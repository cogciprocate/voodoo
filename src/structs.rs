//! Structs.
//! 
// 
// NOTE: Do not edit this file directly; it is auto-generated.


use std::ffi::{CStr};
use std::marker::PhantomData;
use std::slice;
use libc::{c_void, c_char};
use ::*;
use vks;
use vks::{PFN_vkAllocationFunction, PFN_vkReallocationFunction, PFN_vkFreeFunction, 
    PFN_vkInternalAllocationNotification, PFN_vkInternalFreeNotification, 
    PFN_vkDebugReportCallbackEXT};



/// A `VkOffset2D`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct Offset2d {
    raw: vks::VkOffset2D,
}

impl Offset2d {
    pub fn builder() -> Offset2dBuilder {
        Offset2dBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkOffset2D) -> Offset2d {
        Offset2d { raw, }
    }

    pub fn x<'a>(&'a self) -> i32 {
        self.raw.x.into()
    }

    pub fn y<'a>(&'a self) -> i32 {
        self.raw.y.into()
    }

    pub fn set_x<'m>(&mut self, x: i32) {
        self.raw.x = x.into();
    }

    pub fn set_y<'m>(&mut self, y: i32) {
        self.raw.y = y.into();
    }

    pub fn as_raw(&self) -> &vks::VkOffset2D {
        &self.raw
    }
}

impl From<Offset2d> for vks::VkOffset2D {
    fn from(f: Offset2d) -> vks::VkOffset2D {
        f.raw
    }
}


/// A builder for `VkOffset2D`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct Offset2dBuilder {
    raw: vks::VkOffset2D,
}

impl Offset2dBuilder {
    pub fn new() -> Offset2dBuilder {
        Offset2dBuilder {
            raw: vks::VkOffset2D::default(),
        }
    }

    pub fn x<'m>(mut self, x: i32) -> Offset2dBuilder {
        self.raw.x = x.into();
        self
    }

    pub fn y<'m>(mut self, y: i32) -> Offset2dBuilder {
        self.raw.y = y.into();
        self
    }

    pub fn get_x<'a>(&'a self) -> i32 {
        self.raw.x.into()
    }

    pub fn get_y<'a>(&'a self) -> i32 {
        self.raw.y.into()
    }

    pub fn build(self) -> Offset2d {
        Offset2d {
            raw: self.raw,
        }
    }
}


/// A `VkOffset3D`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct Offset3d {
    raw: vks::VkOffset3D,
}

impl Offset3d {
    pub fn builder() -> Offset3dBuilder {
        Offset3dBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkOffset3D) -> Offset3d {
        Offset3d { raw, }
    }

    pub fn x<'a>(&'a self) -> i32 {
        self.raw.x.into()
    }

    pub fn y<'a>(&'a self) -> i32 {
        self.raw.y.into()
    }

    pub fn z<'a>(&'a self) -> i32 {
        self.raw.z.into()
    }

    pub fn set_x<'m>(&mut self, x: i32) {
        self.raw.x = x.into();
    }

    pub fn set_y<'m>(&mut self, y: i32) {
        self.raw.y = y.into();
    }

    pub fn set_z<'m>(&mut self, z: i32) {
        self.raw.z = z.into();
    }

    pub fn as_raw(&self) -> &vks::VkOffset3D {
        &self.raw
    }
}

impl From<Offset3d> for vks::VkOffset3D {
    fn from(f: Offset3d) -> vks::VkOffset3D {
        f.raw
    }
}


/// A builder for `VkOffset3D`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct Offset3dBuilder {
    raw: vks::VkOffset3D,
}

impl Offset3dBuilder {
    pub fn new() -> Offset3dBuilder {
        Offset3dBuilder {
            raw: vks::VkOffset3D::default(),
        }
    }

    pub fn x<'m>(mut self, x: i32) -> Offset3dBuilder {
        self.raw.x = x.into();
        self
    }

    pub fn y<'m>(mut self, y: i32) -> Offset3dBuilder {
        self.raw.y = y.into();
        self
    }

    pub fn z<'m>(mut self, z: i32) -> Offset3dBuilder {
        self.raw.z = z.into();
        self
    }

    pub fn get_x<'a>(&'a self) -> i32 {
        self.raw.x.into()
    }

    pub fn get_y<'a>(&'a self) -> i32 {
        self.raw.y.into()
    }

    pub fn get_z<'a>(&'a self) -> i32 {
        self.raw.z.into()
    }

    pub fn build(self) -> Offset3d {
        Offset3d {
            raw: self.raw,
        }
    }
}


/// A `VkExtent2D`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct Extent2d {
    raw: vks::VkExtent2D,
}

impl Extent2d {
    pub fn builder() -> Extent2dBuilder {
        Extent2dBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExtent2D) -> Extent2d {
        Extent2d { raw, }
    }

    pub fn width<'a>(&'a self) -> u32 {
        self.raw.width.into()
    }

    pub fn height<'a>(&'a self) -> u32 {
        self.raw.height.into()
    }

    pub fn set_width<'m>(&mut self, width: u32) {
        self.raw.width = width.into();
    }

    pub fn set_height<'m>(&mut self, height: u32) {
        self.raw.height = height.into();
    }

    pub fn as_raw(&self) -> &vks::VkExtent2D {
        &self.raw
    }
}

impl From<Extent2d> for vks::VkExtent2D {
    fn from(f: Extent2d) -> vks::VkExtent2D {
        f.raw
    }
}


/// A builder for `VkExtent2D`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct Extent2dBuilder {
    raw: vks::VkExtent2D,
}

impl Extent2dBuilder {
    pub fn new() -> Extent2dBuilder {
        Extent2dBuilder {
            raw: vks::VkExtent2D::default(),
        }
    }

    pub fn width<'m>(mut self, width: u32) -> Extent2dBuilder {
        self.raw.width = width.into();
        self
    }

    pub fn height<'m>(mut self, height: u32) -> Extent2dBuilder {
        self.raw.height = height.into();
        self
    }

    pub fn get_width<'a>(&'a self) -> u32 {
        self.raw.width.into()
    }

    pub fn get_height<'a>(&'a self) -> u32 {
        self.raw.height.into()
    }

    pub fn build(self) -> Extent2d {
        Extent2d {
            raw: self.raw,
        }
    }
}


/// A `VkExtent3D`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct Extent3d {
    raw: vks::VkExtent3D,
}

impl Extent3d {
    pub fn builder() -> Extent3dBuilder {
        Extent3dBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExtent3D) -> Extent3d {
        Extent3d { raw, }
    }

    pub fn width<'a>(&'a self) -> u32 {
        self.raw.width.into()
    }

    pub fn height<'a>(&'a self) -> u32 {
        self.raw.height.into()
    }

    pub fn depth<'a>(&'a self) -> u32 {
        self.raw.depth.into()
    }

    pub fn set_width<'m>(&mut self, width: u32) {
        self.raw.width = width.into();
    }

    pub fn set_height<'m>(&mut self, height: u32) {
        self.raw.height = height.into();
    }

    pub fn set_depth<'m>(&mut self, depth: u32) {
        self.raw.depth = depth.into();
    }

    pub fn as_raw(&self) -> &vks::VkExtent3D {
        &self.raw
    }
}

impl From<Extent3d> for vks::VkExtent3D {
    fn from(f: Extent3d) -> vks::VkExtent3D {
        f.raw
    }
}


/// A builder for `VkExtent3D`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct Extent3dBuilder {
    raw: vks::VkExtent3D,
}

impl Extent3dBuilder {
    pub fn new() -> Extent3dBuilder {
        Extent3dBuilder {
            raw: vks::VkExtent3D::default(),
        }
    }

    pub fn width<'m>(mut self, width: u32) -> Extent3dBuilder {
        self.raw.width = width.into();
        self
    }

    pub fn height<'m>(mut self, height: u32) -> Extent3dBuilder {
        self.raw.height = height.into();
        self
    }

    pub fn depth<'m>(mut self, depth: u32) -> Extent3dBuilder {
        self.raw.depth = depth.into();
        self
    }

    pub fn get_width<'a>(&'a self) -> u32 {
        self.raw.width.into()
    }

    pub fn get_height<'a>(&'a self) -> u32 {
        self.raw.height.into()
    }

    pub fn get_depth<'a>(&'a self) -> u32 {
        self.raw.depth.into()
    }

    pub fn build(self) -> Extent3d {
        Extent3d {
            raw: self.raw,
        }
    }
}


/// A `VkViewport`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct Viewport {
    raw: vks::VkViewport,
}

impl Viewport {
    pub fn builder() -> ViewportBuilder {
        ViewportBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkViewport) -> Viewport {
        Viewport { raw, }
    }

    pub fn x<'a>(&'a self) -> f32 {
        self.raw.x.into()
    }

    pub fn y<'a>(&'a self) -> f32 {
        self.raw.y.into()
    }

    pub fn width<'a>(&'a self) -> f32 {
        self.raw.width.into()
    }

    pub fn height<'a>(&'a self) -> f32 {
        self.raw.height.into()
    }

    pub fn min_depth<'a>(&'a self) -> f32 {
        self.raw.minDepth.into()
    }

    pub fn max_depth<'a>(&'a self) -> f32 {
        self.raw.maxDepth.into()
    }

    pub fn set_x<'m>(&mut self, x: f32) {
        self.raw.x = x.into();
    }

    pub fn set_y<'m>(&mut self, y: f32) {
        self.raw.y = y.into();
    }

    pub fn set_width<'m>(&mut self, width: f32) {
        self.raw.width = width.into();
    }

    pub fn set_height<'m>(&mut self, height: f32) {
        self.raw.height = height.into();
    }

    pub fn set_min_depth<'m>(&mut self, min_depth: f32) {
        self.raw.minDepth = min_depth.into();
    }

    pub fn set_max_depth<'m>(&mut self, max_depth: f32) {
        self.raw.maxDepth = max_depth.into();
    }

    pub fn as_raw(&self) -> &vks::VkViewport {
        &self.raw
    }
}

impl From<Viewport> for vks::VkViewport {
    fn from(f: Viewport) -> vks::VkViewport {
        f.raw
    }
}


/// A builder for `VkViewport`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ViewportBuilder {
    raw: vks::VkViewport,
}

impl ViewportBuilder {
    pub fn new() -> ViewportBuilder {
        ViewportBuilder {
            raw: vks::VkViewport::default(),
        }
    }

    pub fn x<'m>(mut self, x: f32) -> ViewportBuilder {
        self.raw.x = x.into();
        self
    }

    pub fn y<'m>(mut self, y: f32) -> ViewportBuilder {
        self.raw.y = y.into();
        self
    }

    pub fn width<'m>(mut self, width: f32) -> ViewportBuilder {
        self.raw.width = width.into();
        self
    }

    pub fn height<'m>(mut self, height: f32) -> ViewportBuilder {
        self.raw.height = height.into();
        self
    }

    pub fn min_depth<'m>(mut self, min_depth: f32) -> ViewportBuilder {
        self.raw.minDepth = min_depth.into();
        self
    }

    pub fn max_depth<'m>(mut self, max_depth: f32) -> ViewportBuilder {
        self.raw.maxDepth = max_depth.into();
        self
    }

    pub fn get_x<'a>(&'a self) -> f32 {
        self.raw.x.into()
    }

    pub fn get_y<'a>(&'a self) -> f32 {
        self.raw.y.into()
    }

    pub fn get_width<'a>(&'a self) -> f32 {
        self.raw.width.into()
    }

    pub fn get_height<'a>(&'a self) -> f32 {
        self.raw.height.into()
    }

    pub fn get_min_depth<'a>(&'a self) -> f32 {
        self.raw.minDepth.into()
    }

    pub fn get_max_depth<'a>(&'a self) -> f32 {
        self.raw.maxDepth.into()
    }

    pub fn build(self) -> Viewport {
        Viewport {
            raw: self.raw,
        }
    }
}


/// A `VkRect2D`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct Rect2d {
    raw: vks::VkRect2D,
}

impl Rect2d {
    pub fn builder() -> Rect2dBuilder {
        Rect2dBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkRect2D) -> Rect2d {
        Rect2d { raw, }
    }

    pub fn offset<'a>(&'a self) -> &'a Offset2d {
        unsafe { &*(&self.raw.offset as *const vks::VkOffset2D as *const Offset2d) }
    }

    pub fn offset_mut<'a>(&'a mut self) -> &'a mut Offset2d {
        unsafe { &mut *(&mut self.raw.offset as *mut  vks::VkOffset2D as *mut Offset2d) }
    }

    pub fn extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.extent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn set_offset<'m>(&mut self, offset: Offset2d) {
        self.raw.offset = offset.raw;
    }

    pub fn set_extent<'m>(&mut self, extent: Extent2d) {
        self.raw.extent = extent.raw;
    }

    pub fn as_raw(&self) -> &vks::VkRect2D {
        &self.raw
    }
}

impl From<Rect2d> for vks::VkRect2D {
    fn from(f: Rect2d) -> vks::VkRect2D {
        f.raw
    }
}


/// A builder for `VkRect2D`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct Rect2dBuilder {
    raw: vks::VkRect2D,
}

impl Rect2dBuilder {
    pub fn new() -> Rect2dBuilder {
        Rect2dBuilder {
            raw: vks::VkRect2D::default(),
        }
    }

    pub fn offset<'m>(mut self, offset: Offset2d) -> Rect2dBuilder {
        self.raw.offset = offset.raw;
        self
    }

    pub fn extent<'m>(mut self, extent: Extent2d) -> Rect2dBuilder {
        self.raw.extent = extent.raw;
        self
    }

    pub fn get_offset<'a>(&'a self) -> &'a Offset2d {
        unsafe { &*(&self.raw.offset as *const vks::VkOffset2D as *const Offset2d) }
    }

    pub fn get_offset_mut<'a>(&'a mut self) -> &'a mut Offset2d {
        unsafe { &mut *(&mut self.raw.offset as *mut  vks::VkOffset2D as *mut Offset2d) }
    }

    pub fn get_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.extent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn get_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn build(self) -> Rect2d {
        Rect2d {
            raw: self.raw,
        }
    }
}


/// A `VkClearRect`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ClearRect {
    raw: vks::VkClearRect,
}

impl ClearRect {
    pub fn builder() -> ClearRectBuilder {
        ClearRectBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkClearRect) -> ClearRect {
        ClearRect { raw, }
    }

    pub fn rect<'a>(&'a self) -> &'a Rect2d {
        unsafe { &*(&self.raw.rect as *const vks::VkRect2D as *const Rect2d) }
    }

    pub fn rect_mut<'a>(&'a mut self) -> &'a mut Rect2d {
        unsafe { &mut *(&mut self.raw.rect as *mut  vks::VkRect2D as *mut Rect2d) }
    }

    pub fn base_array_layer<'a>(&'a self) -> u32 {
        self.raw.baseArrayLayer.into()
    }

    pub fn layer_count<'a>(&'a self) -> u32 {
        self.raw.layerCount.into()
    }

    pub fn set_rect<'m>(&mut self, rect: Rect2d) {
        self.raw.rect = rect.raw;
    }

    pub fn set_base_array_layer<'m>(&mut self, base_array_layer: u32) {
        self.raw.baseArrayLayer = base_array_layer.into();
    }

    pub fn set_layer_count<'m>(&mut self, layer_count: u32) {
        self.raw.layerCount = layer_count.into();
    }

    pub fn as_raw(&self) -> &vks::VkClearRect {
        &self.raw
    }
}

impl From<ClearRect> for vks::VkClearRect {
    fn from(f: ClearRect) -> vks::VkClearRect {
        f.raw
    }
}


/// A builder for `VkClearRect`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ClearRectBuilder {
    raw: vks::VkClearRect,
}

impl ClearRectBuilder {
    pub fn new() -> ClearRectBuilder {
        ClearRectBuilder {
            raw: vks::VkClearRect::default(),
        }
    }

    pub fn rect<'m>(mut self, rect: Rect2d) -> ClearRectBuilder {
        self.raw.rect = rect.raw;
        self
    }

    pub fn base_array_layer<'m>(mut self, base_array_layer: u32) -> ClearRectBuilder {
        self.raw.baseArrayLayer = base_array_layer.into();
        self
    }

    pub fn layer_count<'m>(mut self, layer_count: u32) -> ClearRectBuilder {
        self.raw.layerCount = layer_count.into();
        self
    }

    pub fn get_rect<'a>(&'a self) -> &'a Rect2d {
        unsafe { &*(&self.raw.rect as *const vks::VkRect2D as *const Rect2d) }
    }

    pub fn get_rect_mut<'a>(&'a mut self) -> &'a mut Rect2d {
        unsafe { &mut *(&mut self.raw.rect as *mut  vks::VkRect2D as *mut Rect2d) }
    }

    pub fn get_base_array_layer<'a>(&'a self) -> u32 {
        self.raw.baseArrayLayer.into()
    }

    pub fn get_layer_count<'a>(&'a self) -> u32 {
        self.raw.layerCount.into()
    }

    pub fn build(self) -> ClearRect {
        ClearRect {
            raw: self.raw,
        }
    }
}


/// A `VkComponentMapping`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ComponentMapping {
    raw: vks::VkComponentMapping,
}

impl ComponentMapping {
    pub fn builder() -> ComponentMappingBuilder {
        ComponentMappingBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkComponentMapping) -> ComponentMapping {
        ComponentMapping { raw, }
    }

    pub fn r<'a>(&'a self) -> ComponentSwizzle {
        self.raw.r.into()
    }

    pub fn g<'a>(&'a self) -> ComponentSwizzle {
        self.raw.g.into()
    }

    pub fn b<'a>(&'a self) -> ComponentSwizzle {
        self.raw.b.into()
    }

    pub fn a<'a>(&'a self) -> ComponentSwizzle {
        self.raw.a.into()
    }

    pub fn set_r<'m>(&mut self, r: ComponentSwizzle) {
        self.raw.r = r.into();
    }

    pub fn set_g<'m>(&mut self, g: ComponentSwizzle) {
        self.raw.g = g.into();
    }

    pub fn set_b<'m>(&mut self, b: ComponentSwizzle) {
        self.raw.b = b.into();
    }

    pub fn set_a<'m>(&mut self, a: ComponentSwizzle) {
        self.raw.a = a.into();
    }

    pub fn as_raw(&self) -> &vks::VkComponentMapping {
        &self.raw
    }
}

impl From<ComponentMapping> for vks::VkComponentMapping {
    fn from(f: ComponentMapping) -> vks::VkComponentMapping {
        f.raw
    }
}


/// A builder for `VkComponentMapping`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ComponentMappingBuilder {
    raw: vks::VkComponentMapping,
}

impl ComponentMappingBuilder {
    pub fn new() -> ComponentMappingBuilder {
        ComponentMappingBuilder {
            raw: vks::VkComponentMapping::default(),
        }
    }

    pub fn r<'m>(mut self, r: ComponentSwizzle) -> ComponentMappingBuilder {
        self.raw.r = r.into();
        self
    }

    pub fn g<'m>(mut self, g: ComponentSwizzle) -> ComponentMappingBuilder {
        self.raw.g = g.into();
        self
    }

    pub fn b<'m>(mut self, b: ComponentSwizzle) -> ComponentMappingBuilder {
        self.raw.b = b.into();
        self
    }

    pub fn a<'m>(mut self, a: ComponentSwizzle) -> ComponentMappingBuilder {
        self.raw.a = a.into();
        self
    }

    pub fn get_r<'a>(&'a self) -> ComponentSwizzle {
        self.raw.r.into()
    }

    pub fn get_g<'a>(&'a self) -> ComponentSwizzle {
        self.raw.g.into()
    }

    pub fn get_b<'a>(&'a self) -> ComponentSwizzle {
        self.raw.b.into()
    }

    pub fn get_a<'a>(&'a self) -> ComponentSwizzle {
        self.raw.a.into()
    }

    pub fn build(self) -> ComponentMapping {
        ComponentMapping {
            raw: self.raw,
        }
    }
}


/// A `VkPhysicalDeviceProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceProperties {
    raw: vks::VkPhysicalDeviceProperties,
}

impl PhysicalDeviceProperties {
    pub fn builder() -> PhysicalDevicePropertiesBuilder {
        PhysicalDevicePropertiesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceProperties) -> PhysicalDeviceProperties {
        PhysicalDeviceProperties { raw, }
    }

    pub fn api_version<'a>(&'a self) -> Version {
        self.raw.apiVersion.into()
    }

    pub fn driver_version<'a>(&'a self) -> u32 {
        self.raw.driverVersion.into()
    }

    pub fn vendor_id<'a>(&'a self) -> u32 {
        self.raw.vendorID.into()
    }

    pub fn device_id<'a>(&'a self) -> u32 {
        self.raw.deviceID.into()
    }

    pub fn device_type<'a>(&'a self) -> PhysicalDeviceType {
        self.raw.deviceType.into()
    }

    pub fn device_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(&self.raw.deviceName as *const _) }
    }

    pub fn pipeline_cache_uuid<'a>(&'a self) -> &[u8] {
        unsafe { slice::from_raw_parts(&self.raw.pipelineCacheUUID as *const _, vks::VK_UUID_SIZE as usize) }
    }

    pub fn limits<'a>(&'a self) -> &'a PhysicalDeviceLimits {
        unsafe { &*(&self.raw.limits as *const vks::VkPhysicalDeviceLimits as *const PhysicalDeviceLimits) }
    }

    pub fn limits_mut<'a>(&'a mut self) -> &'a mut PhysicalDeviceLimits {
        unsafe { &mut *(&mut self.raw.limits as *mut  vks::VkPhysicalDeviceLimits as *mut PhysicalDeviceLimits) }
    }

    pub fn sparse_properties<'a>(&'a self) -> &'a PhysicalDeviceSparseProperties {
        unsafe { &*(&self.raw.sparseProperties as *const vks::VkPhysicalDeviceSparseProperties as *const PhysicalDeviceSparseProperties) }
    }

    pub fn sparse_properties_mut<'a>(&'a mut self) -> &'a mut PhysicalDeviceSparseProperties {
        unsafe { &mut *(&mut self.raw.sparseProperties as *mut  vks::VkPhysicalDeviceSparseProperties as *mut PhysicalDeviceSparseProperties) }
    }

    pub fn set_api_version<'m, T>(&mut self, api_version: T)
            where T: Into<Version> {
        self.raw.apiVersion = api_version.into().into();
    }

    pub fn set_driver_version<'m>(&mut self, driver_version: u32) {
        self.raw.driverVersion = driver_version.into();
    }

    pub fn set_vendor_id<'m>(&mut self, vendor_id: u32) {
        self.raw.vendorID = vendor_id.into();
    }

    pub fn set_device_id<'m>(&mut self, device_id: u32) {
        self.raw.deviceID = device_id.into();
    }

    pub fn set_device_type<'m>(&mut self, device_type: PhysicalDeviceType) {
        self.raw.deviceType = device_type.into();
    }

    pub unsafe fn set_device_name<'m>(&mut self, device_name: [i8; vks::VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]) {
        self.raw.deviceName = device_name;
    }

    pub fn set_pipeline_cache_uuid<'m>(&mut self, pipeline_cache_uuid: [u8; vks::VK_UUID_SIZE]) {
        self.raw.pipelineCacheUUID = pipeline_cache_uuid;
    }

    pub fn set_limits<'m>(&mut self, limits: PhysicalDeviceLimits) {
        self.raw.limits = limits.raw;
    }

    pub fn set_sparse_properties<'m>(&mut self, sparse_properties: PhysicalDeviceSparseProperties) {
        self.raw.sparseProperties = sparse_properties.raw;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceProperties {
        &self.raw
    }
}

impl From<PhysicalDeviceProperties> for vks::VkPhysicalDeviceProperties {
    fn from(f: PhysicalDeviceProperties) -> vks::VkPhysicalDeviceProperties {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDevicePropertiesBuilder {
    raw: vks::VkPhysicalDeviceProperties,
}

impl PhysicalDevicePropertiesBuilder {
    pub fn new() -> PhysicalDevicePropertiesBuilder {
        PhysicalDevicePropertiesBuilder {
            raw: vks::VkPhysicalDeviceProperties::default(),
        }
    }

    pub fn api_version<'m, T>(mut self, api_version: T) -> PhysicalDevicePropertiesBuilder
            where T: Into<Version> {
        self.raw.apiVersion = api_version.into().into();
        self
    }

    pub fn driver_version<'m>(mut self, driver_version: u32) -> PhysicalDevicePropertiesBuilder {
        self.raw.driverVersion = driver_version.into();
        self
    }

    pub fn vendor_id<'m>(mut self, vendor_id: u32) -> PhysicalDevicePropertiesBuilder {
        self.raw.vendorID = vendor_id.into();
        self
    }

    pub fn device_id<'m>(mut self, device_id: u32) -> PhysicalDevicePropertiesBuilder {
        self.raw.deviceID = device_id.into();
        self
    }

    pub fn device_type<'m>(mut self, device_type: PhysicalDeviceType) -> PhysicalDevicePropertiesBuilder {
        self.raw.deviceType = device_type.into();
        self
    }

    pub unsafe fn device_name<'m>(mut self, device_name: [i8; vks::VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]) -> PhysicalDevicePropertiesBuilder {
        self.raw.deviceName = device_name;
        self
    }

    pub fn pipeline_cache_uuid<'m>(mut self, pipeline_cache_uuid: [u8; vks::VK_UUID_SIZE]) -> PhysicalDevicePropertiesBuilder {
        self.raw.pipelineCacheUUID = pipeline_cache_uuid;
        self
    }

    pub fn limits<'m>(mut self, limits: PhysicalDeviceLimits) -> PhysicalDevicePropertiesBuilder {
        self.raw.limits = limits.raw;
        self
    }

    pub fn sparse_properties<'m>(mut self, sparse_properties: PhysicalDeviceSparseProperties) -> PhysicalDevicePropertiesBuilder {
        self.raw.sparseProperties = sparse_properties.raw;
        self
    }

    pub fn get_api_version<'a>(&'a self) -> Version {
        self.raw.apiVersion.into()
    }

    pub fn get_driver_version<'a>(&'a self) -> u32 {
        self.raw.driverVersion.into()
    }

    pub fn get_vendor_id<'a>(&'a self) -> u32 {
        self.raw.vendorID.into()
    }

    pub fn get_device_id<'a>(&'a self) -> u32 {
        self.raw.deviceID.into()
    }

    pub fn get_device_type<'a>(&'a self) -> PhysicalDeviceType {
        self.raw.deviceType.into()
    }

    pub fn get_device_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(&self.raw.deviceName as *const _) }
    }

    pub fn get_pipeline_cache_uuid<'a>(&'a self) -> &[u8] {
        unsafe { slice::from_raw_parts(&self.raw.pipelineCacheUUID as *const _, vks::VK_UUID_SIZE as usize) }
    }

    pub fn get_limits<'a>(&'a self) -> &'a PhysicalDeviceLimits {
        unsafe { &*(&self.raw.limits as *const vks::VkPhysicalDeviceLimits as *const PhysicalDeviceLimits) }
    }

    pub fn get_limits_mut<'a>(&'a mut self) -> &'a mut PhysicalDeviceLimits {
        unsafe { &mut *(&mut self.raw.limits as *mut  vks::VkPhysicalDeviceLimits as *mut PhysicalDeviceLimits) }
    }

    pub fn get_sparse_properties<'a>(&'a self) -> &'a PhysicalDeviceSparseProperties {
        unsafe { &*(&self.raw.sparseProperties as *const vks::VkPhysicalDeviceSparseProperties as *const PhysicalDeviceSparseProperties) }
    }

    pub fn get_sparse_properties_mut<'a>(&'a mut self) -> &'a mut PhysicalDeviceSparseProperties {
        unsafe { &mut *(&mut self.raw.sparseProperties as *mut  vks::VkPhysicalDeviceSparseProperties as *mut PhysicalDeviceSparseProperties) }
    }

    pub fn build(self) -> PhysicalDeviceProperties {
        PhysicalDeviceProperties {
            raw: self.raw,
        }
    }
}


/// A `VkExtensionProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExtensionProperties {
    raw: vks::VkExtensionProperties,
}

impl ExtensionProperties {
    pub fn builder() -> ExtensionPropertiesBuilder {
        ExtensionPropertiesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExtensionProperties) -> ExtensionProperties {
        ExtensionProperties { raw, }
    }

    pub fn extension_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(&self.raw.extensionName as *const _) }
    }

    pub fn spec_version<'a>(&'a self) -> Version {
        self.raw.specVersion.into()
    }

    pub unsafe fn set_extension_name<'m>(&mut self, extension_name: [i8; vks::VK_MAX_EXTENSION_NAME_SIZE]) {
        self.raw.extensionName = extension_name;
    }

    pub fn set_spec_version<'m, T>(&mut self, spec_version: T)
            where T: Into<Version> {
        self.raw.specVersion = spec_version.into().into();
    }

    pub fn as_raw(&self) -> &vks::VkExtensionProperties {
        &self.raw
    }
}

impl From<ExtensionProperties> for vks::VkExtensionProperties {
    fn from(f: ExtensionProperties) -> vks::VkExtensionProperties {
        f.raw
    }
}


/// A builder for `VkExtensionProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExtensionPropertiesBuilder {
    raw: vks::VkExtensionProperties,
}

impl ExtensionPropertiesBuilder {
    pub fn new() -> ExtensionPropertiesBuilder {
        ExtensionPropertiesBuilder {
            raw: vks::VkExtensionProperties::default(),
        }
    }

    pub unsafe fn extension_name<'m>(mut self, extension_name: [i8; vks::VK_MAX_EXTENSION_NAME_SIZE]) -> ExtensionPropertiesBuilder {
        self.raw.extensionName = extension_name;
        self
    }

    pub fn spec_version<'m, T>(mut self, spec_version: T) -> ExtensionPropertiesBuilder
            where T: Into<Version> {
        self.raw.specVersion = spec_version.into().into();
        self
    }

    pub fn get_extension_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(&self.raw.extensionName as *const _) }
    }

    pub fn get_spec_version<'a>(&'a self) -> Version {
        self.raw.specVersion.into()
    }

    pub fn build(self) -> ExtensionProperties {
        ExtensionProperties {
            raw: self.raw,
        }
    }
}


/// A `VkLayerProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct LayerProperties {
    raw: vks::VkLayerProperties,
}

impl LayerProperties {
    pub fn builder() -> LayerPropertiesBuilder {
        LayerPropertiesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkLayerProperties) -> LayerProperties {
        LayerProperties { raw, }
    }

    pub fn layer_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(&self.raw.layerName as *const _) }
    }

    pub fn spec_version<'a>(&'a self) -> Version {
        self.raw.specVersion.into()
    }

    pub fn implementation_version<'a>(&'a self) -> Version {
        self.raw.implementationVersion.into()
    }

    pub fn description<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(&self.raw.description as *const _) }
    }

    pub unsafe fn set_layer_name<'m>(&mut self, layer_name: [i8; vks::VK_MAX_EXTENSION_NAME_SIZE]) {
        self.raw.layerName = layer_name;
    }

    pub fn set_spec_version<'m, T>(&mut self, spec_version: T)
            where T: Into<Version> {
        self.raw.specVersion = spec_version.into().into();
    }

    pub fn set_implementation_version<'m, T>(&mut self, implementation_version: T)
            where T: Into<Version> {
        self.raw.implementationVersion = implementation_version.into().into();
    }

    pub unsafe fn set_description<'m>(&mut self, description: [i8; vks::VK_MAX_DESCRIPTION_SIZE]) {
        self.raw.description = description;
    }

    pub fn as_raw(&self) -> &vks::VkLayerProperties {
        &self.raw
    }
}

impl From<LayerProperties> for vks::VkLayerProperties {
    fn from(f: LayerProperties) -> vks::VkLayerProperties {
        f.raw
    }
}


/// A builder for `VkLayerProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct LayerPropertiesBuilder {
    raw: vks::VkLayerProperties,
}

impl LayerPropertiesBuilder {
    pub fn new() -> LayerPropertiesBuilder {
        LayerPropertiesBuilder {
            raw: vks::VkLayerProperties::default(),
        }
    }

    pub unsafe fn layer_name<'m>(mut self, layer_name: [i8; vks::VK_MAX_EXTENSION_NAME_SIZE]) -> LayerPropertiesBuilder {
        self.raw.layerName = layer_name;
        self
    }

    pub fn spec_version<'m, T>(mut self, spec_version: T) -> LayerPropertiesBuilder
            where T: Into<Version> {
        self.raw.specVersion = spec_version.into().into();
        self
    }

    pub fn implementation_version<'m, T>(mut self, implementation_version: T) -> LayerPropertiesBuilder
            where T: Into<Version> {
        self.raw.implementationVersion = implementation_version.into().into();
        self
    }

    pub unsafe fn description<'m>(mut self, description: [i8; vks::VK_MAX_DESCRIPTION_SIZE]) -> LayerPropertiesBuilder {
        self.raw.description = description;
        self
    }

    pub fn get_layer_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(&self.raw.layerName as *const _) }
    }

    pub fn get_spec_version<'a>(&'a self) -> Version {
        self.raw.specVersion.into()
    }

    pub fn get_implementation_version<'a>(&'a self) -> Version {
        self.raw.implementationVersion.into()
    }

    pub fn get_description<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(&self.raw.description as *const _) }
    }

    pub fn build(self) -> LayerProperties {
        LayerProperties {
            raw: self.raw,
        }
    }
}


/// A `VkApplicationInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ApplicationInfo<'s> {
    raw: vks::VkApplicationInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> ApplicationInfo<'s> {
    pub fn builder<'b>() -> ApplicationInfoBuilder<'b> {
        ApplicationInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkApplicationInfo) -> ApplicationInfo<'s> {
        ApplicationInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn application_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(self.raw.pApplicationName) }
    }

    pub fn application_version<'a>(&'a self) -> Version {
        self.raw.applicationVersion.into()
    }

    pub fn engine_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(self.raw.pEngineName) }
    }

    pub fn engine_version<'a>(&'a self) -> Version {
        self.raw.engineVersion.into()
    }

    pub fn api_version<'a>(&'a self) -> Version {
        self.raw.apiVersion.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_application_name<'m, 'a>(&mut self, application_name: &'a CStr)
            where 'a: 's {
        self.raw.pApplicationName = application_name.as_ptr();
    }

    pub fn set_application_version<'m, T>(&mut self, application_version: T)
            where T: Into<Version> {
        self.raw.applicationVersion = application_version.into().into();
    }

    pub fn set_engine_name<'m, 'a>(&mut self, engine_name: &'a CStr)
            where 'a: 's {
        self.raw.pEngineName = engine_name.as_ptr();
    }

    pub fn set_engine_version<'m, T>(&mut self, engine_version: T)
            where T: Into<Version> {
        self.raw.engineVersion = engine_version.into().into();
    }

    pub fn set_api_version<'m, T>(&mut self, api_version: T)
            where T: Into<Version> {
        self.raw.apiVersion = api_version.into().into();
    }

    pub fn as_raw(&self) -> &vks::VkApplicationInfo {
        &self.raw
    }
}

impl<'s> From<ApplicationInfo<'s>> for vks::VkApplicationInfo {
    fn from(f: ApplicationInfo<'s>) -> vks::VkApplicationInfo {
        f.raw
    }
}


/// A builder for `VkApplicationInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ApplicationInfoBuilder<'b> {
    raw: vks::VkApplicationInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ApplicationInfoBuilder<'b> {
    pub fn new() -> ApplicationInfoBuilder<'b> {
        ApplicationInfoBuilder {
            raw: vks::VkApplicationInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ApplicationInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn application_name<'m, 'a>(mut self, application_name: &'a CStr) -> ApplicationInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pApplicationName = application_name.as_ptr();
        self
    }

    pub fn application_version<'m, T>(mut self, application_version: T) -> ApplicationInfoBuilder<'b>
            where T: Into<Version> {
        self.raw.applicationVersion = application_version.into().into();
        self
    }

    pub fn engine_name<'m, 'a>(mut self, engine_name: &'a CStr) -> ApplicationInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pEngineName = engine_name.as_ptr();
        self
    }

    pub fn engine_version<'m, T>(mut self, engine_version: T) -> ApplicationInfoBuilder<'b>
            where T: Into<Version> {
        self.raw.engineVersion = engine_version.into().into();
        self
    }

    pub fn api_version<'m, T>(mut self, api_version: T) -> ApplicationInfoBuilder<'b>
            where T: Into<Version> {
        self.raw.apiVersion = api_version.into().into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_application_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(self.raw.pApplicationName) }
    }

    pub fn get_application_version<'a>(&'a self) -> Version {
        self.raw.applicationVersion.into()
    }

    pub fn get_engine_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(self.raw.pEngineName) }
    }

    pub fn get_engine_version<'a>(&'a self) -> Version {
        self.raw.engineVersion.into()
    }

    pub fn get_api_version<'a>(&'a self) -> Version {
        self.raw.apiVersion.into()
    }

    pub fn build(self) -> ApplicationInfo<'b> {
        ApplicationInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkAllocationCallbacks`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct AllocationCallbacks<'s> {
    raw: vks::VkAllocationCallbacks,
    _p: PhantomData<&'s ()>,
}

impl<'s> AllocationCallbacks<'s> {
    pub fn builder<'b>() -> AllocationCallbacksBuilder<'b> {
        AllocationCallbacksBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkAllocationCallbacks) -> AllocationCallbacks<'s> {
        AllocationCallbacks { raw, _p: PhantomData }
    }

    pub fn user_data<'a>(&'a self) -> *mut c_void {
        self.raw.pUserData
    }

    pub fn pfn_allocation<'a>(&'a self) -> PFN_vkAllocationFunction {
        self.raw.pfnAllocation.into()
    }

    pub fn pfn_reallocation<'a>(&'a self) -> PFN_vkReallocationFunction {
        self.raw.pfnReallocation.into()
    }

    pub fn pfn_free<'a>(&'a self) -> PFN_vkFreeFunction {
        self.raw.pfnFree.into()
    }

    pub fn pfn_internal_allocation<'a>(&'a self) -> PFN_vkInternalAllocationNotification {
        self.raw.pfnInternalAllocation.into()
    }

    pub fn pfn_internal_free<'a>(&'a self) -> PFN_vkInternalFreeNotification {
        self.raw.pfnInternalFree.into()
    }

    pub unsafe fn set_user_data<'m>(&mut self, user_data: *mut c_void) {
        self.raw.pUserData = user_data;
    }

    pub unsafe fn set_pfn_allocation<'m>(&mut self, pfn_allocation: PFN_vkAllocationFunction) {
        self.raw.pfnAllocation = pfn_allocation.into();
    }

    pub unsafe fn set_pfn_reallocation<'m>(&mut self, pfn_reallocation: PFN_vkReallocationFunction) {
        self.raw.pfnReallocation = pfn_reallocation.into();
    }

    pub unsafe fn set_pfn_free<'m>(&mut self, pfn_free: PFN_vkFreeFunction) {
        self.raw.pfnFree = pfn_free.into();
    }

    pub unsafe fn set_pfn_internal_allocation<'m>(&mut self, pfn_internal_allocation: PFN_vkInternalAllocationNotification) {
        self.raw.pfnInternalAllocation = pfn_internal_allocation.into();
    }

    pub unsafe fn set_pfn_internal_free<'m>(&mut self, pfn_internal_free: PFN_vkInternalFreeNotification) {
        self.raw.pfnInternalFree = pfn_internal_free.into();
    }

    pub fn as_raw(&self) -> &vks::VkAllocationCallbacks {
        &self.raw
    }
}

impl<'s> From<AllocationCallbacks<'s>> for vks::VkAllocationCallbacks {
    fn from(f: AllocationCallbacks<'s>) -> vks::VkAllocationCallbacks {
        f.raw
    }
}


/// A builder for `VkAllocationCallbacks`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct AllocationCallbacksBuilder<'b> {
    raw: vks::VkAllocationCallbacks,
    _p: PhantomData<&'b ()>, 
}

impl<'b> AllocationCallbacksBuilder<'b> {
    pub fn new() -> AllocationCallbacksBuilder<'b> {
        AllocationCallbacksBuilder {
            raw: vks::VkAllocationCallbacks::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn user_data<'m>(mut self, user_data: *mut c_void) -> AllocationCallbacksBuilder<'b> {
        self.raw.pUserData = user_data;
        self
    }

    pub unsafe fn pfn_allocation<'m>(mut self, pfn_allocation: PFN_vkAllocationFunction) -> AllocationCallbacksBuilder<'b> {
        self.raw.pfnAllocation = pfn_allocation.into();
        self
    }

    pub unsafe fn pfn_reallocation<'m>(mut self, pfn_reallocation: PFN_vkReallocationFunction) -> AllocationCallbacksBuilder<'b> {
        self.raw.pfnReallocation = pfn_reallocation.into();
        self
    }

    pub unsafe fn pfn_free<'m>(mut self, pfn_free: PFN_vkFreeFunction) -> AllocationCallbacksBuilder<'b> {
        self.raw.pfnFree = pfn_free.into();
        self
    }

    pub unsafe fn pfn_internal_allocation<'m>(mut self, pfn_internal_allocation: PFN_vkInternalAllocationNotification) -> AllocationCallbacksBuilder<'b> {
        self.raw.pfnInternalAllocation = pfn_internal_allocation.into();
        self
    }

    pub unsafe fn pfn_internal_free<'m>(mut self, pfn_internal_free: PFN_vkInternalFreeNotification) -> AllocationCallbacksBuilder<'b> {
        self.raw.pfnInternalFree = pfn_internal_free.into();
        self
    }

    pub fn get_user_data<'a>(&'a self) -> *mut c_void {
        self.raw.pUserData
    }

    pub fn get_pfn_allocation<'a>(&'a self) -> PFN_vkAllocationFunction {
        self.raw.pfnAllocation.into()
    }

    pub fn get_pfn_reallocation<'a>(&'a self) -> PFN_vkReallocationFunction {
        self.raw.pfnReallocation.into()
    }

    pub fn get_pfn_free<'a>(&'a self) -> PFN_vkFreeFunction {
        self.raw.pfnFree.into()
    }

    pub fn get_pfn_internal_allocation<'a>(&'a self) -> PFN_vkInternalAllocationNotification {
        self.raw.pfnInternalAllocation.into()
    }

    pub fn get_pfn_internal_free<'a>(&'a self) -> PFN_vkInternalFreeNotification {
        self.raw.pfnInternalFree.into()
    }

    pub fn build(self) -> AllocationCallbacks<'b> {
        AllocationCallbacks {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceQueueCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceQueueCreateInfo<'s> {
    raw: vks::VkDeviceQueueCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> DeviceQueueCreateInfo<'s> {
    pub fn builder<'b>() -> DeviceQueueCreateInfoBuilder<'b> {
        DeviceQueueCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceQueueCreateInfo) -> DeviceQueueCreateInfo<'s> {
        DeviceQueueCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> DeviceQueueCreateFlags {
        DeviceQueueCreateFlags::from_bits(self.raw.flags)
            .expect("DeviceQueueCreateInfo::flags: error converting flags")
    }

    pub fn queue_family_index<'a>(&'a self) -> u32 {
        self.raw.queueFamilyIndex.into()
    }

    pub fn queue_priorities<'a>(&'a self) -> &'a [f32] {
        unsafe { slice::from_raw_parts(self.raw.pQueuePriorities as *const _, self.raw.queueCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: DeviceQueueCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_queue_family_index<'m>(&mut self, queue_family_index: u32) {
        self.raw.queueFamilyIndex = queue_family_index.into();
    }

    pub fn set_queue_priorities<'m, 'a>(&mut self, queue_priorities: &'a [f32])
            where 'a: 's {
        assert!(self.raw.queueCount == 0 || self.raw.queueCount == queue_priorities.len() as _, 
            "count inconsistency found when specifying `DeviceQueueCreateInfo::queue_priorities`.");
        self.raw.queueCount = queue_priorities.len() as _;
        self.raw.pQueuePriorities = queue_priorities.as_ptr() as *const f32 as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkDeviceQueueCreateInfo {
        &self.raw
    }
}

impl<'s> From<DeviceQueueCreateInfo<'s>> for vks::VkDeviceQueueCreateInfo {
    fn from(f: DeviceQueueCreateInfo<'s>) -> vks::VkDeviceQueueCreateInfo {
        f.raw
    }
}


/// A builder for `VkDeviceQueueCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DeviceQueueCreateInfoBuilder<'b> {
    raw: vks::VkDeviceQueueCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DeviceQueueCreateInfoBuilder<'b> {
    pub fn new() -> DeviceQueueCreateInfoBuilder<'b> {
        DeviceQueueCreateInfoBuilder {
            raw: vks::VkDeviceQueueCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceQueueCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: DeviceQueueCreateFlags) -> DeviceQueueCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn queue_family_index<'m>(mut self, queue_family_index: u32) -> DeviceQueueCreateInfoBuilder<'b> {
        self.raw.queueFamilyIndex = queue_family_index.into();
        self
    }

    pub fn queue_priorities<'m, 'a>(mut self, queue_priorities: &'a [f32]) -> DeviceQueueCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.queueCount == 0 || self.raw.queueCount == queue_priorities.len() as _, 
            "count inconsistency found when specifying `DeviceQueueCreateInfo::queue_priorities`.");
        self.raw.queueCount = queue_priorities.len() as _;
        self.raw.pQueuePriorities = queue_priorities.as_ptr() as *const f32 as *const _;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> DeviceQueueCreateFlags {
        DeviceQueueCreateFlags::from_bits(self.raw.flags)
            .expect("DeviceQueueCreateInfo::flags: error converting flags")
    }

    pub fn get_queue_family_index<'a>(&'a self) -> u32 {
        self.raw.queueFamilyIndex.into()
    }

    pub fn get_queue_priorities<'a>(&'a self) -> &'a [f32] {
        unsafe { slice::from_raw_parts(self.raw.pQueuePriorities as *const _, self.raw.queueCount as usize) }
    }

    pub fn build(self) -> DeviceQueueCreateInfo<'b> {
        DeviceQueueCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceCreateInfo<'s> {
    raw: vks::VkDeviceCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> DeviceCreateInfo<'s> {
    pub fn builder<'b>() -> DeviceCreateInfoBuilder<'b> {
        DeviceCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceCreateInfo) -> DeviceCreateInfo<'s> {
        DeviceCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> DeviceCreateFlags {
        DeviceCreateFlags::from_bits(self.raw.flags)
            .expect("DeviceCreateInfo::flags: error converting flags")
    }

    pub fn queue_create_infos<'a>(&'a self) -> &'a [DeviceQueueCreateInfo] {
        unsafe { slice::from_raw_parts(self.raw.pQueueCreateInfos as *const _, self.raw.queueCreateInfoCount as usize) }
    }

    pub fn enabled_layer_names<'a>(&'a self) -> &'a [*const c_char] {
        unsafe { slice::from_raw_parts(self.raw.ppEnabledLayerNames as *const _, self.raw.enabledLayerCount as usize) }
    }

    pub fn enabled_extension_names<'a>(&'a self) -> &'a [*const c_char] {
        unsafe { slice::from_raw_parts(self.raw.ppEnabledExtensionNames as *const _, self.raw.enabledExtensionCount as usize) }
    }

    pub fn enabled_features<'a>(&'a self) -> &'a PhysicalDeviceFeatures {
        unsafe { &*(self.raw.pEnabledFeatures as *const vks::VkPhysicalDeviceFeatures as *const _) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: DeviceCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_queue_create_infos<'m, 'a>(&mut self, queue_create_infos: &'a [DeviceQueueCreateInfo])
            where 'a: 's {
        assert!(self.raw.queueCreateInfoCount == 0 || self.raw.queueCreateInfoCount == queue_create_infos.len() as _, 
            "count inconsistency found when specifying `DeviceCreateInfo::queue_create_infos`.");
        self.raw.queueCreateInfoCount = queue_create_infos.len() as _;
        self.raw.pQueueCreateInfos = queue_create_infos.as_ptr() as *const vks::VkDeviceQueueCreateInfo;
    }

    pub fn set_enabled_layer_names<'m, 'a>(&mut self, enabled_layer_names: &'a [*const c_char])
            where 'a: 's {
        assert!(self.raw.enabledLayerCount == 0 || self.raw.enabledLayerCount == enabled_layer_names.len() as _, 
            "count inconsistency found when specifying `DeviceCreateInfo::enabled_layer_names`.");
        self.raw.enabledLayerCount = enabled_layer_names.len() as _;
        self.raw.ppEnabledLayerNames = enabled_layer_names.as_ptr();
    }

    pub fn set_enabled_extension_names<'m, 'a>(&mut self, enabled_extension_names: &'a [*const c_char])
            where 'a: 's {
        assert!(self.raw.enabledExtensionCount == 0 || self.raw.enabledExtensionCount == enabled_extension_names.len() as _, 
            "count inconsistency found when specifying `DeviceCreateInfo::enabled_extension_names`.");
        self.raw.enabledExtensionCount = enabled_extension_names.len() as _;
        self.raw.ppEnabledExtensionNames = enabled_extension_names.as_ptr();
    }

    pub fn set_enabled_features<'m, 'a>(&mut self, enabled_features: &'a PhysicalDeviceFeatures)
            where 'a: 's {
        self.raw.pEnabledFeatures = enabled_features.as_raw();
    }

    pub fn as_raw(&self) -> &vks::VkDeviceCreateInfo {
        &self.raw
    }
}

impl<'s> From<DeviceCreateInfo<'s>> for vks::VkDeviceCreateInfo {
    fn from(f: DeviceCreateInfo<'s>) -> vks::VkDeviceCreateInfo {
        f.raw
    }
}


/// A builder for `VkDeviceCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DeviceCreateInfoBuilder<'b> {
    raw: vks::VkDeviceCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DeviceCreateInfoBuilder<'b> {
    pub fn new() -> DeviceCreateInfoBuilder<'b> {
        DeviceCreateInfoBuilder {
            raw: vks::VkDeviceCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: DeviceCreateFlags) -> DeviceCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn queue_create_infos<'m, 'a>(mut self, queue_create_infos: &'a [DeviceQueueCreateInfo]) -> DeviceCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.queueCreateInfoCount == 0 || self.raw.queueCreateInfoCount == queue_create_infos.len() as _, 
            "count inconsistency found when specifying `DeviceCreateInfo::queue_create_infos`.");
        self.raw.queueCreateInfoCount = queue_create_infos.len() as _;
        self.raw.pQueueCreateInfos = queue_create_infos.as_ptr() as *const vks::VkDeviceQueueCreateInfo;
        self
    }

    pub fn enabled_layer_names<'m, 'a>(mut self, enabled_layer_names: &'a [*const c_char]) -> DeviceCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.enabledLayerCount == 0 || self.raw.enabledLayerCount == enabled_layer_names.len() as _, 
            "count inconsistency found when specifying `DeviceCreateInfo::enabled_layer_names`.");
        self.raw.enabledLayerCount = enabled_layer_names.len() as _;
        self.raw.ppEnabledLayerNames = enabled_layer_names.as_ptr();
        self
    }

    pub fn enabled_extension_names<'m, 'a>(mut self, enabled_extension_names: &'a [*const c_char]) -> DeviceCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.enabledExtensionCount == 0 || self.raw.enabledExtensionCount == enabled_extension_names.len() as _, 
            "count inconsistency found when specifying `DeviceCreateInfo::enabled_extension_names`.");
        self.raw.enabledExtensionCount = enabled_extension_names.len() as _;
        self.raw.ppEnabledExtensionNames = enabled_extension_names.as_ptr();
        self
    }

    pub fn enabled_features<'m, 'a>(mut self, enabled_features: &'a PhysicalDeviceFeatures) -> DeviceCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pEnabledFeatures = enabled_features.as_raw();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> DeviceCreateFlags {
        DeviceCreateFlags::from_bits(self.raw.flags)
            .expect("DeviceCreateInfo::flags: error converting flags")
    }

    pub fn get_queue_create_infos<'a>(&'a self) -> &'a [DeviceQueueCreateInfo] {
        unsafe { slice::from_raw_parts(self.raw.pQueueCreateInfos as *const _, self.raw.queueCreateInfoCount as usize) }
    }

    pub fn get_enabled_layer_names<'a>(&'a self) -> &'a [*const c_char] {
        unsafe { slice::from_raw_parts(self.raw.ppEnabledLayerNames as *const _, self.raw.enabledLayerCount as usize) }
    }

    pub fn get_enabled_extension_names<'a>(&'a self) -> &'a [*const c_char] {
        unsafe { slice::from_raw_parts(self.raw.ppEnabledExtensionNames as *const _, self.raw.enabledExtensionCount as usize) }
    }

    pub fn get_enabled_features<'a>(&'a self) -> &'a PhysicalDeviceFeatures {
        unsafe { &*(self.raw.pEnabledFeatures as *const vks::VkPhysicalDeviceFeatures as *const _) }
    }

    pub fn build(self) -> DeviceCreateInfo<'b> {
        DeviceCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkInstanceCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct InstanceCreateInfo<'s> {
    raw: vks::VkInstanceCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> InstanceCreateInfo<'s> {
    pub fn builder<'b>() -> InstanceCreateInfoBuilder<'b> {
        InstanceCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkInstanceCreateInfo) -> InstanceCreateInfo<'s> {
        InstanceCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> InstanceCreateFlags {
        InstanceCreateFlags::from_bits(self.raw.flags)
            .expect("InstanceCreateInfo::flags: error converting flags")
    }

    pub fn application_info<'a>(&'a self) -> &'a ApplicationInfo {
        unsafe { &*(self.raw.pApplicationInfo as *const vks::VkApplicationInfo as *const _) }
    }

    pub fn enabled_layer_names<'a>(&'a self) -> &'a [*const c_char] {
        unsafe { slice::from_raw_parts(self.raw.ppEnabledLayerNames as *const _, self.raw.enabledLayerCount as usize) }
    }

    pub fn enabled_extension_names<'a>(&'a self) -> &'a [*const c_char] {
        unsafe { slice::from_raw_parts(self.raw.ppEnabledExtensionNames as *const _, self.raw.enabledExtensionCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: InstanceCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_application_info<'m, 'a>(&mut self, application_info: &'a ApplicationInfo)
            where 'a: 's {
        self.raw.pApplicationInfo = application_info.as_raw();
    }

    pub fn set_enabled_layer_names<'m, 'a>(&mut self, enabled_layer_names: &'a [*const c_char])
            where 'a: 's {
        assert!(self.raw.enabledLayerCount == 0 || self.raw.enabledLayerCount == enabled_layer_names.len() as _, 
            "count inconsistency found when specifying `InstanceCreateInfo::enabled_layer_names`.");
        self.raw.enabledLayerCount = enabled_layer_names.len() as _;
        self.raw.ppEnabledLayerNames = enabled_layer_names.as_ptr();
    }

    pub fn set_enabled_extension_names<'m, 'a>(&mut self, enabled_extension_names: &'a [*const c_char])
            where 'a: 's {
        assert!(self.raw.enabledExtensionCount == 0 || self.raw.enabledExtensionCount == enabled_extension_names.len() as _, 
            "count inconsistency found when specifying `InstanceCreateInfo::enabled_extension_names`.");
        self.raw.enabledExtensionCount = enabled_extension_names.len() as _;
        self.raw.ppEnabledExtensionNames = enabled_extension_names.as_ptr();
    }

    pub fn as_raw(&self) -> &vks::VkInstanceCreateInfo {
        &self.raw
    }
}

impl<'s> From<InstanceCreateInfo<'s>> for vks::VkInstanceCreateInfo {
    fn from(f: InstanceCreateInfo<'s>) -> vks::VkInstanceCreateInfo {
        f.raw
    }
}


/// A builder for `VkInstanceCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct InstanceCreateInfoBuilder<'b> {
    raw: vks::VkInstanceCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> InstanceCreateInfoBuilder<'b> {
    pub fn new() -> InstanceCreateInfoBuilder<'b> {
        InstanceCreateInfoBuilder {
            raw: vks::VkInstanceCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> InstanceCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: InstanceCreateFlags) -> InstanceCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn application_info<'m, 'a>(mut self, application_info: &'a ApplicationInfo) -> InstanceCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pApplicationInfo = application_info.as_raw();
        self
    }

    pub fn enabled_layer_names<'m, 'a>(mut self, enabled_layer_names: &'a [*const c_char]) -> InstanceCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.enabledLayerCount == 0 || self.raw.enabledLayerCount == enabled_layer_names.len() as _, 
            "count inconsistency found when specifying `InstanceCreateInfo::enabled_layer_names`.");
        self.raw.enabledLayerCount = enabled_layer_names.len() as _;
        self.raw.ppEnabledLayerNames = enabled_layer_names.as_ptr();
        self
    }

    pub fn enabled_extension_names<'m, 'a>(mut self, enabled_extension_names: &'a [*const c_char]) -> InstanceCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.enabledExtensionCount == 0 || self.raw.enabledExtensionCount == enabled_extension_names.len() as _, 
            "count inconsistency found when specifying `InstanceCreateInfo::enabled_extension_names`.");
        self.raw.enabledExtensionCount = enabled_extension_names.len() as _;
        self.raw.ppEnabledExtensionNames = enabled_extension_names.as_ptr();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> InstanceCreateFlags {
        InstanceCreateFlags::from_bits(self.raw.flags)
            .expect("InstanceCreateInfo::flags: error converting flags")
    }

    pub fn get_application_info<'a>(&'a self) -> &'a ApplicationInfo {
        unsafe { &*(self.raw.pApplicationInfo as *const vks::VkApplicationInfo as *const _) }
    }

    pub fn get_enabled_layer_names<'a>(&'a self) -> &'a [*const c_char] {
        unsafe { slice::from_raw_parts(self.raw.ppEnabledLayerNames as *const _, self.raw.enabledLayerCount as usize) }
    }

    pub fn get_enabled_extension_names<'a>(&'a self) -> &'a [*const c_char] {
        unsafe { slice::from_raw_parts(self.raw.ppEnabledExtensionNames as *const _, self.raw.enabledExtensionCount as usize) }
    }

    pub fn build(self) -> InstanceCreateInfo<'b> {
        InstanceCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkQueueFamilyProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct QueueFamilyProperties {
    raw: vks::VkQueueFamilyProperties,
}

impl QueueFamilyProperties {
    pub fn builder() -> QueueFamilyPropertiesBuilder {
        QueueFamilyPropertiesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkQueueFamilyProperties) -> QueueFamilyProperties {
        QueueFamilyProperties { raw, }
    }

    pub fn queue_flags<'a>(&'a self) -> QueueFlags {
        QueueFlags::from_bits(self.raw.queueFlags)
            .expect("QueueFamilyProperties::queue_flags: error converting flags")
    }

    pub fn queue_count<'a>(&'a self) -> u32 {
        self.raw.queueCount.into()
    }

    pub fn timestamp_valid_bits<'a>(&'a self) -> u32 {
        self.raw.timestampValidBits.into()
    }

    pub fn min_image_transfer_granularity<'a>(&'a self) -> &'a Extent3d {
        unsafe { &*(&self.raw.minImageTransferGranularity as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn min_image_transfer_granularity_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.minImageTransferGranularity as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn set_queue_flags<'m>(&mut self, queue_flags: QueueFlags) {
        self.raw.queueFlags = queue_flags.bits();
    }

    pub fn set_queue_count<'m>(&mut self, queue_count: u32) {
        self.raw.queueCount = queue_count.into();
    }

    pub fn set_timestamp_valid_bits<'m>(&mut self, timestamp_valid_bits: u32) {
        self.raw.timestampValidBits = timestamp_valid_bits.into();
    }

    pub fn set_min_image_transfer_granularity<'m>(&mut self, min_image_transfer_granularity: Extent3d) {
        self.raw.minImageTransferGranularity = min_image_transfer_granularity.raw;
    }

    pub fn as_raw(&self) -> &vks::VkQueueFamilyProperties {
        &self.raw
    }
}

impl From<QueueFamilyProperties> for vks::VkQueueFamilyProperties {
    fn from(f: QueueFamilyProperties) -> vks::VkQueueFamilyProperties {
        f.raw
    }
}


/// A builder for `VkQueueFamilyProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct QueueFamilyPropertiesBuilder {
    raw: vks::VkQueueFamilyProperties,
}

impl QueueFamilyPropertiesBuilder {
    pub fn new() -> QueueFamilyPropertiesBuilder {
        QueueFamilyPropertiesBuilder {
            raw: vks::VkQueueFamilyProperties::default(),
        }
    }

    pub fn queue_flags<'m>(mut self, queue_flags: QueueFlags) -> QueueFamilyPropertiesBuilder {
        self.raw.queueFlags = queue_flags.bits();
        self
    }

    pub fn queue_count<'m>(mut self, queue_count: u32) -> QueueFamilyPropertiesBuilder {
        self.raw.queueCount = queue_count.into();
        self
    }

    pub fn timestamp_valid_bits<'m>(mut self, timestamp_valid_bits: u32) -> QueueFamilyPropertiesBuilder {
        self.raw.timestampValidBits = timestamp_valid_bits.into();
        self
    }

    pub fn min_image_transfer_granularity<'m>(mut self, min_image_transfer_granularity: Extent3d) -> QueueFamilyPropertiesBuilder {
        self.raw.minImageTransferGranularity = min_image_transfer_granularity.raw;
        self
    }

    pub fn get_queue_flags<'a>(&'a self) -> QueueFlags {
        QueueFlags::from_bits(self.raw.queueFlags)
            .expect("QueueFamilyProperties::queue_flags: error converting flags")
    }

    pub fn get_queue_count<'a>(&'a self) -> u32 {
        self.raw.queueCount.into()
    }

    pub fn get_timestamp_valid_bits<'a>(&'a self) -> u32 {
        self.raw.timestampValidBits.into()
    }

    pub fn get_min_image_transfer_granularity<'a>(&'a self) -> &'a Extent3d {
        unsafe { &*(&self.raw.minImageTransferGranularity as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn get_min_image_transfer_granularity_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.minImageTransferGranularity as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn build(self) -> QueueFamilyProperties {
        QueueFamilyProperties {
            raw: self.raw,
        }
    }
}


/// A `VkPhysicalDeviceMemoryProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceMemoryProperties {
    raw: vks::VkPhysicalDeviceMemoryProperties,
}

impl PhysicalDeviceMemoryProperties {
    pub fn builder() -> PhysicalDeviceMemoryPropertiesBuilder {
        PhysicalDeviceMemoryPropertiesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceMemoryProperties) -> PhysicalDeviceMemoryProperties {
        PhysicalDeviceMemoryProperties { raw, }
    }

    pub fn memory_type_count<'a>(&'a self) -> u32 {
        self.raw.memoryTypeCount.into()
    }

    pub fn memory_types<'a>(&'a self) -> &[MemoryType] {
        unsafe { slice::from_raw_parts(&self.raw.memoryTypes as *const vks::VkMemoryType as *const _, vks::VK_MAX_MEMORY_TYPES as usize) }
    }

    pub fn memory_heap_count<'a>(&'a self) -> u32 {
        self.raw.memoryHeapCount.into()
    }

    pub fn memory_heaps<'a>(&'a self) -> &[MemoryHeap] {
        unsafe { slice::from_raw_parts(&self.raw.memoryHeaps as *const vks::VkMemoryHeap as *const _, vks::VK_MAX_MEMORY_HEAPS as usize) }
    }

    pub fn set_memory_type_count<'m>(&mut self, memory_type_count: u32) {
        self.raw.memoryTypeCount = memory_type_count.into();
    }

    pub fn set_memory_types<'m>(&mut self, memory_types: [MemoryType; vks::VK_MAX_MEMORY_TYPES]) {
        self.raw.memoryTypes = unsafe { *(&memory_types as *const [MemoryType; vks::VK_MAX_MEMORY_TYPES] as *const _) };
    }

    pub fn set_memory_heap_count<'m>(&mut self, memory_heap_count: u32) {
        self.raw.memoryHeapCount = memory_heap_count.into();
    }

    pub fn set_memory_heaps<'m>(&mut self, memory_heaps: [MemoryHeap; vks::VK_MAX_MEMORY_HEAPS]) {
        self.raw.memoryHeaps = unsafe { *(&memory_heaps as *const [MemoryHeap; vks::VK_MAX_MEMORY_HEAPS] as *const _) };
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceMemoryProperties {
        &self.raw
    }
}

impl From<PhysicalDeviceMemoryProperties> for vks::VkPhysicalDeviceMemoryProperties {
    fn from(f: PhysicalDeviceMemoryProperties) -> vks::VkPhysicalDeviceMemoryProperties {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceMemoryProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceMemoryPropertiesBuilder {
    raw: vks::VkPhysicalDeviceMemoryProperties,
}

impl PhysicalDeviceMemoryPropertiesBuilder {
    pub fn new() -> PhysicalDeviceMemoryPropertiesBuilder {
        PhysicalDeviceMemoryPropertiesBuilder {
            raw: vks::VkPhysicalDeviceMemoryProperties::default(),
        }
    }

    pub fn memory_type_count<'m>(mut self, memory_type_count: u32) -> PhysicalDeviceMemoryPropertiesBuilder {
        self.raw.memoryTypeCount = memory_type_count.into();
        self
    }

    pub fn memory_types<'m>(mut self, memory_types: [MemoryType; vks::VK_MAX_MEMORY_TYPES]) -> PhysicalDeviceMemoryPropertiesBuilder {
        self.raw.memoryTypes = unsafe { *(&memory_types as *const [MemoryType; vks::VK_MAX_MEMORY_TYPES] as *const _) };
        self
    }

    pub fn memory_heap_count<'m>(mut self, memory_heap_count: u32) -> PhysicalDeviceMemoryPropertiesBuilder {
        self.raw.memoryHeapCount = memory_heap_count.into();
        self
    }

    pub fn memory_heaps<'m>(mut self, memory_heaps: [MemoryHeap; vks::VK_MAX_MEMORY_HEAPS]) -> PhysicalDeviceMemoryPropertiesBuilder {
        self.raw.memoryHeaps = unsafe { *(&memory_heaps as *const [MemoryHeap; vks::VK_MAX_MEMORY_HEAPS] as *const _) };
        self
    }

    pub fn get_memory_type_count<'a>(&'a self) -> u32 {
        self.raw.memoryTypeCount.into()
    }

    pub fn get_memory_types<'a>(&'a self) -> &[MemoryType] {
        unsafe { slice::from_raw_parts(&self.raw.memoryTypes as *const vks::VkMemoryType as *const _, vks::VK_MAX_MEMORY_TYPES as usize) }
    }

    pub fn get_memory_heap_count<'a>(&'a self) -> u32 {
        self.raw.memoryHeapCount.into()
    }

    pub fn get_memory_heaps<'a>(&'a self) -> &[MemoryHeap] {
        unsafe { slice::from_raw_parts(&self.raw.memoryHeaps as *const vks::VkMemoryHeap as *const _, vks::VK_MAX_MEMORY_HEAPS as usize) }
    }

    pub fn build(self) -> PhysicalDeviceMemoryProperties {
        PhysicalDeviceMemoryProperties {
            raw: self.raw,
        }
    }
}


/// A `VkMemoryAllocateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryAllocateInfo<'s> {
    raw: vks::VkMemoryAllocateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> MemoryAllocateInfo<'s> {
    pub fn builder<'b>() -> MemoryAllocateInfoBuilder<'b> {
        MemoryAllocateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryAllocateInfo) -> MemoryAllocateInfo<'s> {
        MemoryAllocateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn allocation_size<'a>(&'a self) -> u64 {
        self.raw.allocationSize.into()
    }

    pub fn memory_type_index<'a>(&'a self) -> u32 {
        self.raw.memoryTypeIndex.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_allocation_size<'m>(&mut self, allocation_size: u64) {
        self.raw.allocationSize = allocation_size.into();
    }

    pub fn set_memory_type_index<'m>(&mut self, memory_type_index: u32) {
        self.raw.memoryTypeIndex = memory_type_index.into();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryAllocateInfo {
        &self.raw
    }
}

impl<'s> From<MemoryAllocateInfo<'s>> for vks::VkMemoryAllocateInfo {
    fn from(f: MemoryAllocateInfo<'s>) -> vks::VkMemoryAllocateInfo {
        f.raw
    }
}


/// A builder for `VkMemoryAllocateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryAllocateInfoBuilder<'b> {
    raw: vks::VkMemoryAllocateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> MemoryAllocateInfoBuilder<'b> {
    pub fn new() -> MemoryAllocateInfoBuilder<'b> {
        MemoryAllocateInfoBuilder {
            raw: vks::VkMemoryAllocateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> MemoryAllocateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn allocation_size<'m>(mut self, allocation_size: u64) -> MemoryAllocateInfoBuilder<'b> {
        self.raw.allocationSize = allocation_size.into();
        self
    }

    pub fn memory_type_index<'m>(mut self, memory_type_index: u32) -> MemoryAllocateInfoBuilder<'b> {
        self.raw.memoryTypeIndex = memory_type_index.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_allocation_size<'a>(&'a self) -> u64 {
        self.raw.allocationSize.into()
    }

    pub fn get_memory_type_index<'a>(&'a self) -> u32 {
        self.raw.memoryTypeIndex.into()
    }

    pub fn build(self) -> MemoryAllocateInfo<'b> {
        MemoryAllocateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMemoryRequirements`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryRequirements {
    raw: vks::VkMemoryRequirements,
}

impl MemoryRequirements {
    pub fn builder() -> MemoryRequirementsBuilder {
        MemoryRequirementsBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryRequirements) -> MemoryRequirements {
        MemoryRequirements { raw, }
    }

    pub fn size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn alignment<'a>(&'a self) -> u64 {
        self.raw.alignment.into()
    }

    pub fn memory_type_bits<'a>(&'a self) -> u32 {
        self.raw.memoryTypeBits.into()
    }

    pub fn set_size<'m>(&mut self, size: u64) {
        self.raw.size = size.into();
    }

    pub fn set_alignment<'m>(&mut self, alignment: u64) {
        self.raw.alignment = alignment.into();
    }

    pub fn set_memory_type_bits<'m>(&mut self, memory_type_bits: u32) {
        self.raw.memoryTypeBits = memory_type_bits.into();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryRequirements {
        &self.raw
    }
}

impl From<MemoryRequirements> for vks::VkMemoryRequirements {
    fn from(f: MemoryRequirements) -> vks::VkMemoryRequirements {
        f.raw
    }
}


/// A builder for `VkMemoryRequirements`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryRequirementsBuilder {
    raw: vks::VkMemoryRequirements,
}

impl MemoryRequirementsBuilder {
    pub fn new() -> MemoryRequirementsBuilder {
        MemoryRequirementsBuilder {
            raw: vks::VkMemoryRequirements::default(),
        }
    }

    pub fn size<'m>(mut self, size: u64) -> MemoryRequirementsBuilder {
        self.raw.size = size.into();
        self
    }

    pub fn alignment<'m>(mut self, alignment: u64) -> MemoryRequirementsBuilder {
        self.raw.alignment = alignment.into();
        self
    }

    pub fn memory_type_bits<'m>(mut self, memory_type_bits: u32) -> MemoryRequirementsBuilder {
        self.raw.memoryTypeBits = memory_type_bits.into();
        self
    }

    pub fn get_size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn get_alignment<'a>(&'a self) -> u64 {
        self.raw.alignment.into()
    }

    pub fn get_memory_type_bits<'a>(&'a self) -> u32 {
        self.raw.memoryTypeBits.into()
    }

    pub fn build(self) -> MemoryRequirements {
        MemoryRequirements {
            raw: self.raw,
        }
    }
}


/// A `VkSparseImageFormatProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SparseImageFormatProperties {
    raw: vks::VkSparseImageFormatProperties,
}

impl SparseImageFormatProperties {
    pub fn builder() -> SparseImageFormatPropertiesBuilder {
        SparseImageFormatPropertiesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSparseImageFormatProperties) -> SparseImageFormatProperties {
        SparseImageFormatProperties { raw, }
    }

    pub fn aspect_mask<'a>(&'a self) -> ImageAspectFlags {
        ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("SparseImageFormatProperties::aspect_mask: error converting flags")
    }

    pub fn image_granularity<'a>(&'a self) -> &'a Extent3d {
        unsafe { &*(&self.raw.imageGranularity as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn image_granularity_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.imageGranularity as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn flags<'a>(&'a self) -> SparseImageFormatFlags {
        SparseImageFormatFlags::from_bits(self.raw.flags)
            .expect("SparseImageFormatProperties::flags: error converting flags")
    }

    pub fn set_aspect_mask<'m>(&mut self, aspect_mask: ImageAspectFlags) {
        self.raw.aspectMask = aspect_mask.bits();
    }

    pub fn set_image_granularity<'m>(&mut self, image_granularity: Extent3d) {
        self.raw.imageGranularity = image_granularity.raw;
    }

    pub fn set_flags<'m>(&mut self, flags: SparseImageFormatFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSparseImageFormatProperties {
        &self.raw
    }
}

impl From<SparseImageFormatProperties> for vks::VkSparseImageFormatProperties {
    fn from(f: SparseImageFormatProperties) -> vks::VkSparseImageFormatProperties {
        f.raw
    }
}


/// A builder for `VkSparseImageFormatProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SparseImageFormatPropertiesBuilder {
    raw: vks::VkSparseImageFormatProperties,
}

impl SparseImageFormatPropertiesBuilder {
    pub fn new() -> SparseImageFormatPropertiesBuilder {
        SparseImageFormatPropertiesBuilder {
            raw: vks::VkSparseImageFormatProperties::default(),
        }
    }

    pub fn aspect_mask<'m>(mut self, aspect_mask: ImageAspectFlags) -> SparseImageFormatPropertiesBuilder {
        self.raw.aspectMask = aspect_mask.bits();
        self
    }

    pub fn image_granularity<'m>(mut self, image_granularity: Extent3d) -> SparseImageFormatPropertiesBuilder {
        self.raw.imageGranularity = image_granularity.raw;
        self
    }

    pub fn flags<'m>(mut self, flags: SparseImageFormatFlags) -> SparseImageFormatPropertiesBuilder {
        self.raw.flags = flags.bits();
        self
    }

    pub fn get_aspect_mask<'a>(&'a self) -> ImageAspectFlags {
        ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("SparseImageFormatProperties::aspect_mask: error converting flags")
    }

    pub fn get_image_granularity<'a>(&'a self) -> &'a Extent3d {
        unsafe { &*(&self.raw.imageGranularity as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn get_image_granularity_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.imageGranularity as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn get_flags<'a>(&'a self) -> SparseImageFormatFlags {
        SparseImageFormatFlags::from_bits(self.raw.flags)
            .expect("SparseImageFormatProperties::flags: error converting flags")
    }

    pub fn build(self) -> SparseImageFormatProperties {
        SparseImageFormatProperties {
            raw: self.raw,
        }
    }
}


/// A `VkSparseImageMemoryRequirements`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SparseImageMemoryRequirements {
    raw: vks::VkSparseImageMemoryRequirements,
}

impl SparseImageMemoryRequirements {
    pub fn builder() -> SparseImageMemoryRequirementsBuilder {
        SparseImageMemoryRequirementsBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSparseImageMemoryRequirements) -> SparseImageMemoryRequirements {
        SparseImageMemoryRequirements { raw, }
    }

    pub fn format_properties<'a>(&'a self) -> &'a SparseImageFormatProperties {
        unsafe { &*(&self.raw.formatProperties as *const vks::VkSparseImageFormatProperties as *const SparseImageFormatProperties) }
    }

    pub fn format_properties_mut<'a>(&'a mut self) -> &'a mut SparseImageFormatProperties {
        unsafe { &mut *(&mut self.raw.formatProperties as *mut  vks::VkSparseImageFormatProperties as *mut SparseImageFormatProperties) }
    }

    pub fn image_mip_tail_first_lod<'a>(&'a self) -> u32 {
        self.raw.imageMipTailFirstLod.into()
    }

    pub fn image_mip_tail_size<'a>(&'a self) -> u64 {
        self.raw.imageMipTailSize.into()
    }

    pub fn image_mip_tail_offset<'a>(&'a self) -> u64 {
        self.raw.imageMipTailOffset.into()
    }

    pub fn image_mip_tail_stride<'a>(&'a self) -> u64 {
        self.raw.imageMipTailStride.into()
    }

    pub fn set_format_properties<'m>(&mut self, format_properties: SparseImageFormatProperties) {
        self.raw.formatProperties = format_properties.raw;
    }

    pub fn set_image_mip_tail_first_lod<'m>(&mut self, image_mip_tail_first_lod: u32) {
        self.raw.imageMipTailFirstLod = image_mip_tail_first_lod.into();
    }

    pub fn set_image_mip_tail_size<'m>(&mut self, image_mip_tail_size: u64) {
        self.raw.imageMipTailSize = image_mip_tail_size.into();
    }

    pub fn set_image_mip_tail_offset<'m>(&mut self, image_mip_tail_offset: u64) {
        self.raw.imageMipTailOffset = image_mip_tail_offset.into();
    }

    pub fn set_image_mip_tail_stride<'m>(&mut self, image_mip_tail_stride: u64) {
        self.raw.imageMipTailStride = image_mip_tail_stride.into();
    }

    pub fn as_raw(&self) -> &vks::VkSparseImageMemoryRequirements {
        &self.raw
    }
}

impl From<SparseImageMemoryRequirements> for vks::VkSparseImageMemoryRequirements {
    fn from(f: SparseImageMemoryRequirements) -> vks::VkSparseImageMemoryRequirements {
        f.raw
    }
}


/// A builder for `VkSparseImageMemoryRequirements`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SparseImageMemoryRequirementsBuilder {
    raw: vks::VkSparseImageMemoryRequirements,
}

impl SparseImageMemoryRequirementsBuilder {
    pub fn new() -> SparseImageMemoryRequirementsBuilder {
        SparseImageMemoryRequirementsBuilder {
            raw: vks::VkSparseImageMemoryRequirements::default(),
        }
    }

    pub fn format_properties<'m>(mut self, format_properties: SparseImageFormatProperties) -> SparseImageMemoryRequirementsBuilder {
        self.raw.formatProperties = format_properties.raw;
        self
    }

    pub fn image_mip_tail_first_lod<'m>(mut self, image_mip_tail_first_lod: u32) -> SparseImageMemoryRequirementsBuilder {
        self.raw.imageMipTailFirstLod = image_mip_tail_first_lod.into();
        self
    }

    pub fn image_mip_tail_size<'m>(mut self, image_mip_tail_size: u64) -> SparseImageMemoryRequirementsBuilder {
        self.raw.imageMipTailSize = image_mip_tail_size.into();
        self
    }

    pub fn image_mip_tail_offset<'m>(mut self, image_mip_tail_offset: u64) -> SparseImageMemoryRequirementsBuilder {
        self.raw.imageMipTailOffset = image_mip_tail_offset.into();
        self
    }

    pub fn image_mip_tail_stride<'m>(mut self, image_mip_tail_stride: u64) -> SparseImageMemoryRequirementsBuilder {
        self.raw.imageMipTailStride = image_mip_tail_stride.into();
        self
    }

    pub fn get_format_properties<'a>(&'a self) -> &'a SparseImageFormatProperties {
        unsafe { &*(&self.raw.formatProperties as *const vks::VkSparseImageFormatProperties as *const SparseImageFormatProperties) }
    }

    pub fn get_format_properties_mut<'a>(&'a mut self) -> &'a mut SparseImageFormatProperties {
        unsafe { &mut *(&mut self.raw.formatProperties as *mut  vks::VkSparseImageFormatProperties as *mut SparseImageFormatProperties) }
    }

    pub fn get_image_mip_tail_first_lod<'a>(&'a self) -> u32 {
        self.raw.imageMipTailFirstLod.into()
    }

    pub fn get_image_mip_tail_size<'a>(&'a self) -> u64 {
        self.raw.imageMipTailSize.into()
    }

    pub fn get_image_mip_tail_offset<'a>(&'a self) -> u64 {
        self.raw.imageMipTailOffset.into()
    }

    pub fn get_image_mip_tail_stride<'a>(&'a self) -> u64 {
        self.raw.imageMipTailStride.into()
    }

    pub fn build(self) -> SparseImageMemoryRequirements {
        SparseImageMemoryRequirements {
            raw: self.raw,
        }
    }
}


/// A `VkMemoryType`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryType {
    raw: vks::VkMemoryType,
}

impl MemoryType {
    pub fn builder() -> MemoryTypeBuilder {
        MemoryTypeBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryType) -> MemoryType {
        MemoryType { raw, }
    }

    pub fn property_flags<'a>(&'a self) -> MemoryPropertyFlags {
        MemoryPropertyFlags::from_bits(self.raw.propertyFlags)
            .expect("MemoryType::property_flags: error converting flags")
    }

    pub fn heap_index<'a>(&'a self) -> u32 {
        self.raw.heapIndex.into()
    }

    pub fn set_property_flags<'m>(&mut self, property_flags: MemoryPropertyFlags) {
        self.raw.propertyFlags = property_flags.bits();
    }

    pub fn set_heap_index<'m>(&mut self, heap_index: u32) {
        self.raw.heapIndex = heap_index.into();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryType {
        &self.raw
    }
}

impl From<MemoryType> for vks::VkMemoryType {
    fn from(f: MemoryType) -> vks::VkMemoryType {
        f.raw
    }
}


/// A builder for `VkMemoryType`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryTypeBuilder {
    raw: vks::VkMemoryType,
}

impl MemoryTypeBuilder {
    pub fn new() -> MemoryTypeBuilder {
        MemoryTypeBuilder {
            raw: vks::VkMemoryType::default(),
        }
    }

    pub fn property_flags<'m>(mut self, property_flags: MemoryPropertyFlags) -> MemoryTypeBuilder {
        self.raw.propertyFlags = property_flags.bits();
        self
    }

    pub fn heap_index<'m>(mut self, heap_index: u32) -> MemoryTypeBuilder {
        self.raw.heapIndex = heap_index.into();
        self
    }

    pub fn get_property_flags<'a>(&'a self) -> MemoryPropertyFlags {
        MemoryPropertyFlags::from_bits(self.raw.propertyFlags)
            .expect("MemoryType::property_flags: error converting flags")
    }

    pub fn get_heap_index<'a>(&'a self) -> u32 {
        self.raw.heapIndex.into()
    }

    pub fn build(self) -> MemoryType {
        MemoryType {
            raw: self.raw,
        }
    }
}


/// A `VkMemoryHeap`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryHeap {
    raw: vks::VkMemoryHeap,
}

impl MemoryHeap {
    pub fn builder() -> MemoryHeapBuilder {
        MemoryHeapBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryHeap) -> MemoryHeap {
        MemoryHeap { raw, }
    }

    pub fn size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn flags<'a>(&'a self) -> MemoryHeapFlags {
        MemoryHeapFlags::from_bits(self.raw.flags)
            .expect("MemoryHeap::flags: error converting flags")
    }

    pub fn set_size<'m>(&mut self, size: u64) {
        self.raw.size = size.into();
    }

    pub fn set_flags<'m>(&mut self, flags: MemoryHeapFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryHeap {
        &self.raw
    }
}

impl From<MemoryHeap> for vks::VkMemoryHeap {
    fn from(f: MemoryHeap) -> vks::VkMemoryHeap {
        f.raw
    }
}


/// A builder for `VkMemoryHeap`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryHeapBuilder {
    raw: vks::VkMemoryHeap,
}

impl MemoryHeapBuilder {
    pub fn new() -> MemoryHeapBuilder {
        MemoryHeapBuilder {
            raw: vks::VkMemoryHeap::default(),
        }
    }

    pub fn size<'m>(mut self, size: u64) -> MemoryHeapBuilder {
        self.raw.size = size.into();
        self
    }

    pub fn flags<'m>(mut self, flags: MemoryHeapFlags) -> MemoryHeapBuilder {
        self.raw.flags = flags.bits();
        self
    }

    pub fn get_size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn get_flags<'a>(&'a self) -> MemoryHeapFlags {
        MemoryHeapFlags::from_bits(self.raw.flags)
            .expect("MemoryHeap::flags: error converting flags")
    }

    pub fn build(self) -> MemoryHeap {
        MemoryHeap {
            raw: self.raw,
        }
    }
}


/// A `VkMappedMemoryRange`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MappedMemoryRange<'s> {
    raw: vks::VkMappedMemoryRange,
    _p: PhantomData<&'s ()>,
}

impl<'s> MappedMemoryRange<'s> {
    pub fn builder<'b>() -> MappedMemoryRangeBuilder<'b> {
        MappedMemoryRangeBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMappedMemoryRange) -> MappedMemoryRange<'s> {
        MappedMemoryRange { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn memory<'a>(&'a self) -> vks::VkDeviceMemory {
        self.raw.memory
    }

    pub fn offset<'a>(&'a self) -> u64 {
        self.raw.offset.into()
    }

    pub fn size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_memory<'m, H>(&mut self, memory: H)
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
    }

    pub fn set_offset<'m>(&mut self, offset: u64) {
        self.raw.offset = offset.into();
    }

    pub fn set_size<'m>(&mut self, size: u64) {
        self.raw.size = size.into();
    }

    pub fn as_raw(&self) -> &vks::VkMappedMemoryRange {
        &self.raw
    }
}

impl<'s> From<MappedMemoryRange<'s>> for vks::VkMappedMemoryRange {
    fn from(f: MappedMemoryRange<'s>) -> vks::VkMappedMemoryRange {
        f.raw
    }
}


/// A builder for `VkMappedMemoryRange`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MappedMemoryRangeBuilder<'b> {
    raw: vks::VkMappedMemoryRange,
    _p: PhantomData<&'b ()>, 
}

impl<'b> MappedMemoryRangeBuilder<'b> {
    pub fn new() -> MappedMemoryRangeBuilder<'b> {
        MappedMemoryRangeBuilder {
            raw: vks::VkMappedMemoryRange::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> MappedMemoryRangeBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn memory<'m, H>(mut self, memory: H) -> MappedMemoryRangeBuilder<'b>
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
        self
    }

    pub fn offset<'m>(mut self, offset: u64) -> MappedMemoryRangeBuilder<'b> {
        self.raw.offset = offset.into();
        self
    }

    pub fn size<'m>(mut self, size: u64) -> MappedMemoryRangeBuilder<'b> {
        self.raw.size = size.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_memory<'a>(&'a self) -> vks::VkDeviceMemory {
        self.raw.memory
    }

    pub fn get_offset<'a>(&'a self) -> u64 {
        self.raw.offset.into()
    }

    pub fn get_size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn build(self) -> MappedMemoryRange<'b> {
        MappedMemoryRange {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkFormatProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct FormatProperties {
    raw: vks::VkFormatProperties,
}

impl FormatProperties {
    pub fn builder() -> FormatPropertiesBuilder {
        FormatPropertiesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkFormatProperties) -> FormatProperties {
        FormatProperties { raw, }
    }

    pub fn linear_tiling_features<'a>(&'a self) -> FormatFeatureFlags {
        FormatFeatureFlags::from_bits(self.raw.linearTilingFeatures)
            .expect("FormatProperties::linear_tiling_features: error converting flags")
    }

    pub fn optimal_tiling_features<'a>(&'a self) -> FormatFeatureFlags {
        FormatFeatureFlags::from_bits(self.raw.optimalTilingFeatures)
            .expect("FormatProperties::optimal_tiling_features: error converting flags")
    }

    pub fn buffer_features<'a>(&'a self) -> FormatFeatureFlags {
        FormatFeatureFlags::from_bits(self.raw.bufferFeatures)
            .expect("FormatProperties::buffer_features: error converting flags")
    }

    pub fn set_linear_tiling_features<'m>(&mut self, linear_tiling_features: FormatFeatureFlags) {
        self.raw.linearTilingFeatures = linear_tiling_features.bits();
    }

    pub fn set_optimal_tiling_features<'m>(&mut self, optimal_tiling_features: FormatFeatureFlags) {
        self.raw.optimalTilingFeatures = optimal_tiling_features.bits();
    }

    pub fn set_buffer_features<'m>(&mut self, buffer_features: FormatFeatureFlags) {
        self.raw.bufferFeatures = buffer_features.bits();
    }

    pub fn as_raw(&self) -> &vks::VkFormatProperties {
        &self.raw
    }
}

impl From<FormatProperties> for vks::VkFormatProperties {
    fn from(f: FormatProperties) -> vks::VkFormatProperties {
        f.raw
    }
}


/// A builder for `VkFormatProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct FormatPropertiesBuilder {
    raw: vks::VkFormatProperties,
}

impl FormatPropertiesBuilder {
    pub fn new() -> FormatPropertiesBuilder {
        FormatPropertiesBuilder {
            raw: vks::VkFormatProperties::default(),
        }
    }

    pub fn linear_tiling_features<'m>(mut self, linear_tiling_features: FormatFeatureFlags) -> FormatPropertiesBuilder {
        self.raw.linearTilingFeatures = linear_tiling_features.bits();
        self
    }

    pub fn optimal_tiling_features<'m>(mut self, optimal_tiling_features: FormatFeatureFlags) -> FormatPropertiesBuilder {
        self.raw.optimalTilingFeatures = optimal_tiling_features.bits();
        self
    }

    pub fn buffer_features<'m>(mut self, buffer_features: FormatFeatureFlags) -> FormatPropertiesBuilder {
        self.raw.bufferFeatures = buffer_features.bits();
        self
    }

    pub fn get_linear_tiling_features<'a>(&'a self) -> FormatFeatureFlags {
        FormatFeatureFlags::from_bits(self.raw.linearTilingFeatures)
            .expect("FormatProperties::linear_tiling_features: error converting flags")
    }

    pub fn get_optimal_tiling_features<'a>(&'a self) -> FormatFeatureFlags {
        FormatFeatureFlags::from_bits(self.raw.optimalTilingFeatures)
            .expect("FormatProperties::optimal_tiling_features: error converting flags")
    }

    pub fn get_buffer_features<'a>(&'a self) -> FormatFeatureFlags {
        FormatFeatureFlags::from_bits(self.raw.bufferFeatures)
            .expect("FormatProperties::buffer_features: error converting flags")
    }

    pub fn build(self) -> FormatProperties {
        FormatProperties {
            raw: self.raw,
        }
    }
}


/// A `VkImageFormatProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageFormatProperties {
    raw: vks::VkImageFormatProperties,
}

impl ImageFormatProperties {
    pub fn builder() -> ImageFormatPropertiesBuilder {
        ImageFormatPropertiesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageFormatProperties) -> ImageFormatProperties {
        ImageFormatProperties { raw, }
    }

    pub fn max_extent<'a>(&'a self) -> &'a Extent3d {
        unsafe { &*(&self.raw.maxExtent as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn max_extent_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.maxExtent as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn max_mip_levels<'a>(&'a self) -> u32 {
        self.raw.maxMipLevels.into()
    }

    pub fn max_array_layers<'a>(&'a self) -> u32 {
        self.raw.maxArrayLayers.into()
    }

    pub fn sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.sampleCounts)
            .expect("ImageFormatProperties::sample_counts: error converting flags")
    }

    pub fn max_resource_size<'a>(&'a self) -> u64 {
        self.raw.maxResourceSize.into()
    }

    pub fn set_max_extent<'m>(&mut self, max_extent: Extent3d) {
        self.raw.maxExtent = max_extent.raw;
    }

    pub fn set_max_mip_levels<'m>(&mut self, max_mip_levels: u32) {
        self.raw.maxMipLevels = max_mip_levels.into();
    }

    pub fn set_max_array_layers<'m>(&mut self, max_array_layers: u32) {
        self.raw.maxArrayLayers = max_array_layers.into();
    }

    pub fn set_sample_counts<'m>(&mut self, sample_counts: SampleCountFlags) {
        self.raw.sampleCounts = sample_counts.bits();
    }

    pub fn set_max_resource_size<'m>(&mut self, max_resource_size: u64) {
        self.raw.maxResourceSize = max_resource_size.into();
    }

    pub fn as_raw(&self) -> &vks::VkImageFormatProperties {
        &self.raw
    }
}

impl From<ImageFormatProperties> for vks::VkImageFormatProperties {
    fn from(f: ImageFormatProperties) -> vks::VkImageFormatProperties {
        f.raw
    }
}


/// A builder for `VkImageFormatProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageFormatPropertiesBuilder {
    raw: vks::VkImageFormatProperties,
}

impl ImageFormatPropertiesBuilder {
    pub fn new() -> ImageFormatPropertiesBuilder {
        ImageFormatPropertiesBuilder {
            raw: vks::VkImageFormatProperties::default(),
        }
    }

    pub fn max_extent<'m>(mut self, max_extent: Extent3d) -> ImageFormatPropertiesBuilder {
        self.raw.maxExtent = max_extent.raw;
        self
    }

    pub fn max_mip_levels<'m>(mut self, max_mip_levels: u32) -> ImageFormatPropertiesBuilder {
        self.raw.maxMipLevels = max_mip_levels.into();
        self
    }

    pub fn max_array_layers<'m>(mut self, max_array_layers: u32) -> ImageFormatPropertiesBuilder {
        self.raw.maxArrayLayers = max_array_layers.into();
        self
    }

    pub fn sample_counts<'m>(mut self, sample_counts: SampleCountFlags) -> ImageFormatPropertiesBuilder {
        self.raw.sampleCounts = sample_counts.bits();
        self
    }

    pub fn max_resource_size<'m>(mut self, max_resource_size: u64) -> ImageFormatPropertiesBuilder {
        self.raw.maxResourceSize = max_resource_size.into();
        self
    }

    pub fn get_max_extent<'a>(&'a self) -> &'a Extent3d {
        unsafe { &*(&self.raw.maxExtent as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn get_max_extent_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.maxExtent as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn get_max_mip_levels<'a>(&'a self) -> u32 {
        self.raw.maxMipLevels.into()
    }

    pub fn get_max_array_layers<'a>(&'a self) -> u32 {
        self.raw.maxArrayLayers.into()
    }

    pub fn get_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.sampleCounts)
            .expect("ImageFormatProperties::sample_counts: error converting flags")
    }

    pub fn get_max_resource_size<'a>(&'a self) -> u64 {
        self.raw.maxResourceSize.into()
    }

    pub fn build(self) -> ImageFormatProperties {
        ImageFormatProperties {
            raw: self.raw,
        }
    }
}


/// A `VkDescriptorBufferInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DescriptorBufferInfo {
    raw: vks::VkDescriptorBufferInfo,
}

impl DescriptorBufferInfo {
    pub fn builder() -> DescriptorBufferInfoBuilder {
        DescriptorBufferInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDescriptorBufferInfo) -> DescriptorBufferInfo {
        DescriptorBufferInfo { raw, }
    }

    pub fn buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn offset<'a>(&'a self) -> u64 {
        self.raw.offset.into()
    }

    pub fn range<'a>(&'a self) -> u64 {
        self.raw.range.into()
    }

    pub fn set_buffer<'m, H>(&mut self, buffer: H)
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
    }

    pub fn set_offset<'m>(&mut self, offset: u64) {
        self.raw.offset = offset.into();
    }

    pub fn set_range<'m>(&mut self, range: u64) {
        self.raw.range = range.into();
    }

    pub fn as_raw(&self) -> &vks::VkDescriptorBufferInfo {
        &self.raw
    }
}

impl From<DescriptorBufferInfo> for vks::VkDescriptorBufferInfo {
    fn from(f: DescriptorBufferInfo) -> vks::VkDescriptorBufferInfo {
        f.raw
    }
}


/// A builder for `VkDescriptorBufferInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DescriptorBufferInfoBuilder {
    raw: vks::VkDescriptorBufferInfo,
}

impl DescriptorBufferInfoBuilder {
    pub fn new() -> DescriptorBufferInfoBuilder {
        DescriptorBufferInfoBuilder {
            raw: vks::VkDescriptorBufferInfo::default(),
        }
    }

    pub fn buffer<'m, H>(mut self, buffer: H) -> DescriptorBufferInfoBuilder
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
        self
    }

    pub fn offset<'m>(mut self, offset: u64) -> DescriptorBufferInfoBuilder {
        self.raw.offset = offset.into();
        self
    }

    pub fn range<'m>(mut self, range: u64) -> DescriptorBufferInfoBuilder {
        self.raw.range = range.into();
        self
    }

    pub fn get_buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn get_offset<'a>(&'a self) -> u64 {
        self.raw.offset.into()
    }

    pub fn get_range<'a>(&'a self) -> u64 {
        self.raw.range.into()
    }

    pub fn build(self) -> DescriptorBufferInfo {
        DescriptorBufferInfo {
            raw: self.raw,
        }
    }
}


/// A `VkDescriptorImageInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DescriptorImageInfo {
    raw: vks::VkDescriptorImageInfo,
}

impl DescriptorImageInfo {
    pub fn builder() -> DescriptorImageInfoBuilder {
        DescriptorImageInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDescriptorImageInfo) -> DescriptorImageInfo {
        DescriptorImageInfo { raw, }
    }

    pub fn sampler<'a>(&'a self) -> vks::VkSampler {
        self.raw.sampler
    }

    pub fn image_view<'a>(&'a self) -> vks::VkImageView {
        self.raw.imageView
    }

    pub fn image_layout<'a>(&'a self) -> ImageLayout {
        self.raw.imageLayout.into()
    }

    pub fn set_sampler<'m, H>(&mut self, sampler: H)
            where H: Handle<Target=SamplerHandle> {
        self.raw.sampler = sampler.handle().0;
    }

    pub fn set_image_view<'m, H>(&mut self, image_view: H)
            where H: Handle<Target=ImageViewHandle> {
        self.raw.imageView = image_view.handle().0;
    }

    pub fn set_image_layout<'m>(&mut self, image_layout: ImageLayout) {
        self.raw.imageLayout = image_layout.into();
    }

    pub fn as_raw(&self) -> &vks::VkDescriptorImageInfo {
        &self.raw
    }
}

impl From<DescriptorImageInfo> for vks::VkDescriptorImageInfo {
    fn from(f: DescriptorImageInfo) -> vks::VkDescriptorImageInfo {
        f.raw
    }
}


/// A builder for `VkDescriptorImageInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DescriptorImageInfoBuilder {
    raw: vks::VkDescriptorImageInfo,
}

impl DescriptorImageInfoBuilder {
    pub fn new() -> DescriptorImageInfoBuilder {
        DescriptorImageInfoBuilder {
            raw: vks::VkDescriptorImageInfo::default(),
        }
    }

    pub fn sampler<'m, H>(mut self, sampler: H) -> DescriptorImageInfoBuilder
            where H: Handle<Target=SamplerHandle> {
        self.raw.sampler = sampler.handle().0;
        self
    }

    pub fn image_view<'m, H>(mut self, image_view: H) -> DescriptorImageInfoBuilder
            where H: Handle<Target=ImageViewHandle> {
        self.raw.imageView = image_view.handle().0;
        self
    }

    pub fn image_layout<'m>(mut self, image_layout: ImageLayout) -> DescriptorImageInfoBuilder {
        self.raw.imageLayout = image_layout.into();
        self
    }

    pub fn get_sampler<'a>(&'a self) -> vks::VkSampler {
        self.raw.sampler
    }

    pub fn get_image_view<'a>(&'a self) -> vks::VkImageView {
        self.raw.imageView
    }

    pub fn get_image_layout<'a>(&'a self) -> ImageLayout {
        self.raw.imageLayout.into()
    }

    pub fn build(self) -> DescriptorImageInfo {
        DescriptorImageInfo {
            raw: self.raw,
        }
    }
}


/// A `VkWriteDescriptorSet`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct WriteDescriptorSet<'s> {
    raw: vks::VkWriteDescriptorSet,
    _p: PhantomData<&'s ()>,
}

impl<'s> WriteDescriptorSet<'s> {
    pub fn builder<'b>() -> WriteDescriptorSetBuilder<'b> {
        WriteDescriptorSetBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkWriteDescriptorSet) -> WriteDescriptorSet<'s> {
        WriteDescriptorSet { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn dst_set<'a>(&'a self) -> vks::VkDescriptorSet {
        self.raw.dstSet
    }

    pub fn dst_binding<'a>(&'a self) -> u32 {
        self.raw.dstBinding.into()
    }

    pub fn dst_array_element<'a>(&'a self) -> u32 {
        self.raw.dstArrayElement.into()
    }

    pub fn descriptor_count<'a>(&'a self) -> u32 {
        self.raw.descriptorCount.into()
    }

    pub fn descriptor_type<'a>(&'a self) -> DescriptorType {
        self.raw.descriptorType.into()
    }

    pub fn image_info<'a>(&'a self) -> &'a DescriptorImageInfo {
        unsafe { &*(self.raw.pImageInfo as *const vks::VkDescriptorImageInfo as *const _) }
    }

    pub fn buffer_info<'a>(&'a self) -> &'a DescriptorBufferInfo {
        unsafe { &*(self.raw.pBufferInfo as *const vks::VkDescriptorBufferInfo as *const _) }
    }

    pub fn texel_buffer_view<'a>(&'a self) -> &'a vks::VkBufferView {
        unsafe { &*(self.raw.pTexelBufferView as *const _) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_dst_set<'m, H>(&mut self, dst_set: H)
            where H: Handle<Target=DescriptorSetHandle> {
        self.raw.dstSet = dst_set.handle().0;
    }

    pub fn set_dst_binding<'m>(&mut self, dst_binding: u32) {
        self.raw.dstBinding = dst_binding.into();
    }

    pub fn set_dst_array_element<'m>(&mut self, dst_array_element: u32) {
        self.raw.dstArrayElement = dst_array_element.into();
    }

    pub fn set_descriptor_count<'m>(&mut self, descriptor_count: u32) {
        self.raw.descriptorCount = descriptor_count.into();
    }

    pub fn set_descriptor_type<'m>(&mut self, descriptor_type: DescriptorType) {
        self.raw.descriptorType = descriptor_type.into();
    }

    pub fn set_image_info<'m, 'a>(&mut self, image_info: &'a DescriptorImageInfo)
            where 'a: 's {
        self.raw.pImageInfo = image_info.as_raw();
    }

    pub fn set_buffer_info<'m, 'a>(&mut self, buffer_info: &'a DescriptorBufferInfo)
            where 'a: 's {
        self.raw.pBufferInfo = buffer_info.as_raw();
    }

    pub fn set_texel_buffer_view<'m, 'a, H>(&mut self, texel_buffer_view: &'a H)
            where H: Handle<Target=BufferViewHandle> {
        self.raw.pTexelBufferView = &texel_buffer_view.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkWriteDescriptorSet {
        &self.raw
    }
}

impl<'s> From<WriteDescriptorSet<'s>> for vks::VkWriteDescriptorSet {
    fn from(f: WriteDescriptorSet<'s>) -> vks::VkWriteDescriptorSet {
        f.raw
    }
}


/// A builder for `VkWriteDescriptorSet`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct WriteDescriptorSetBuilder<'b> {
    raw: vks::VkWriteDescriptorSet,
    _p: PhantomData<&'b ()>, 
}

impl<'b> WriteDescriptorSetBuilder<'b> {
    pub fn new() -> WriteDescriptorSetBuilder<'b> {
        WriteDescriptorSetBuilder {
            raw: vks::VkWriteDescriptorSet::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> WriteDescriptorSetBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn dst_set<'m, H>(mut self, dst_set: H) -> WriteDescriptorSetBuilder<'b>
            where H: Handle<Target=DescriptorSetHandle> {
        self.raw.dstSet = dst_set.handle().0;
        self
    }

    pub fn dst_binding<'m>(mut self, dst_binding: u32) -> WriteDescriptorSetBuilder<'b> {
        self.raw.dstBinding = dst_binding.into();
        self
    }

    pub fn dst_array_element<'m>(mut self, dst_array_element: u32) -> WriteDescriptorSetBuilder<'b> {
        self.raw.dstArrayElement = dst_array_element.into();
        self
    }

    pub fn descriptor_count<'m>(mut self, descriptor_count: u32) -> WriteDescriptorSetBuilder<'b> {
        self.raw.descriptorCount = descriptor_count.into();
        self
    }

    pub fn descriptor_type<'m>(mut self, descriptor_type: DescriptorType) -> WriteDescriptorSetBuilder<'b> {
        self.raw.descriptorType = descriptor_type.into();
        self
    }

    pub fn image_info<'m, 'a>(mut self, image_info: &'a DescriptorImageInfo) -> WriteDescriptorSetBuilder<'b>
            where 'a: 'b {
        self.raw.pImageInfo = image_info.as_raw();
        self
    }

    pub fn buffer_info<'m, 'a>(mut self, buffer_info: &'a DescriptorBufferInfo) -> WriteDescriptorSetBuilder<'b>
            where 'a: 'b {
        self.raw.pBufferInfo = buffer_info.as_raw();
        self
    }

    pub fn texel_buffer_view<'m, 'a, H>(mut self, texel_buffer_view: &'a H) -> WriteDescriptorSetBuilder<'b>
            where H: Handle<Target=BufferViewHandle> {
        self.raw.pTexelBufferView = &texel_buffer_view.handle().0;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_dst_set<'a>(&'a self) -> vks::VkDescriptorSet {
        self.raw.dstSet
    }

    pub fn get_dst_binding<'a>(&'a self) -> u32 {
        self.raw.dstBinding.into()
    }

    pub fn get_dst_array_element<'a>(&'a self) -> u32 {
        self.raw.dstArrayElement.into()
    }

    pub fn get_descriptor_count<'a>(&'a self) -> u32 {
        self.raw.descriptorCount.into()
    }

    pub fn get_descriptor_type<'a>(&'a self) -> DescriptorType {
        self.raw.descriptorType.into()
    }

    pub fn get_image_info<'a>(&'a self) -> &'a DescriptorImageInfo {
        unsafe { &*(self.raw.pImageInfo as *const vks::VkDescriptorImageInfo as *const _) }
    }

    pub fn get_buffer_info<'a>(&'a self) -> &'a DescriptorBufferInfo {
        unsafe { &*(self.raw.pBufferInfo as *const vks::VkDescriptorBufferInfo as *const _) }
    }

    pub fn get_texel_buffer_view<'a>(&'a self) -> &'a vks::VkBufferView {
        unsafe { &*(self.raw.pTexelBufferView as *const _) }
    }

    pub fn build(self) -> WriteDescriptorSet<'b> {
        WriteDescriptorSet {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkCopyDescriptorSet`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct CopyDescriptorSet<'s> {
    raw: vks::VkCopyDescriptorSet,
    _p: PhantomData<&'s ()>,
}

impl<'s> CopyDescriptorSet<'s> {
    pub fn builder<'b>() -> CopyDescriptorSetBuilder<'b> {
        CopyDescriptorSetBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkCopyDescriptorSet) -> CopyDescriptorSet<'s> {
        CopyDescriptorSet { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn src_set<'a>(&'a self) -> vks::VkDescriptorSet {
        self.raw.srcSet
    }

    pub fn src_binding<'a>(&'a self) -> u32 {
        self.raw.srcBinding.into()
    }

    pub fn src_array_element<'a>(&'a self) -> u32 {
        self.raw.srcArrayElement.into()
    }

    pub fn dst_set<'a>(&'a self) -> vks::VkDescriptorSet {
        self.raw.dstSet
    }

    pub fn dst_binding<'a>(&'a self) -> u32 {
        self.raw.dstBinding.into()
    }

    pub fn dst_array_element<'a>(&'a self) -> u32 {
        self.raw.dstArrayElement.into()
    }

    pub fn descriptor_count<'a>(&'a self) -> u32 {
        self.raw.descriptorCount.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_src_set<'m, H>(&mut self, src_set: H)
            where H: Handle<Target=DescriptorSetHandle> {
        self.raw.srcSet = src_set.handle().0;
    }

    pub fn set_src_binding<'m>(&mut self, src_binding: u32) {
        self.raw.srcBinding = src_binding.into();
    }

    pub fn set_src_array_element<'m>(&mut self, src_array_element: u32) {
        self.raw.srcArrayElement = src_array_element.into();
    }

    pub fn set_dst_set<'m, H>(&mut self, dst_set: H)
            where H: Handle<Target=DescriptorSetHandle> {
        self.raw.dstSet = dst_set.handle().0;
    }

    pub fn set_dst_binding<'m>(&mut self, dst_binding: u32) {
        self.raw.dstBinding = dst_binding.into();
    }

    pub fn set_dst_array_element<'m>(&mut self, dst_array_element: u32) {
        self.raw.dstArrayElement = dst_array_element.into();
    }

    pub fn set_descriptor_count<'m>(&mut self, descriptor_count: u32) {
        self.raw.descriptorCount = descriptor_count.into();
    }

    pub fn as_raw(&self) -> &vks::VkCopyDescriptorSet {
        &self.raw
    }
}

impl<'s> From<CopyDescriptorSet<'s>> for vks::VkCopyDescriptorSet {
    fn from(f: CopyDescriptorSet<'s>) -> vks::VkCopyDescriptorSet {
        f.raw
    }
}


/// A builder for `VkCopyDescriptorSet`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct CopyDescriptorSetBuilder<'b> {
    raw: vks::VkCopyDescriptorSet,
    _p: PhantomData<&'b ()>, 
}

impl<'b> CopyDescriptorSetBuilder<'b> {
    pub fn new() -> CopyDescriptorSetBuilder<'b> {
        CopyDescriptorSetBuilder {
            raw: vks::VkCopyDescriptorSet::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> CopyDescriptorSetBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn src_set<'m, H>(mut self, src_set: H) -> CopyDescriptorSetBuilder<'b>
            where H: Handle<Target=DescriptorSetHandle> {
        self.raw.srcSet = src_set.handle().0;
        self
    }

    pub fn src_binding<'m>(mut self, src_binding: u32) -> CopyDescriptorSetBuilder<'b> {
        self.raw.srcBinding = src_binding.into();
        self
    }

    pub fn src_array_element<'m>(mut self, src_array_element: u32) -> CopyDescriptorSetBuilder<'b> {
        self.raw.srcArrayElement = src_array_element.into();
        self
    }

    pub fn dst_set<'m, H>(mut self, dst_set: H) -> CopyDescriptorSetBuilder<'b>
            where H: Handle<Target=DescriptorSetHandle> {
        self.raw.dstSet = dst_set.handle().0;
        self
    }

    pub fn dst_binding<'m>(mut self, dst_binding: u32) -> CopyDescriptorSetBuilder<'b> {
        self.raw.dstBinding = dst_binding.into();
        self
    }

    pub fn dst_array_element<'m>(mut self, dst_array_element: u32) -> CopyDescriptorSetBuilder<'b> {
        self.raw.dstArrayElement = dst_array_element.into();
        self
    }

    pub fn descriptor_count<'m>(mut self, descriptor_count: u32) -> CopyDescriptorSetBuilder<'b> {
        self.raw.descriptorCount = descriptor_count.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_src_set<'a>(&'a self) -> vks::VkDescriptorSet {
        self.raw.srcSet
    }

    pub fn get_src_binding<'a>(&'a self) -> u32 {
        self.raw.srcBinding.into()
    }

    pub fn get_src_array_element<'a>(&'a self) -> u32 {
        self.raw.srcArrayElement.into()
    }

    pub fn get_dst_set<'a>(&'a self) -> vks::VkDescriptorSet {
        self.raw.dstSet
    }

    pub fn get_dst_binding<'a>(&'a self) -> u32 {
        self.raw.dstBinding.into()
    }

    pub fn get_dst_array_element<'a>(&'a self) -> u32 {
        self.raw.dstArrayElement.into()
    }

    pub fn get_descriptor_count<'a>(&'a self) -> u32 {
        self.raw.descriptorCount.into()
    }

    pub fn build(self) -> CopyDescriptorSet<'b> {
        CopyDescriptorSet {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkBufferCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct BufferCreateInfo<'s> {
    raw: vks::VkBufferCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> BufferCreateInfo<'s> {
    pub fn builder<'b>() -> BufferCreateInfoBuilder<'b> {
        BufferCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkBufferCreateInfo) -> BufferCreateInfo<'s> {
        BufferCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> BufferCreateFlags {
        BufferCreateFlags::from_bits(self.raw.flags)
            .expect("BufferCreateInfo::flags: error converting flags")
    }

    pub fn size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn usage<'a>(&'a self) -> BufferUsageFlags {
        BufferUsageFlags::from_bits(self.raw.usage)
            .expect("BufferCreateInfo::usage: error converting flags")
    }

    pub fn sharing_mode<'a>(&'a self) -> SharingMode {
        self.raw.sharingMode.into()
    }

    pub fn queue_family_indices<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pQueueFamilyIndices as *const _, self.raw.queueFamilyIndexCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: BufferCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_size<'m>(&mut self, size: u64) {
        self.raw.size = size.into();
    }

    pub fn set_usage<'m>(&mut self, usage: BufferUsageFlags) {
        self.raw.usage = usage.bits();
    }

    pub fn set_sharing_mode<'m>(&mut self, sharing_mode: SharingMode) {
        self.raw.sharingMode = sharing_mode.into();
    }

    pub fn set_queue_family_indices<'m, 'a>(&mut self, queue_family_indices: &'a [u32])
            where 'a: 's {
        assert!(self.raw.queueFamilyIndexCount == 0 || self.raw.queueFamilyIndexCount == queue_family_indices.len() as _, 
            "count inconsistency found when specifying `BufferCreateInfo::queue_family_indices`.");
        self.raw.queueFamilyIndexCount = queue_family_indices.len() as _;
        self.raw.pQueueFamilyIndices = queue_family_indices.as_ptr() as *const u32 as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkBufferCreateInfo {
        &self.raw
    }
}

impl<'s> From<BufferCreateInfo<'s>> for vks::VkBufferCreateInfo {
    fn from(f: BufferCreateInfo<'s>) -> vks::VkBufferCreateInfo {
        f.raw
    }
}


/// A builder for `VkBufferCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct BufferCreateInfoBuilder<'b> {
    raw: vks::VkBufferCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> BufferCreateInfoBuilder<'b> {
    pub fn new() -> BufferCreateInfoBuilder<'b> {
        BufferCreateInfoBuilder {
            raw: vks::VkBufferCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> BufferCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: BufferCreateFlags) -> BufferCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn size<'m>(mut self, size: u64) -> BufferCreateInfoBuilder<'b> {
        self.raw.size = size.into();
        self
    }

    pub fn usage<'m>(mut self, usage: BufferUsageFlags) -> BufferCreateInfoBuilder<'b> {
        self.raw.usage = usage.bits();
        self
    }

    pub fn sharing_mode<'m>(mut self, sharing_mode: SharingMode) -> BufferCreateInfoBuilder<'b> {
        self.raw.sharingMode = sharing_mode.into();
        self
    }

    pub fn queue_family_indices<'m, 'a>(mut self, queue_family_indices: &'a [u32]) -> BufferCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.queueFamilyIndexCount == 0 || self.raw.queueFamilyIndexCount == queue_family_indices.len() as _, 
            "count inconsistency found when specifying `BufferCreateInfo::queue_family_indices`.");
        self.raw.queueFamilyIndexCount = queue_family_indices.len() as _;
        self.raw.pQueueFamilyIndices = queue_family_indices.as_ptr() as *const u32 as *const _;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> BufferCreateFlags {
        BufferCreateFlags::from_bits(self.raw.flags)
            .expect("BufferCreateInfo::flags: error converting flags")
    }

    pub fn get_size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn get_usage<'a>(&'a self) -> BufferUsageFlags {
        BufferUsageFlags::from_bits(self.raw.usage)
            .expect("BufferCreateInfo::usage: error converting flags")
    }

    pub fn get_sharing_mode<'a>(&'a self) -> SharingMode {
        self.raw.sharingMode.into()
    }

    pub fn get_queue_family_indices<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pQueueFamilyIndices as *const _, self.raw.queueFamilyIndexCount as usize) }
    }

    pub fn build(self) -> BufferCreateInfo<'b> {
        BufferCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkBufferViewCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct BufferViewCreateInfo<'s> {
    raw: vks::VkBufferViewCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> BufferViewCreateInfo<'s> {
    pub fn builder<'b>() -> BufferViewCreateInfoBuilder<'b> {
        BufferViewCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkBufferViewCreateInfo) -> BufferViewCreateInfo<'s> {
        BufferViewCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> BufferViewCreateFlags {
        BufferViewCreateFlags::from_bits(self.raw.flags)
            .expect("BufferViewCreateInfo::flags: error converting flags")
    }

    pub fn buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn offset<'a>(&'a self) -> u64 {
        self.raw.offset.into()
    }

    pub fn range<'a>(&'a self) -> u64 {
        self.raw.range.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: BufferViewCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_buffer<'m, H>(&mut self, buffer: H)
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
    }

    pub fn set_format<'m>(&mut self, format: Format) {
        self.raw.format = format.into();
    }

    pub fn set_offset<'m>(&mut self, offset: u64) {
        self.raw.offset = offset.into();
    }

    pub fn set_range<'m>(&mut self, range: u64) {
        self.raw.range = range.into();
    }

    pub fn as_raw(&self) -> &vks::VkBufferViewCreateInfo {
        &self.raw
    }
}

impl<'s> From<BufferViewCreateInfo<'s>> for vks::VkBufferViewCreateInfo {
    fn from(f: BufferViewCreateInfo<'s>) -> vks::VkBufferViewCreateInfo {
        f.raw
    }
}


/// A builder for `VkBufferViewCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct BufferViewCreateInfoBuilder<'b> {
    raw: vks::VkBufferViewCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> BufferViewCreateInfoBuilder<'b> {
    pub fn new() -> BufferViewCreateInfoBuilder<'b> {
        BufferViewCreateInfoBuilder {
            raw: vks::VkBufferViewCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> BufferViewCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: BufferViewCreateFlags) -> BufferViewCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn buffer<'m, H>(mut self, buffer: H) -> BufferViewCreateInfoBuilder<'b>
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
        self
    }

    pub fn format<'m>(mut self, format: Format) -> BufferViewCreateInfoBuilder<'b> {
        self.raw.format = format.into();
        self
    }

    pub fn offset<'m>(mut self, offset: u64) -> BufferViewCreateInfoBuilder<'b> {
        self.raw.offset = offset.into();
        self
    }

    pub fn range<'m>(mut self, range: u64) -> BufferViewCreateInfoBuilder<'b> {
        self.raw.range = range.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> BufferViewCreateFlags {
        BufferViewCreateFlags::from_bits(self.raw.flags)
            .expect("BufferViewCreateInfo::flags: error converting flags")
    }

    pub fn get_buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn get_format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn get_offset<'a>(&'a self) -> u64 {
        self.raw.offset.into()
    }

    pub fn get_range<'a>(&'a self) -> u64 {
        self.raw.range.into()
    }

    pub fn build(self) -> BufferViewCreateInfo<'b> {
        BufferViewCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImageSubresource`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageSubresource {
    raw: vks::VkImageSubresource,
}

impl ImageSubresource {
    pub fn builder() -> ImageSubresourceBuilder {
        ImageSubresourceBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageSubresource) -> ImageSubresource {
        ImageSubresource { raw, }
    }

    pub fn aspect_mask<'a>(&'a self) -> ImageAspectFlags {
        ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("ImageSubresource::aspect_mask: error converting flags")
    }

    pub fn mip_level<'a>(&'a self) -> u32 {
        self.raw.mipLevel.into()
    }

    pub fn array_layer<'a>(&'a self) -> u32 {
        self.raw.arrayLayer.into()
    }

    pub fn set_aspect_mask<'m>(&mut self, aspect_mask: ImageAspectFlags) {
        self.raw.aspectMask = aspect_mask.bits();
    }

    pub fn set_mip_level<'m>(&mut self, mip_level: u32) {
        self.raw.mipLevel = mip_level.into();
    }

    pub fn set_array_layer<'m>(&mut self, array_layer: u32) {
        self.raw.arrayLayer = array_layer.into();
    }

    pub fn as_raw(&self) -> &vks::VkImageSubresource {
        &self.raw
    }
}

impl From<ImageSubresource> for vks::VkImageSubresource {
    fn from(f: ImageSubresource) -> vks::VkImageSubresource {
        f.raw
    }
}


/// A builder for `VkImageSubresource`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageSubresourceBuilder {
    raw: vks::VkImageSubresource,
}

impl ImageSubresourceBuilder {
    pub fn new() -> ImageSubresourceBuilder {
        ImageSubresourceBuilder {
            raw: vks::VkImageSubresource::default(),
        }
    }

    pub fn aspect_mask<'m>(mut self, aspect_mask: ImageAspectFlags) -> ImageSubresourceBuilder {
        self.raw.aspectMask = aspect_mask.bits();
        self
    }

    pub fn mip_level<'m>(mut self, mip_level: u32) -> ImageSubresourceBuilder {
        self.raw.mipLevel = mip_level.into();
        self
    }

    pub fn array_layer<'m>(mut self, array_layer: u32) -> ImageSubresourceBuilder {
        self.raw.arrayLayer = array_layer.into();
        self
    }

    pub fn get_aspect_mask<'a>(&'a self) -> ImageAspectFlags {
        ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("ImageSubresource::aspect_mask: error converting flags")
    }

    pub fn get_mip_level<'a>(&'a self) -> u32 {
        self.raw.mipLevel.into()
    }

    pub fn get_array_layer<'a>(&'a self) -> u32 {
        self.raw.arrayLayer.into()
    }

    pub fn build(self) -> ImageSubresource {
        ImageSubresource {
            raw: self.raw,
        }
    }
}


/// A `VkImageSubresourceLayers`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageSubresourceLayers {
    raw: vks::VkImageSubresourceLayers,
}

impl ImageSubresourceLayers {
    pub fn builder() -> ImageSubresourceLayersBuilder {
        ImageSubresourceLayersBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageSubresourceLayers) -> ImageSubresourceLayers {
        ImageSubresourceLayers { raw, }
    }

    pub fn aspect_mask<'a>(&'a self) -> ImageAspectFlags {
        ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("ImageSubresourceLayers::aspect_mask: error converting flags")
    }

    pub fn mip_level<'a>(&'a self) -> u32 {
        self.raw.mipLevel.into()
    }

    pub fn base_array_layer<'a>(&'a self) -> u32 {
        self.raw.baseArrayLayer.into()
    }

    pub fn layer_count<'a>(&'a self) -> u32 {
        self.raw.layerCount.into()
    }

    pub fn set_aspect_mask<'m>(&mut self, aspect_mask: ImageAspectFlags) {
        self.raw.aspectMask = aspect_mask.bits();
    }

    pub fn set_mip_level<'m>(&mut self, mip_level: u32) {
        self.raw.mipLevel = mip_level.into();
    }

    pub fn set_base_array_layer<'m>(&mut self, base_array_layer: u32) {
        self.raw.baseArrayLayer = base_array_layer.into();
    }

    pub fn set_layer_count<'m>(&mut self, layer_count: u32) {
        self.raw.layerCount = layer_count.into();
    }

    pub fn as_raw(&self) -> &vks::VkImageSubresourceLayers {
        &self.raw
    }
}

impl From<ImageSubresourceLayers> for vks::VkImageSubresourceLayers {
    fn from(f: ImageSubresourceLayers) -> vks::VkImageSubresourceLayers {
        f.raw
    }
}


/// A builder for `VkImageSubresourceLayers`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageSubresourceLayersBuilder {
    raw: vks::VkImageSubresourceLayers,
}

impl ImageSubresourceLayersBuilder {
    pub fn new() -> ImageSubresourceLayersBuilder {
        ImageSubresourceLayersBuilder {
            raw: vks::VkImageSubresourceLayers::default(),
        }
    }

    pub fn aspect_mask<'m>(mut self, aspect_mask: ImageAspectFlags) -> ImageSubresourceLayersBuilder {
        self.raw.aspectMask = aspect_mask.bits();
        self
    }

    pub fn mip_level<'m>(mut self, mip_level: u32) -> ImageSubresourceLayersBuilder {
        self.raw.mipLevel = mip_level.into();
        self
    }

    pub fn base_array_layer<'m>(mut self, base_array_layer: u32) -> ImageSubresourceLayersBuilder {
        self.raw.baseArrayLayer = base_array_layer.into();
        self
    }

    pub fn layer_count<'m>(mut self, layer_count: u32) -> ImageSubresourceLayersBuilder {
        self.raw.layerCount = layer_count.into();
        self
    }

    pub fn get_aspect_mask<'a>(&'a self) -> ImageAspectFlags {
        ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("ImageSubresourceLayers::aspect_mask: error converting flags")
    }

    pub fn get_mip_level<'a>(&'a self) -> u32 {
        self.raw.mipLevel.into()
    }

    pub fn get_base_array_layer<'a>(&'a self) -> u32 {
        self.raw.baseArrayLayer.into()
    }

    pub fn get_layer_count<'a>(&'a self) -> u32 {
        self.raw.layerCount.into()
    }

    pub fn build(self) -> ImageSubresourceLayers {
        ImageSubresourceLayers {
            raw: self.raw,
        }
    }
}


/// A `VkImageSubresourceRange`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageSubresourceRange {
    raw: vks::VkImageSubresourceRange,
}

impl ImageSubresourceRange {
    pub fn builder() -> ImageSubresourceRangeBuilder {
        ImageSubresourceRangeBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageSubresourceRange) -> ImageSubresourceRange {
        ImageSubresourceRange { raw, }
    }

    pub fn aspect_mask<'a>(&'a self) -> ImageAspectFlags {
        ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("ImageSubresourceRange::aspect_mask: error converting flags")
    }

    pub fn base_mip_level<'a>(&'a self) -> u32 {
        self.raw.baseMipLevel.into()
    }

    pub fn level_count<'a>(&'a self) -> u32 {
        self.raw.levelCount.into()
    }

    pub fn base_array_layer<'a>(&'a self) -> u32 {
        self.raw.baseArrayLayer.into()
    }

    pub fn layer_count<'a>(&'a self) -> u32 {
        self.raw.layerCount.into()
    }

    pub fn set_aspect_mask<'m>(&mut self, aspect_mask: ImageAspectFlags) {
        self.raw.aspectMask = aspect_mask.bits();
    }

    pub fn set_base_mip_level<'m>(&mut self, base_mip_level: u32) {
        self.raw.baseMipLevel = base_mip_level.into();
    }

    pub fn set_level_count<'m>(&mut self, level_count: u32) {
        self.raw.levelCount = level_count.into();
    }

    pub fn set_base_array_layer<'m>(&mut self, base_array_layer: u32) {
        self.raw.baseArrayLayer = base_array_layer.into();
    }

    pub fn set_layer_count<'m>(&mut self, layer_count: u32) {
        self.raw.layerCount = layer_count.into();
    }

    pub fn as_raw(&self) -> &vks::VkImageSubresourceRange {
        &self.raw
    }
}

impl From<ImageSubresourceRange> for vks::VkImageSubresourceRange {
    fn from(f: ImageSubresourceRange) -> vks::VkImageSubresourceRange {
        f.raw
    }
}


/// A builder for `VkImageSubresourceRange`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageSubresourceRangeBuilder {
    raw: vks::VkImageSubresourceRange,
}

impl ImageSubresourceRangeBuilder {
    pub fn new() -> ImageSubresourceRangeBuilder {
        ImageSubresourceRangeBuilder {
            raw: vks::VkImageSubresourceRange::default(),
        }
    }

    pub fn aspect_mask<'m>(mut self, aspect_mask: ImageAspectFlags) -> ImageSubresourceRangeBuilder {
        self.raw.aspectMask = aspect_mask.bits();
        self
    }

    pub fn base_mip_level<'m>(mut self, base_mip_level: u32) -> ImageSubresourceRangeBuilder {
        self.raw.baseMipLevel = base_mip_level.into();
        self
    }

    pub fn level_count<'m>(mut self, level_count: u32) -> ImageSubresourceRangeBuilder {
        self.raw.levelCount = level_count.into();
        self
    }

    pub fn base_array_layer<'m>(mut self, base_array_layer: u32) -> ImageSubresourceRangeBuilder {
        self.raw.baseArrayLayer = base_array_layer.into();
        self
    }

    pub fn layer_count<'m>(mut self, layer_count: u32) -> ImageSubresourceRangeBuilder {
        self.raw.layerCount = layer_count.into();
        self
    }

    pub fn get_aspect_mask<'a>(&'a self) -> ImageAspectFlags {
        ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("ImageSubresourceRange::aspect_mask: error converting flags")
    }

    pub fn get_base_mip_level<'a>(&'a self) -> u32 {
        self.raw.baseMipLevel.into()
    }

    pub fn get_level_count<'a>(&'a self) -> u32 {
        self.raw.levelCount.into()
    }

    pub fn get_base_array_layer<'a>(&'a self) -> u32 {
        self.raw.baseArrayLayer.into()
    }

    pub fn get_layer_count<'a>(&'a self) -> u32 {
        self.raw.layerCount.into()
    }

    pub fn build(self) -> ImageSubresourceRange {
        ImageSubresourceRange {
            raw: self.raw,
        }
    }
}


/// A `VkMemoryBarrier`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryBarrier<'s> {
    raw: vks::VkMemoryBarrier,
    _p: PhantomData<&'s ()>,
}

impl<'s> MemoryBarrier<'s> {
    pub fn builder<'b>() -> MemoryBarrierBuilder<'b> {
        MemoryBarrierBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryBarrier) -> MemoryBarrier<'s> {
        MemoryBarrier { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn src_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.srcAccessMask)
            .expect("MemoryBarrier::src_access_mask: error converting flags")
    }

    pub fn dst_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.dstAccessMask)
            .expect("MemoryBarrier::dst_access_mask: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_src_access_mask<'m>(&mut self, src_access_mask: AccessFlags) {
        self.raw.srcAccessMask = src_access_mask.bits();
    }

    pub fn set_dst_access_mask<'m>(&mut self, dst_access_mask: AccessFlags) {
        self.raw.dstAccessMask = dst_access_mask.bits();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryBarrier {
        &self.raw
    }
}

impl<'s> From<MemoryBarrier<'s>> for vks::VkMemoryBarrier {
    fn from(f: MemoryBarrier<'s>) -> vks::VkMemoryBarrier {
        f.raw
    }
}


/// A builder for `VkMemoryBarrier`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryBarrierBuilder<'b> {
    raw: vks::VkMemoryBarrier,
    _p: PhantomData<&'b ()>, 
}

impl<'b> MemoryBarrierBuilder<'b> {
    pub fn new() -> MemoryBarrierBuilder<'b> {
        MemoryBarrierBuilder {
            raw: vks::VkMemoryBarrier::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> MemoryBarrierBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn src_access_mask<'m>(mut self, src_access_mask: AccessFlags) -> MemoryBarrierBuilder<'b> {
        self.raw.srcAccessMask = src_access_mask.bits();
        self
    }

    pub fn dst_access_mask<'m>(mut self, dst_access_mask: AccessFlags) -> MemoryBarrierBuilder<'b> {
        self.raw.dstAccessMask = dst_access_mask.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_src_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.srcAccessMask)
            .expect("MemoryBarrier::src_access_mask: error converting flags")
    }

    pub fn get_dst_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.dstAccessMask)
            .expect("MemoryBarrier::dst_access_mask: error converting flags")
    }

    pub fn build(self) -> MemoryBarrier<'b> {
        MemoryBarrier {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkBufferMemoryBarrier`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct BufferMemoryBarrier<'s> {
    raw: vks::VkBufferMemoryBarrier,
    _p: PhantomData<&'s ()>,
}

impl<'s> BufferMemoryBarrier<'s> {
    pub fn builder<'b>() -> BufferMemoryBarrierBuilder<'b> {
        BufferMemoryBarrierBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkBufferMemoryBarrier) -> BufferMemoryBarrier<'s> {
        BufferMemoryBarrier { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn src_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.srcAccessMask)
            .expect("BufferMemoryBarrier::src_access_mask: error converting flags")
    }

    pub fn dst_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.dstAccessMask)
            .expect("BufferMemoryBarrier::dst_access_mask: error converting flags")
    }

    pub fn src_queue_family_index<'a>(&'a self) -> u32 {
        self.raw.srcQueueFamilyIndex.into()
    }

    pub fn dst_queue_family_index<'a>(&'a self) -> u32 {
        self.raw.dstQueueFamilyIndex.into()
    }

    pub fn buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn offset<'a>(&'a self) -> u64 {
        self.raw.offset.into()
    }

    pub fn size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_src_access_mask<'m>(&mut self, src_access_mask: AccessFlags) {
        self.raw.srcAccessMask = src_access_mask.bits();
    }

    pub fn set_dst_access_mask<'m>(&mut self, dst_access_mask: AccessFlags) {
        self.raw.dstAccessMask = dst_access_mask.bits();
    }

    pub fn set_src_queue_family_index<'m>(&mut self, src_queue_family_index: u32) {
        self.raw.srcQueueFamilyIndex = src_queue_family_index.into();
    }

    pub fn set_dst_queue_family_index<'m>(&mut self, dst_queue_family_index: u32) {
        self.raw.dstQueueFamilyIndex = dst_queue_family_index.into();
    }

    pub fn set_buffer<'m, H>(&mut self, buffer: H)
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
    }

    pub fn set_offset<'m>(&mut self, offset: u64) {
        self.raw.offset = offset.into();
    }

    pub fn set_size<'m>(&mut self, size: u64) {
        self.raw.size = size.into();
    }

    pub fn as_raw(&self) -> &vks::VkBufferMemoryBarrier {
        &self.raw
    }
}

impl<'s> From<BufferMemoryBarrier<'s>> for vks::VkBufferMemoryBarrier {
    fn from(f: BufferMemoryBarrier<'s>) -> vks::VkBufferMemoryBarrier {
        f.raw
    }
}


/// A builder for `VkBufferMemoryBarrier`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct BufferMemoryBarrierBuilder<'b> {
    raw: vks::VkBufferMemoryBarrier,
    _p: PhantomData<&'b ()>, 
}

impl<'b> BufferMemoryBarrierBuilder<'b> {
    pub fn new() -> BufferMemoryBarrierBuilder<'b> {
        BufferMemoryBarrierBuilder {
            raw: vks::VkBufferMemoryBarrier::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> BufferMemoryBarrierBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn src_access_mask<'m>(mut self, src_access_mask: AccessFlags) -> BufferMemoryBarrierBuilder<'b> {
        self.raw.srcAccessMask = src_access_mask.bits();
        self
    }

    pub fn dst_access_mask<'m>(mut self, dst_access_mask: AccessFlags) -> BufferMemoryBarrierBuilder<'b> {
        self.raw.dstAccessMask = dst_access_mask.bits();
        self
    }

    pub fn src_queue_family_index<'m>(mut self, src_queue_family_index: u32) -> BufferMemoryBarrierBuilder<'b> {
        self.raw.srcQueueFamilyIndex = src_queue_family_index.into();
        self
    }

    pub fn dst_queue_family_index<'m>(mut self, dst_queue_family_index: u32) -> BufferMemoryBarrierBuilder<'b> {
        self.raw.dstQueueFamilyIndex = dst_queue_family_index.into();
        self
    }

    pub fn buffer<'m, H>(mut self, buffer: H) -> BufferMemoryBarrierBuilder<'b>
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
        self
    }

    pub fn offset<'m>(mut self, offset: u64) -> BufferMemoryBarrierBuilder<'b> {
        self.raw.offset = offset.into();
        self
    }

    pub fn size<'m>(mut self, size: u64) -> BufferMemoryBarrierBuilder<'b> {
        self.raw.size = size.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_src_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.srcAccessMask)
            .expect("BufferMemoryBarrier::src_access_mask: error converting flags")
    }

    pub fn get_dst_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.dstAccessMask)
            .expect("BufferMemoryBarrier::dst_access_mask: error converting flags")
    }

    pub fn get_src_queue_family_index<'a>(&'a self) -> u32 {
        self.raw.srcQueueFamilyIndex.into()
    }

    pub fn get_dst_queue_family_index<'a>(&'a self) -> u32 {
        self.raw.dstQueueFamilyIndex.into()
    }

    pub fn get_buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn get_offset<'a>(&'a self) -> u64 {
        self.raw.offset.into()
    }

    pub fn get_size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn build(self) -> BufferMemoryBarrier<'b> {
        BufferMemoryBarrier {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImageMemoryBarrier`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageMemoryBarrier<'s> {
    raw: vks::VkImageMemoryBarrier,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImageMemoryBarrier<'s> {
    pub fn builder<'b>() -> ImageMemoryBarrierBuilder<'b> {
        ImageMemoryBarrierBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageMemoryBarrier) -> ImageMemoryBarrier<'s> {
        ImageMemoryBarrier { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn src_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.srcAccessMask)
            .expect("ImageMemoryBarrier::src_access_mask: error converting flags")
    }

    pub fn dst_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.dstAccessMask)
            .expect("ImageMemoryBarrier::dst_access_mask: error converting flags")
    }

    pub fn old_layout<'a>(&'a self) -> ImageLayout {
        self.raw.oldLayout.into()
    }

    pub fn new_layout<'a>(&'a self) -> ImageLayout {
        self.raw.newLayout.into()
    }

    pub fn src_queue_family_index<'a>(&'a self) -> u32 {
        self.raw.srcQueueFamilyIndex.into()
    }

    pub fn dst_queue_family_index<'a>(&'a self) -> u32 {
        self.raw.dstQueueFamilyIndex.into()
    }

    pub fn image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn subresource_range<'a>(&'a self) -> &'a ImageSubresourceRange {
        unsafe { &*(&self.raw.subresourceRange as *const vks::VkImageSubresourceRange as *const ImageSubresourceRange) }
    }

    pub fn subresource_range_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceRange {
        unsafe { &mut *(&mut self.raw.subresourceRange as *mut  vks::VkImageSubresourceRange as *mut ImageSubresourceRange) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_src_access_mask<'m>(&mut self, src_access_mask: AccessFlags) {
        self.raw.srcAccessMask = src_access_mask.bits();
    }

    pub fn set_dst_access_mask<'m>(&mut self, dst_access_mask: AccessFlags) {
        self.raw.dstAccessMask = dst_access_mask.bits();
    }

    pub fn set_old_layout<'m>(&mut self, old_layout: ImageLayout) {
        self.raw.oldLayout = old_layout.into();
    }

    pub fn set_new_layout<'m>(&mut self, new_layout: ImageLayout) {
        self.raw.newLayout = new_layout.into();
    }

    pub fn set_src_queue_family_index<'m>(&mut self, src_queue_family_index: u32) {
        self.raw.srcQueueFamilyIndex = src_queue_family_index.into();
    }

    pub fn set_dst_queue_family_index<'m>(&mut self, dst_queue_family_index: u32) {
        self.raw.dstQueueFamilyIndex = dst_queue_family_index.into();
    }

    pub fn set_image<'m, H>(&mut self, image: H)
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
    }

    pub fn set_subresource_range<'m>(&mut self, subresource_range: ImageSubresourceRange) {
        self.raw.subresourceRange = subresource_range.raw;
    }

    pub fn as_raw(&self) -> &vks::VkImageMemoryBarrier {
        &self.raw
    }
}

impl<'s> From<ImageMemoryBarrier<'s>> for vks::VkImageMemoryBarrier {
    fn from(f: ImageMemoryBarrier<'s>) -> vks::VkImageMemoryBarrier {
        f.raw
    }
}


/// A builder for `VkImageMemoryBarrier`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageMemoryBarrierBuilder<'b> {
    raw: vks::VkImageMemoryBarrier,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ImageMemoryBarrierBuilder<'b> {
    pub fn new() -> ImageMemoryBarrierBuilder<'b> {
        ImageMemoryBarrierBuilder {
            raw: vks::VkImageMemoryBarrier::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImageMemoryBarrierBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn src_access_mask<'m>(mut self, src_access_mask: AccessFlags) -> ImageMemoryBarrierBuilder<'b> {
        self.raw.srcAccessMask = src_access_mask.bits();
        self
    }

    pub fn dst_access_mask<'m>(mut self, dst_access_mask: AccessFlags) -> ImageMemoryBarrierBuilder<'b> {
        self.raw.dstAccessMask = dst_access_mask.bits();
        self
    }

    pub fn old_layout<'m>(mut self, old_layout: ImageLayout) -> ImageMemoryBarrierBuilder<'b> {
        self.raw.oldLayout = old_layout.into();
        self
    }

    pub fn new_layout<'m>(mut self, new_layout: ImageLayout) -> ImageMemoryBarrierBuilder<'b> {
        self.raw.newLayout = new_layout.into();
        self
    }

    pub fn src_queue_family_index<'m>(mut self, src_queue_family_index: u32) -> ImageMemoryBarrierBuilder<'b> {
        self.raw.srcQueueFamilyIndex = src_queue_family_index.into();
        self
    }

    pub fn dst_queue_family_index<'m>(mut self, dst_queue_family_index: u32) -> ImageMemoryBarrierBuilder<'b> {
        self.raw.dstQueueFamilyIndex = dst_queue_family_index.into();
        self
    }

    pub fn image<'m, H>(mut self, image: H) -> ImageMemoryBarrierBuilder<'b>
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
        self
    }

    pub fn subresource_range<'m>(mut self, subresource_range: ImageSubresourceRange) -> ImageMemoryBarrierBuilder<'b> {
        self.raw.subresourceRange = subresource_range.raw;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_src_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.srcAccessMask)
            .expect("ImageMemoryBarrier::src_access_mask: error converting flags")
    }

    pub fn get_dst_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.dstAccessMask)
            .expect("ImageMemoryBarrier::dst_access_mask: error converting flags")
    }

    pub fn get_old_layout<'a>(&'a self) -> ImageLayout {
        self.raw.oldLayout.into()
    }

    pub fn get_new_layout<'a>(&'a self) -> ImageLayout {
        self.raw.newLayout.into()
    }

    pub fn get_src_queue_family_index<'a>(&'a self) -> u32 {
        self.raw.srcQueueFamilyIndex.into()
    }

    pub fn get_dst_queue_family_index<'a>(&'a self) -> u32 {
        self.raw.dstQueueFamilyIndex.into()
    }

    pub fn get_image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn get_subresource_range<'a>(&'a self) -> &'a ImageSubresourceRange {
        unsafe { &*(&self.raw.subresourceRange as *const vks::VkImageSubresourceRange as *const ImageSubresourceRange) }
    }

    pub fn get_subresource_range_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceRange {
        unsafe { &mut *(&mut self.raw.subresourceRange as *mut  vks::VkImageSubresourceRange as *mut ImageSubresourceRange) }
    }

    pub fn build(self) -> ImageMemoryBarrier<'b> {
        ImageMemoryBarrier {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImageCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageCreateInfo<'s> {
    raw: vks::VkImageCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImageCreateInfo<'s> {
    pub fn builder<'b>() -> ImageCreateInfoBuilder<'b> {
        ImageCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageCreateInfo) -> ImageCreateInfo<'s> {
        ImageCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> ImageCreateFlags {
        ImageCreateFlags::from_bits(self.raw.flags)
            .expect("ImageCreateInfo::flags: error converting flags")
    }

    pub fn image_type<'a>(&'a self) -> ImageType {
        self.raw.imageType.into()
    }

    pub fn format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn extent<'a>(&'a self) -> &'a Extent3d {
        unsafe { &*(&self.raw.extent as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn extent_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn mip_levels<'a>(&'a self) -> u32 {
        self.raw.mipLevels.into()
    }

    pub fn array_layers<'a>(&'a self) -> u32 {
        self.raw.arrayLayers.into()
    }

    pub fn samples<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.samples)
            .expect("ImageCreateInfo::samples: error converting flags")
    }

    pub fn tiling<'a>(&'a self) -> ImageTiling {
        self.raw.tiling.into()
    }

    pub fn usage<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.usage)
            .expect("ImageCreateInfo::usage: error converting flags")
    }

    pub fn sharing_mode<'a>(&'a self) -> SharingMode {
        self.raw.sharingMode.into()
    }

    pub fn queue_family_indices<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pQueueFamilyIndices as *const _, self.raw.queueFamilyIndexCount as usize) }
    }

    pub fn initial_layout<'a>(&'a self) -> ImageLayout {
        self.raw.initialLayout.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: ImageCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_image_type<'m>(&mut self, image_type: ImageType) {
        self.raw.imageType = image_type.into();
    }

    pub fn set_format<'m>(&mut self, format: Format) {
        self.raw.format = format.into();
    }

    pub fn set_extent<'m>(&mut self, extent: Extent3d) {
        self.raw.extent = extent.raw;
    }

    pub fn set_mip_levels<'m>(&mut self, mip_levels: u32) {
        self.raw.mipLevels = mip_levels.into();
    }

    pub fn set_array_layers<'m>(&mut self, array_layers: u32) {
        self.raw.arrayLayers = array_layers.into();
    }

    pub fn set_samples<'m>(&mut self, samples: SampleCountFlags) {
        self.raw.samples = samples.bits();
    }

    pub fn set_tiling<'m>(&mut self, tiling: ImageTiling) {
        self.raw.tiling = tiling.into();
    }

    pub fn set_usage<'m>(&mut self, usage: ImageUsageFlags) {
        self.raw.usage = usage.bits();
    }

    pub fn set_sharing_mode<'m>(&mut self, sharing_mode: SharingMode) {
        self.raw.sharingMode = sharing_mode.into();
    }

    pub fn set_queue_family_indices<'m, 'a>(&mut self, queue_family_indices: &'a [u32])
            where 'a: 's {
        assert!(self.raw.queueFamilyIndexCount == 0 || self.raw.queueFamilyIndexCount == queue_family_indices.len() as _, 
            "count inconsistency found when specifying `ImageCreateInfo::queue_family_indices`.");
        self.raw.queueFamilyIndexCount = queue_family_indices.len() as _;
        self.raw.pQueueFamilyIndices = queue_family_indices.as_ptr() as *const u32 as *const _;
    }

    pub fn set_initial_layout<'m>(&mut self, initial_layout: ImageLayout) {
        self.raw.initialLayout = initial_layout.into();
    }

    pub fn as_raw(&self) -> &vks::VkImageCreateInfo {
        &self.raw
    }
}

impl<'s> From<ImageCreateInfo<'s>> for vks::VkImageCreateInfo {
    fn from(f: ImageCreateInfo<'s>) -> vks::VkImageCreateInfo {
        f.raw
    }
}


/// A builder for `VkImageCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageCreateInfoBuilder<'b> {
    raw: vks::VkImageCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ImageCreateInfoBuilder<'b> {
    pub fn new() -> ImageCreateInfoBuilder<'b> {
        ImageCreateInfoBuilder {
            raw: vks::VkImageCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImageCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: ImageCreateFlags) -> ImageCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn image_type<'m>(mut self, image_type: ImageType) -> ImageCreateInfoBuilder<'b> {
        self.raw.imageType = image_type.into();
        self
    }

    pub fn format<'m>(mut self, format: Format) -> ImageCreateInfoBuilder<'b> {
        self.raw.format = format.into();
        self
    }

    pub fn extent<'m>(mut self, extent: Extent3d) -> ImageCreateInfoBuilder<'b> {
        self.raw.extent = extent.raw;
        self
    }

    pub fn mip_levels<'m>(mut self, mip_levels: u32) -> ImageCreateInfoBuilder<'b> {
        self.raw.mipLevels = mip_levels.into();
        self
    }

    pub fn array_layers<'m>(mut self, array_layers: u32) -> ImageCreateInfoBuilder<'b> {
        self.raw.arrayLayers = array_layers.into();
        self
    }

    pub fn samples<'m>(mut self, samples: SampleCountFlags) -> ImageCreateInfoBuilder<'b> {
        self.raw.samples = samples.bits();
        self
    }

    pub fn tiling<'m>(mut self, tiling: ImageTiling) -> ImageCreateInfoBuilder<'b> {
        self.raw.tiling = tiling.into();
        self
    }

    pub fn usage<'m>(mut self, usage: ImageUsageFlags) -> ImageCreateInfoBuilder<'b> {
        self.raw.usage = usage.bits();
        self
    }

    pub fn sharing_mode<'m>(mut self, sharing_mode: SharingMode) -> ImageCreateInfoBuilder<'b> {
        self.raw.sharingMode = sharing_mode.into();
        self
    }

    pub fn queue_family_indices<'m, 'a>(mut self, queue_family_indices: &'a [u32]) -> ImageCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.queueFamilyIndexCount == 0 || self.raw.queueFamilyIndexCount == queue_family_indices.len() as _, 
            "count inconsistency found when specifying `ImageCreateInfo::queue_family_indices`.");
        self.raw.queueFamilyIndexCount = queue_family_indices.len() as _;
        self.raw.pQueueFamilyIndices = queue_family_indices.as_ptr() as *const u32 as *const _;
        self
    }

    pub fn initial_layout<'m>(mut self, initial_layout: ImageLayout) -> ImageCreateInfoBuilder<'b> {
        self.raw.initialLayout = initial_layout.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> ImageCreateFlags {
        ImageCreateFlags::from_bits(self.raw.flags)
            .expect("ImageCreateInfo::flags: error converting flags")
    }

    pub fn get_image_type<'a>(&'a self) -> ImageType {
        self.raw.imageType.into()
    }

    pub fn get_format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn get_extent<'a>(&'a self) -> &'a Extent3d {
        unsafe { &*(&self.raw.extent as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn get_extent_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn get_mip_levels<'a>(&'a self) -> u32 {
        self.raw.mipLevels.into()
    }

    pub fn get_array_layers<'a>(&'a self) -> u32 {
        self.raw.arrayLayers.into()
    }

    pub fn get_samples<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.samples)
            .expect("ImageCreateInfo::samples: error converting flags")
    }

    pub fn get_tiling<'a>(&'a self) -> ImageTiling {
        self.raw.tiling.into()
    }

    pub fn get_usage<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.usage)
            .expect("ImageCreateInfo::usage: error converting flags")
    }

    pub fn get_sharing_mode<'a>(&'a self) -> SharingMode {
        self.raw.sharingMode.into()
    }

    pub fn get_queue_family_indices<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pQueueFamilyIndices as *const _, self.raw.queueFamilyIndexCount as usize) }
    }

    pub fn get_initial_layout<'a>(&'a self) -> ImageLayout {
        self.raw.initialLayout.into()
    }

    pub fn build(self) -> ImageCreateInfo<'b> {
        ImageCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSubresourceLayout`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SubresourceLayout {
    raw: vks::VkSubresourceLayout,
}

impl SubresourceLayout {
    pub fn builder() -> SubresourceLayoutBuilder {
        SubresourceLayoutBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSubresourceLayout) -> SubresourceLayout {
        SubresourceLayout { raw, }
    }

    pub fn offset<'a>(&'a self) -> u64 {
        self.raw.offset.into()
    }

    pub fn size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn row_pitch<'a>(&'a self) -> u64 {
        self.raw.rowPitch.into()
    }

    pub fn array_pitch<'a>(&'a self) -> u64 {
        self.raw.arrayPitch.into()
    }

    pub fn depth_pitch<'a>(&'a self) -> u64 {
        self.raw.depthPitch.into()
    }

    pub fn set_offset<'m>(&mut self, offset: u64) {
        self.raw.offset = offset.into();
    }

    pub fn set_size<'m>(&mut self, size: u64) {
        self.raw.size = size.into();
    }

    pub fn set_row_pitch<'m>(&mut self, row_pitch: u64) {
        self.raw.rowPitch = row_pitch.into();
    }

    pub fn set_array_pitch<'m>(&mut self, array_pitch: u64) {
        self.raw.arrayPitch = array_pitch.into();
    }

    pub fn set_depth_pitch<'m>(&mut self, depth_pitch: u64) {
        self.raw.depthPitch = depth_pitch.into();
    }

    pub fn as_raw(&self) -> &vks::VkSubresourceLayout {
        &self.raw
    }
}

impl From<SubresourceLayout> for vks::VkSubresourceLayout {
    fn from(f: SubresourceLayout) -> vks::VkSubresourceLayout {
        f.raw
    }
}


/// A builder for `VkSubresourceLayout`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SubresourceLayoutBuilder {
    raw: vks::VkSubresourceLayout,
}

impl SubresourceLayoutBuilder {
    pub fn new() -> SubresourceLayoutBuilder {
        SubresourceLayoutBuilder {
            raw: vks::VkSubresourceLayout::default(),
        }
    }

    pub fn offset<'m>(mut self, offset: u64) -> SubresourceLayoutBuilder {
        self.raw.offset = offset.into();
        self
    }

    pub fn size<'m>(mut self, size: u64) -> SubresourceLayoutBuilder {
        self.raw.size = size.into();
        self
    }

    pub fn row_pitch<'m>(mut self, row_pitch: u64) -> SubresourceLayoutBuilder {
        self.raw.rowPitch = row_pitch.into();
        self
    }

    pub fn array_pitch<'m>(mut self, array_pitch: u64) -> SubresourceLayoutBuilder {
        self.raw.arrayPitch = array_pitch.into();
        self
    }

    pub fn depth_pitch<'m>(mut self, depth_pitch: u64) -> SubresourceLayoutBuilder {
        self.raw.depthPitch = depth_pitch.into();
        self
    }

    pub fn get_offset<'a>(&'a self) -> u64 {
        self.raw.offset.into()
    }

    pub fn get_size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn get_row_pitch<'a>(&'a self) -> u64 {
        self.raw.rowPitch.into()
    }

    pub fn get_array_pitch<'a>(&'a self) -> u64 {
        self.raw.arrayPitch.into()
    }

    pub fn get_depth_pitch<'a>(&'a self) -> u64 {
        self.raw.depthPitch.into()
    }

    pub fn build(self) -> SubresourceLayout {
        SubresourceLayout {
            raw: self.raw,
        }
    }
}


/// A `VkImageViewCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageViewCreateInfo<'s> {
    raw: vks::VkImageViewCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImageViewCreateInfo<'s> {
    pub fn builder<'b>() -> ImageViewCreateInfoBuilder<'b> {
        ImageViewCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageViewCreateInfo) -> ImageViewCreateInfo<'s> {
        ImageViewCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> ImageViewCreateFlags {
        ImageViewCreateFlags::from_bits(self.raw.flags)
            .expect("ImageViewCreateInfo::flags: error converting flags")
    }

    pub fn image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn view_type<'a>(&'a self) -> ImageViewType {
        self.raw.viewType.into()
    }

    pub fn format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn components<'a>(&'a self) -> &'a ComponentMapping {
        unsafe { &*(&self.raw.components as *const vks::VkComponentMapping as *const ComponentMapping) }
    }

    pub fn components_mut<'a>(&'a mut self) -> &'a mut ComponentMapping {
        unsafe { &mut *(&mut self.raw.components as *mut  vks::VkComponentMapping as *mut ComponentMapping) }
    }

    pub fn subresource_range<'a>(&'a self) -> &'a ImageSubresourceRange {
        unsafe { &*(&self.raw.subresourceRange as *const vks::VkImageSubresourceRange as *const ImageSubresourceRange) }
    }

    pub fn subresource_range_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceRange {
        unsafe { &mut *(&mut self.raw.subresourceRange as *mut  vks::VkImageSubresourceRange as *mut ImageSubresourceRange) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: ImageViewCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_image<'m, H>(&mut self, image: H)
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
    }

    pub fn set_view_type<'m>(&mut self, view_type: ImageViewType) {
        self.raw.viewType = view_type.into();
    }

    pub fn set_format<'m>(&mut self, format: Format) {
        self.raw.format = format.into();
    }

    pub fn set_components<'m>(&mut self, components: ComponentMapping) {
        self.raw.components = components.raw;
    }

    pub fn set_subresource_range<'m>(&mut self, subresource_range: ImageSubresourceRange) {
        self.raw.subresourceRange = subresource_range.raw;
    }

    pub fn as_raw(&self) -> &vks::VkImageViewCreateInfo {
        &self.raw
    }
}

impl<'s> From<ImageViewCreateInfo<'s>> for vks::VkImageViewCreateInfo {
    fn from(f: ImageViewCreateInfo<'s>) -> vks::VkImageViewCreateInfo {
        f.raw
    }
}


/// A builder for `VkImageViewCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageViewCreateInfoBuilder<'b> {
    raw: vks::VkImageViewCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ImageViewCreateInfoBuilder<'b> {
    pub fn new() -> ImageViewCreateInfoBuilder<'b> {
        ImageViewCreateInfoBuilder {
            raw: vks::VkImageViewCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImageViewCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: ImageViewCreateFlags) -> ImageViewCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn image<'m, H>(mut self, image: H) -> ImageViewCreateInfoBuilder<'b>
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
        self
    }

    pub fn view_type<'m>(mut self, view_type: ImageViewType) -> ImageViewCreateInfoBuilder<'b> {
        self.raw.viewType = view_type.into();
        self
    }

    pub fn format<'m>(mut self, format: Format) -> ImageViewCreateInfoBuilder<'b> {
        self.raw.format = format.into();
        self
    }

    pub fn components<'m>(mut self, components: ComponentMapping) -> ImageViewCreateInfoBuilder<'b> {
        self.raw.components = components.raw;
        self
    }

    pub fn subresource_range<'m>(mut self, subresource_range: ImageSubresourceRange) -> ImageViewCreateInfoBuilder<'b> {
        self.raw.subresourceRange = subresource_range.raw;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> ImageViewCreateFlags {
        ImageViewCreateFlags::from_bits(self.raw.flags)
            .expect("ImageViewCreateInfo::flags: error converting flags")
    }

    pub fn get_image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn get_view_type<'a>(&'a self) -> ImageViewType {
        self.raw.viewType.into()
    }

    pub fn get_format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn get_components<'a>(&'a self) -> &'a ComponentMapping {
        unsafe { &*(&self.raw.components as *const vks::VkComponentMapping as *const ComponentMapping) }
    }

    pub fn get_components_mut<'a>(&'a mut self) -> &'a mut ComponentMapping {
        unsafe { &mut *(&mut self.raw.components as *mut  vks::VkComponentMapping as *mut ComponentMapping) }
    }

    pub fn get_subresource_range<'a>(&'a self) -> &'a ImageSubresourceRange {
        unsafe { &*(&self.raw.subresourceRange as *const vks::VkImageSubresourceRange as *const ImageSubresourceRange) }
    }

    pub fn get_subresource_range_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceRange {
        unsafe { &mut *(&mut self.raw.subresourceRange as *mut  vks::VkImageSubresourceRange as *mut ImageSubresourceRange) }
    }

    pub fn build(self) -> ImageViewCreateInfo<'b> {
        ImageViewCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkBufferCopy`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct BufferCopy {
    raw: vks::VkBufferCopy,
}

impl BufferCopy {
    pub fn builder() -> BufferCopyBuilder {
        BufferCopyBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkBufferCopy) -> BufferCopy {
        BufferCopy { raw, }
    }

    pub fn src_offset<'a>(&'a self) -> u64 {
        self.raw.srcOffset.into()
    }

    pub fn dst_offset<'a>(&'a self) -> u64 {
        self.raw.dstOffset.into()
    }

    pub fn size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn set_src_offset<'m>(&mut self, src_offset: u64) {
        self.raw.srcOffset = src_offset.into();
    }

    pub fn set_dst_offset<'m>(&mut self, dst_offset: u64) {
        self.raw.dstOffset = dst_offset.into();
    }

    pub fn set_size<'m>(&mut self, size: u64) {
        self.raw.size = size.into();
    }

    pub fn as_raw(&self) -> &vks::VkBufferCopy {
        &self.raw
    }
}

impl From<BufferCopy> for vks::VkBufferCopy {
    fn from(f: BufferCopy) -> vks::VkBufferCopy {
        f.raw
    }
}


/// A builder for `VkBufferCopy`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct BufferCopyBuilder {
    raw: vks::VkBufferCopy,
}

impl BufferCopyBuilder {
    pub fn new() -> BufferCopyBuilder {
        BufferCopyBuilder {
            raw: vks::VkBufferCopy::default(),
        }
    }

    pub fn src_offset<'m>(mut self, src_offset: u64) -> BufferCopyBuilder {
        self.raw.srcOffset = src_offset.into();
        self
    }

    pub fn dst_offset<'m>(mut self, dst_offset: u64) -> BufferCopyBuilder {
        self.raw.dstOffset = dst_offset.into();
        self
    }

    pub fn size<'m>(mut self, size: u64) -> BufferCopyBuilder {
        self.raw.size = size.into();
        self
    }

    pub fn get_src_offset<'a>(&'a self) -> u64 {
        self.raw.srcOffset.into()
    }

    pub fn get_dst_offset<'a>(&'a self) -> u64 {
        self.raw.dstOffset.into()
    }

    pub fn get_size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn build(self) -> BufferCopy {
        BufferCopy {
            raw: self.raw,
        }
    }
}


/// A `VkSparseMemoryBind`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SparseMemoryBind {
    raw: vks::VkSparseMemoryBind,
}

impl SparseMemoryBind {
    pub fn builder() -> SparseMemoryBindBuilder {
        SparseMemoryBindBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSparseMemoryBind) -> SparseMemoryBind {
        SparseMemoryBind { raw, }
    }

    pub fn resource_offset<'a>(&'a self) -> u64 {
        self.raw.resourceOffset.into()
    }

    pub fn size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn memory<'a>(&'a self) -> vks::VkDeviceMemory {
        self.raw.memory
    }

    pub fn memory_offset<'a>(&'a self) -> u64 {
        self.raw.memoryOffset.into()
    }

    pub fn flags<'a>(&'a self) -> SparseMemoryBindFlags {
        SparseMemoryBindFlags::from_bits(self.raw.flags)
            .expect("SparseMemoryBind::flags: error converting flags")
    }

    pub fn set_resource_offset<'m>(&mut self, resource_offset: u64) {
        self.raw.resourceOffset = resource_offset.into();
    }

    pub fn set_size<'m>(&mut self, size: u64) {
        self.raw.size = size.into();
    }

    pub fn set_memory<'m, H>(&mut self, memory: H)
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
    }

    pub fn set_memory_offset<'m>(&mut self, memory_offset: u64) {
        self.raw.memoryOffset = memory_offset.into();
    }

    pub fn set_flags<'m>(&mut self, flags: SparseMemoryBindFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSparseMemoryBind {
        &self.raw
    }
}

impl From<SparseMemoryBind> for vks::VkSparseMemoryBind {
    fn from(f: SparseMemoryBind) -> vks::VkSparseMemoryBind {
        f.raw
    }
}


/// A builder for `VkSparseMemoryBind`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SparseMemoryBindBuilder {
    raw: vks::VkSparseMemoryBind,
}

impl SparseMemoryBindBuilder {
    pub fn new() -> SparseMemoryBindBuilder {
        SparseMemoryBindBuilder {
            raw: vks::VkSparseMemoryBind::default(),
        }
    }

    pub fn resource_offset<'m>(mut self, resource_offset: u64) -> SparseMemoryBindBuilder {
        self.raw.resourceOffset = resource_offset.into();
        self
    }

    pub fn size<'m>(mut self, size: u64) -> SparseMemoryBindBuilder {
        self.raw.size = size.into();
        self
    }

    pub fn memory<'m, H>(mut self, memory: H) -> SparseMemoryBindBuilder
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
        self
    }

    pub fn memory_offset<'m>(mut self, memory_offset: u64) -> SparseMemoryBindBuilder {
        self.raw.memoryOffset = memory_offset.into();
        self
    }

    pub fn flags<'m>(mut self, flags: SparseMemoryBindFlags) -> SparseMemoryBindBuilder {
        self.raw.flags = flags.bits();
        self
    }

    pub fn get_resource_offset<'a>(&'a self) -> u64 {
        self.raw.resourceOffset.into()
    }

    pub fn get_size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn get_memory<'a>(&'a self) -> vks::VkDeviceMemory {
        self.raw.memory
    }

    pub fn get_memory_offset<'a>(&'a self) -> u64 {
        self.raw.memoryOffset.into()
    }

    pub fn get_flags<'a>(&'a self) -> SparseMemoryBindFlags {
        SparseMemoryBindFlags::from_bits(self.raw.flags)
            .expect("SparseMemoryBind::flags: error converting flags")
    }

    pub fn build(self) -> SparseMemoryBind {
        SparseMemoryBind {
            raw: self.raw,
        }
    }
}


/// A `VkSparseImageMemoryBind`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SparseImageMemoryBind {
    raw: vks::VkSparseImageMemoryBind,
}

impl SparseImageMemoryBind {
    pub fn builder() -> SparseImageMemoryBindBuilder {
        SparseImageMemoryBindBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSparseImageMemoryBind) -> SparseImageMemoryBind {
        SparseImageMemoryBind { raw, }
    }

    pub fn subresource<'a>(&'a self) -> &'a ImageSubresource {
        unsafe { &*(&self.raw.subresource as *const vks::VkImageSubresource as *const ImageSubresource) }
    }

    pub fn subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresource {
        unsafe { &mut *(&mut self.raw.subresource as *mut  vks::VkImageSubresource as *mut ImageSubresource) }
    }

    pub fn offset<'a>(&'a self) -> &'a Offset3d {
        unsafe { &*(&self.raw.offset as *const vks::VkOffset3D as *const Offset3d) }
    }

    pub fn offset_mut<'a>(&'a mut self) -> &'a mut Offset3d {
        unsafe { &mut *(&mut self.raw.offset as *mut  vks::VkOffset3D as *mut Offset3d) }
    }

    pub fn extent<'a>(&'a self) -> &'a Extent3d {
        unsafe { &*(&self.raw.extent as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn extent_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn memory<'a>(&'a self) -> vks::VkDeviceMemory {
        self.raw.memory
    }

    pub fn memory_offset<'a>(&'a self) -> u64 {
        self.raw.memoryOffset.into()
    }

    pub fn flags<'a>(&'a self) -> SparseMemoryBindFlags {
        SparseMemoryBindFlags::from_bits(self.raw.flags)
            .expect("SparseImageMemoryBind::flags: error converting flags")
    }

    pub fn set_subresource<'m>(&mut self, subresource: ImageSubresource) {
        self.raw.subresource = subresource.raw;
    }

    pub fn set_offset<'m>(&mut self, offset: Offset3d) {
        self.raw.offset = offset.raw;
    }

    pub fn set_extent<'m>(&mut self, extent: Extent3d) {
        self.raw.extent = extent.raw;
    }

    pub fn set_memory<'m, H>(&mut self, memory: H)
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
    }

    pub fn set_memory_offset<'m>(&mut self, memory_offset: u64) {
        self.raw.memoryOffset = memory_offset.into();
    }

    pub fn set_flags<'m>(&mut self, flags: SparseMemoryBindFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSparseImageMemoryBind {
        &self.raw
    }
}

impl From<SparseImageMemoryBind> for vks::VkSparseImageMemoryBind {
    fn from(f: SparseImageMemoryBind) -> vks::VkSparseImageMemoryBind {
        f.raw
    }
}


/// A builder for `VkSparseImageMemoryBind`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SparseImageMemoryBindBuilder {
    raw: vks::VkSparseImageMemoryBind,
}

impl SparseImageMemoryBindBuilder {
    pub fn new() -> SparseImageMemoryBindBuilder {
        SparseImageMemoryBindBuilder {
            raw: vks::VkSparseImageMemoryBind::default(),
        }
    }

    pub fn subresource<'m>(mut self, subresource: ImageSubresource) -> SparseImageMemoryBindBuilder {
        self.raw.subresource = subresource.raw;
        self
    }

    pub fn offset<'m>(mut self, offset: Offset3d) -> SparseImageMemoryBindBuilder {
        self.raw.offset = offset.raw;
        self
    }

    pub fn extent<'m>(mut self, extent: Extent3d) -> SparseImageMemoryBindBuilder {
        self.raw.extent = extent.raw;
        self
    }

    pub fn memory<'m, H>(mut self, memory: H) -> SparseImageMemoryBindBuilder
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
        self
    }

    pub fn memory_offset<'m>(mut self, memory_offset: u64) -> SparseImageMemoryBindBuilder {
        self.raw.memoryOffset = memory_offset.into();
        self
    }

    pub fn flags<'m>(mut self, flags: SparseMemoryBindFlags) -> SparseImageMemoryBindBuilder {
        self.raw.flags = flags.bits();
        self
    }

    pub fn get_subresource<'a>(&'a self) -> &'a ImageSubresource {
        unsafe { &*(&self.raw.subresource as *const vks::VkImageSubresource as *const ImageSubresource) }
    }

    pub fn get_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresource {
        unsafe { &mut *(&mut self.raw.subresource as *mut  vks::VkImageSubresource as *mut ImageSubresource) }
    }

    pub fn get_offset<'a>(&'a self) -> &'a Offset3d {
        unsafe { &*(&self.raw.offset as *const vks::VkOffset3D as *const Offset3d) }
    }

    pub fn get_offset_mut<'a>(&'a mut self) -> &'a mut Offset3d {
        unsafe { &mut *(&mut self.raw.offset as *mut  vks::VkOffset3D as *mut Offset3d) }
    }

    pub fn get_extent<'a>(&'a self) -> &'a Extent3d {
        unsafe { &*(&self.raw.extent as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn get_extent_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn get_memory<'a>(&'a self) -> vks::VkDeviceMemory {
        self.raw.memory
    }

    pub fn get_memory_offset<'a>(&'a self) -> u64 {
        self.raw.memoryOffset.into()
    }

    pub fn get_flags<'a>(&'a self) -> SparseMemoryBindFlags {
        SparseMemoryBindFlags::from_bits(self.raw.flags)
            .expect("SparseImageMemoryBind::flags: error converting flags")
    }

    pub fn build(self) -> SparseImageMemoryBind {
        SparseImageMemoryBind {
            raw: self.raw,
        }
    }
}


/// A `VkSparseBufferMemoryBindInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SparseBufferMemoryBindInfo<'s> {
    raw: vks::VkSparseBufferMemoryBindInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> SparseBufferMemoryBindInfo<'s> {
    pub fn builder<'b>() -> SparseBufferMemoryBindInfoBuilder<'b> {
        SparseBufferMemoryBindInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSparseBufferMemoryBindInfo) -> SparseBufferMemoryBindInfo<'s> {
        SparseBufferMemoryBindInfo { raw, _p: PhantomData }
    }

    pub fn buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn binds<'a>(&'a self) -> &'a [SparseMemoryBind] {
        unsafe { slice::from_raw_parts(self.raw.pBinds as *const _, self.raw.bindCount as usize) }
    }

    pub fn set_buffer<'m, H>(&mut self, buffer: H)
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
    }

    pub fn set_binds<'m, 'a>(&mut self, binds: &'a [SparseMemoryBind])
            where 'a: 's {
        assert!(self.raw.bindCount == 0 || self.raw.bindCount == binds.len() as _, 
            "count inconsistency found when specifying `SparseBufferMemoryBindInfo::binds`.");
        self.raw.bindCount = binds.len() as _;
        self.raw.pBinds = binds.as_ptr() as *const vks::VkSparseMemoryBind;
    }

    pub fn as_raw(&self) -> &vks::VkSparseBufferMemoryBindInfo {
        &self.raw
    }
}

impl<'s> From<SparseBufferMemoryBindInfo<'s>> for vks::VkSparseBufferMemoryBindInfo {
    fn from(f: SparseBufferMemoryBindInfo<'s>) -> vks::VkSparseBufferMemoryBindInfo {
        f.raw
    }
}


/// A builder for `VkSparseBufferMemoryBindInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SparseBufferMemoryBindInfoBuilder<'b> {
    raw: vks::VkSparseBufferMemoryBindInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SparseBufferMemoryBindInfoBuilder<'b> {
    pub fn new() -> SparseBufferMemoryBindInfoBuilder<'b> {
        SparseBufferMemoryBindInfoBuilder {
            raw: vks::VkSparseBufferMemoryBindInfo::default(),
            _p: PhantomData,
        }
    }

    pub fn buffer<'m, H>(mut self, buffer: H) -> SparseBufferMemoryBindInfoBuilder<'b>
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
        self
    }

    pub fn binds<'m, 'a>(mut self, binds: &'a [SparseMemoryBind]) -> SparseBufferMemoryBindInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.bindCount == 0 || self.raw.bindCount == binds.len() as _, 
            "count inconsistency found when specifying `SparseBufferMemoryBindInfo::binds`.");
        self.raw.bindCount = binds.len() as _;
        self.raw.pBinds = binds.as_ptr() as *const vks::VkSparseMemoryBind;
        self
    }

    pub fn get_buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn get_binds<'a>(&'a self) -> &'a [SparseMemoryBind] {
        unsafe { slice::from_raw_parts(self.raw.pBinds as *const _, self.raw.bindCount as usize) }
    }

    pub fn build(self) -> SparseBufferMemoryBindInfo<'b> {
        SparseBufferMemoryBindInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSparseImageOpaqueMemoryBindInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SparseImageOpaqueMemoryBindInfo<'s> {
    raw: vks::VkSparseImageOpaqueMemoryBindInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> SparseImageOpaqueMemoryBindInfo<'s> {
    pub fn builder<'b>() -> SparseImageOpaqueMemoryBindInfoBuilder<'b> {
        SparseImageOpaqueMemoryBindInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSparseImageOpaqueMemoryBindInfo) -> SparseImageOpaqueMemoryBindInfo<'s> {
        SparseImageOpaqueMemoryBindInfo { raw, _p: PhantomData }
    }

    pub fn image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn binds<'a>(&'a self) -> &'a [SparseMemoryBind] {
        unsafe { slice::from_raw_parts(self.raw.pBinds as *const _, self.raw.bindCount as usize) }
    }

    pub fn set_image<'m, H>(&mut self, image: H)
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
    }

    pub fn set_binds<'m, 'a>(&mut self, binds: &'a [SparseMemoryBind])
            where 'a: 's {
        assert!(self.raw.bindCount == 0 || self.raw.bindCount == binds.len() as _, 
            "count inconsistency found when specifying `SparseImageOpaqueMemoryBindInfo::binds`.");
        self.raw.bindCount = binds.len() as _;
        self.raw.pBinds = binds.as_ptr() as *const vks::VkSparseMemoryBind;
    }

    pub fn as_raw(&self) -> &vks::VkSparseImageOpaqueMemoryBindInfo {
        &self.raw
    }
}

impl<'s> From<SparseImageOpaqueMemoryBindInfo<'s>> for vks::VkSparseImageOpaqueMemoryBindInfo {
    fn from(f: SparseImageOpaqueMemoryBindInfo<'s>) -> vks::VkSparseImageOpaqueMemoryBindInfo {
        f.raw
    }
}


/// A builder for `VkSparseImageOpaqueMemoryBindInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SparseImageOpaqueMemoryBindInfoBuilder<'b> {
    raw: vks::VkSparseImageOpaqueMemoryBindInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SparseImageOpaqueMemoryBindInfoBuilder<'b> {
    pub fn new() -> SparseImageOpaqueMemoryBindInfoBuilder<'b> {
        SparseImageOpaqueMemoryBindInfoBuilder {
            raw: vks::VkSparseImageOpaqueMemoryBindInfo::default(),
            _p: PhantomData,
        }
    }

    pub fn image<'m, H>(mut self, image: H) -> SparseImageOpaqueMemoryBindInfoBuilder<'b>
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
        self
    }

    pub fn binds<'m, 'a>(mut self, binds: &'a [SparseMemoryBind]) -> SparseImageOpaqueMemoryBindInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.bindCount == 0 || self.raw.bindCount == binds.len() as _, 
            "count inconsistency found when specifying `SparseImageOpaqueMemoryBindInfo::binds`.");
        self.raw.bindCount = binds.len() as _;
        self.raw.pBinds = binds.as_ptr() as *const vks::VkSparseMemoryBind;
        self
    }

    pub fn get_image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn get_binds<'a>(&'a self) -> &'a [SparseMemoryBind] {
        unsafe { slice::from_raw_parts(self.raw.pBinds as *const _, self.raw.bindCount as usize) }
    }

    pub fn build(self) -> SparseImageOpaqueMemoryBindInfo<'b> {
        SparseImageOpaqueMemoryBindInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSparseImageMemoryBindInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SparseImageMemoryBindInfo<'s> {
    raw: vks::VkSparseImageMemoryBindInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> SparseImageMemoryBindInfo<'s> {
    pub fn builder<'b>() -> SparseImageMemoryBindInfoBuilder<'b> {
        SparseImageMemoryBindInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSparseImageMemoryBindInfo) -> SparseImageMemoryBindInfo<'s> {
        SparseImageMemoryBindInfo { raw, _p: PhantomData }
    }

    pub fn image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn binds<'a>(&'a self) -> &'a [SparseImageMemoryBind] {
        unsafe { slice::from_raw_parts(self.raw.pBinds as *const _, self.raw.bindCount as usize) }
    }

    pub fn set_image<'m, H>(&mut self, image: H)
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
    }

    pub fn set_binds<'m, 'a>(&mut self, binds: &'a [SparseImageMemoryBind])
            where 'a: 's {
        assert!(self.raw.bindCount == 0 || self.raw.bindCount == binds.len() as _, 
            "count inconsistency found when specifying `SparseImageMemoryBindInfo::binds`.");
        self.raw.bindCount = binds.len() as _;
        self.raw.pBinds = binds.as_ptr() as *const vks::VkSparseImageMemoryBind;
    }

    pub fn as_raw(&self) -> &vks::VkSparseImageMemoryBindInfo {
        &self.raw
    }
}

impl<'s> From<SparseImageMemoryBindInfo<'s>> for vks::VkSparseImageMemoryBindInfo {
    fn from(f: SparseImageMemoryBindInfo<'s>) -> vks::VkSparseImageMemoryBindInfo {
        f.raw
    }
}


/// A builder for `VkSparseImageMemoryBindInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SparseImageMemoryBindInfoBuilder<'b> {
    raw: vks::VkSparseImageMemoryBindInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SparseImageMemoryBindInfoBuilder<'b> {
    pub fn new() -> SparseImageMemoryBindInfoBuilder<'b> {
        SparseImageMemoryBindInfoBuilder {
            raw: vks::VkSparseImageMemoryBindInfo::default(),
            _p: PhantomData,
        }
    }

    pub fn image<'m, H>(mut self, image: H) -> SparseImageMemoryBindInfoBuilder<'b>
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
        self
    }

    pub fn binds<'m, 'a>(mut self, binds: &'a [SparseImageMemoryBind]) -> SparseImageMemoryBindInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.bindCount == 0 || self.raw.bindCount == binds.len() as _, 
            "count inconsistency found when specifying `SparseImageMemoryBindInfo::binds`.");
        self.raw.bindCount = binds.len() as _;
        self.raw.pBinds = binds.as_ptr() as *const vks::VkSparseImageMemoryBind;
        self
    }

    pub fn get_image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn get_binds<'a>(&'a self) -> &'a [SparseImageMemoryBind] {
        unsafe { slice::from_raw_parts(self.raw.pBinds as *const _, self.raw.bindCount as usize) }
    }

    pub fn build(self) -> SparseImageMemoryBindInfo<'b> {
        SparseImageMemoryBindInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkBindSparseInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct BindSparseInfo<'s> {
    raw: vks::VkBindSparseInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> BindSparseInfo<'s> {
    pub fn builder<'b>() -> BindSparseInfoBuilder<'b> {
        BindSparseInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkBindSparseInfo) -> BindSparseInfo<'s> {
        BindSparseInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn wait_semaphores<'a>(&'a self) -> &'a [vks::VkSemaphore] {
        unsafe { slice::from_raw_parts(self.raw.pWaitSemaphores as *const _, self.raw.waitSemaphoreCount as usize) }
    }

    pub fn buffer_binds<'a>(&'a self) -> &'a [SparseBufferMemoryBindInfo] {
        unsafe { slice::from_raw_parts(self.raw.pBufferBinds as *const _, self.raw.bufferBindCount as usize) }
    }

    pub fn image_opaque_binds<'a>(&'a self) -> &'a [SparseImageOpaqueMemoryBindInfo] {
        unsafe { slice::from_raw_parts(self.raw.pImageOpaqueBinds as *const _, self.raw.imageOpaqueBindCount as usize) }
    }

    pub fn image_binds<'a>(&'a self) -> &'a [SparseImageMemoryBindInfo] {
        unsafe { slice::from_raw_parts(self.raw.pImageBinds as *const _, self.raw.imageBindCount as usize) }
    }

    pub fn signal_semaphores<'a>(&'a self) -> &'a [vks::VkSemaphore] {
        unsafe { slice::from_raw_parts(self.raw.pSignalSemaphores as *const _, self.raw.signalSemaphoreCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_wait_semaphores<'m, 'a>(&mut self, wait_semaphores: &'a [SemaphoreHandle])
            where 'a: 's {
        assert!(self.raw.waitSemaphoreCount == 0 || self.raw.waitSemaphoreCount == wait_semaphores.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::wait_semaphores`.");
        self.raw.waitSemaphoreCount = wait_semaphores.len() as _;
        self.raw.pWaitSemaphores = wait_semaphores.as_ptr() as *const vks::VkSemaphore;
    }

    pub fn set_buffer_binds<'m, 'a>(&mut self, buffer_binds: &'a [SparseBufferMemoryBindInfo])
            where 'a: 's {
        assert!(self.raw.bufferBindCount == 0 || self.raw.bufferBindCount == buffer_binds.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::buffer_binds`.");
        self.raw.bufferBindCount = buffer_binds.len() as _;
        self.raw.pBufferBinds = buffer_binds.as_ptr() as *const vks::VkSparseBufferMemoryBindInfo;
    }

    pub fn set_image_opaque_binds<'m, 'a>(&mut self, image_opaque_binds: &'a [SparseImageOpaqueMemoryBindInfo])
            where 'a: 's {
        assert!(self.raw.imageOpaqueBindCount == 0 || self.raw.imageOpaqueBindCount == image_opaque_binds.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::image_opaque_binds`.");
        self.raw.imageOpaqueBindCount = image_opaque_binds.len() as _;
        self.raw.pImageOpaqueBinds = image_opaque_binds.as_ptr() as *const vks::VkSparseImageOpaqueMemoryBindInfo;
    }

    pub fn set_image_binds<'m, 'a>(&mut self, image_binds: &'a [SparseImageMemoryBindInfo])
            where 'a: 's {
        assert!(self.raw.imageBindCount == 0 || self.raw.imageBindCount == image_binds.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::image_binds`.");
        self.raw.imageBindCount = image_binds.len() as _;
        self.raw.pImageBinds = image_binds.as_ptr() as *const vks::VkSparseImageMemoryBindInfo;
    }

    pub fn set_signal_semaphores<'m, 'a>(&mut self, signal_semaphores: &'a [SemaphoreHandle])
            where 'a: 's {
        assert!(self.raw.signalSemaphoreCount == 0 || self.raw.signalSemaphoreCount == signal_semaphores.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::signal_semaphores`.");
        self.raw.signalSemaphoreCount = signal_semaphores.len() as _;
        self.raw.pSignalSemaphores = signal_semaphores.as_ptr() as *const vks::VkSemaphore;
    }

    pub fn as_raw(&self) -> &vks::VkBindSparseInfo {
        &self.raw
    }
}

impl<'s> From<BindSparseInfo<'s>> for vks::VkBindSparseInfo {
    fn from(f: BindSparseInfo<'s>) -> vks::VkBindSparseInfo {
        f.raw
    }
}


/// A builder for `VkBindSparseInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct BindSparseInfoBuilder<'b> {
    raw: vks::VkBindSparseInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> BindSparseInfoBuilder<'b> {
    pub fn new() -> BindSparseInfoBuilder<'b> {
        BindSparseInfoBuilder {
            raw: vks::VkBindSparseInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> BindSparseInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn wait_semaphores<'m, 'a>(mut self, wait_semaphores: &'a [SemaphoreHandle]) -> BindSparseInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.waitSemaphoreCount == 0 || self.raw.waitSemaphoreCount == wait_semaphores.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::wait_semaphores`.");
        self.raw.waitSemaphoreCount = wait_semaphores.len() as _;
        self.raw.pWaitSemaphores = wait_semaphores.as_ptr() as *const vks::VkSemaphore;
        self
    }

    pub fn buffer_binds<'m, 'a>(mut self, buffer_binds: &'a [SparseBufferMemoryBindInfo]) -> BindSparseInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.bufferBindCount == 0 || self.raw.bufferBindCount == buffer_binds.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::buffer_binds`.");
        self.raw.bufferBindCount = buffer_binds.len() as _;
        self.raw.pBufferBinds = buffer_binds.as_ptr() as *const vks::VkSparseBufferMemoryBindInfo;
        self
    }

    pub fn image_opaque_binds<'m, 'a>(mut self, image_opaque_binds: &'a [SparseImageOpaqueMemoryBindInfo]) -> BindSparseInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.imageOpaqueBindCount == 0 || self.raw.imageOpaqueBindCount == image_opaque_binds.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::image_opaque_binds`.");
        self.raw.imageOpaqueBindCount = image_opaque_binds.len() as _;
        self.raw.pImageOpaqueBinds = image_opaque_binds.as_ptr() as *const vks::VkSparseImageOpaqueMemoryBindInfo;
        self
    }

    pub fn image_binds<'m, 'a>(mut self, image_binds: &'a [SparseImageMemoryBindInfo]) -> BindSparseInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.imageBindCount == 0 || self.raw.imageBindCount == image_binds.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::image_binds`.");
        self.raw.imageBindCount = image_binds.len() as _;
        self.raw.pImageBinds = image_binds.as_ptr() as *const vks::VkSparseImageMemoryBindInfo;
        self
    }

    pub fn signal_semaphores<'m, 'a>(mut self, signal_semaphores: &'a [SemaphoreHandle]) -> BindSparseInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.signalSemaphoreCount == 0 || self.raw.signalSemaphoreCount == signal_semaphores.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::signal_semaphores`.");
        self.raw.signalSemaphoreCount = signal_semaphores.len() as _;
        self.raw.pSignalSemaphores = signal_semaphores.as_ptr() as *const vks::VkSemaphore;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_wait_semaphores<'a>(&'a self) -> &'a [vks::VkSemaphore] {
        unsafe { slice::from_raw_parts(self.raw.pWaitSemaphores as *const _, self.raw.waitSemaphoreCount as usize) }
    }

    pub fn get_buffer_binds<'a>(&'a self) -> &'a [SparseBufferMemoryBindInfo] {
        unsafe { slice::from_raw_parts(self.raw.pBufferBinds as *const _, self.raw.bufferBindCount as usize) }
    }

    pub fn get_image_opaque_binds<'a>(&'a self) -> &'a [SparseImageOpaqueMemoryBindInfo] {
        unsafe { slice::from_raw_parts(self.raw.pImageOpaqueBinds as *const _, self.raw.imageOpaqueBindCount as usize) }
    }

    pub fn get_image_binds<'a>(&'a self) -> &'a [SparseImageMemoryBindInfo] {
        unsafe { slice::from_raw_parts(self.raw.pImageBinds as *const _, self.raw.imageBindCount as usize) }
    }

    pub fn get_signal_semaphores<'a>(&'a self) -> &'a [vks::VkSemaphore] {
        unsafe { slice::from_raw_parts(self.raw.pSignalSemaphores as *const _, self.raw.signalSemaphoreCount as usize) }
    }

    pub fn build(self) -> BindSparseInfo<'b> {
        BindSparseInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImageCopy`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageCopy {
    raw: vks::VkImageCopy,
}

impl ImageCopy {
    pub fn builder() -> ImageCopyBuilder {
        ImageCopyBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageCopy) -> ImageCopy {
        ImageCopy { raw, }
    }

    pub fn src_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
        unsafe { &*(&self.raw.srcSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn src_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.srcSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn src_offset<'a>(&'a self) -> &'a Offset3d {
        unsafe { &*(&self.raw.srcOffset as *const vks::VkOffset3D as *const Offset3d) }
    }

    pub fn src_offset_mut<'a>(&'a mut self) -> &'a mut Offset3d {
        unsafe { &mut *(&mut self.raw.srcOffset as *mut  vks::VkOffset3D as *mut Offset3d) }
    }

    pub fn dst_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
        unsafe { &*(&self.raw.dstSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn dst_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.dstSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn dst_offset<'a>(&'a self) -> &'a Offset3d {
        unsafe { &*(&self.raw.dstOffset as *const vks::VkOffset3D as *const Offset3d) }
    }

    pub fn dst_offset_mut<'a>(&'a mut self) -> &'a mut Offset3d {
        unsafe { &mut *(&mut self.raw.dstOffset as *mut  vks::VkOffset3D as *mut Offset3d) }
    }

    pub fn extent<'a>(&'a self) -> &'a Extent3d {
        unsafe { &*(&self.raw.extent as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn extent_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn set_src_subresource<'m>(&mut self, src_subresource: ImageSubresourceLayers) {
        self.raw.srcSubresource = src_subresource.raw;
    }

    pub fn set_src_offset<'m>(&mut self, src_offset: Offset3d) {
        self.raw.srcOffset = src_offset.raw;
    }

    pub fn set_dst_subresource<'m>(&mut self, dst_subresource: ImageSubresourceLayers) {
        self.raw.dstSubresource = dst_subresource.raw;
    }

    pub fn set_dst_offset<'m>(&mut self, dst_offset: Offset3d) {
        self.raw.dstOffset = dst_offset.raw;
    }

    pub fn set_extent<'m>(&mut self, extent: Extent3d) {
        self.raw.extent = extent.raw;
    }

    pub fn as_raw(&self) -> &vks::VkImageCopy {
        &self.raw
    }
}

impl From<ImageCopy> for vks::VkImageCopy {
    fn from(f: ImageCopy) -> vks::VkImageCopy {
        f.raw
    }
}


/// A builder for `VkImageCopy`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageCopyBuilder {
    raw: vks::VkImageCopy,
}

impl ImageCopyBuilder {
    pub fn new() -> ImageCopyBuilder {
        ImageCopyBuilder {
            raw: vks::VkImageCopy::default(),
        }
    }

    pub fn src_subresource<'m>(mut self, src_subresource: ImageSubresourceLayers) -> ImageCopyBuilder {
        self.raw.srcSubresource = src_subresource.raw;
        self
    }

    pub fn src_offset<'m>(mut self, src_offset: Offset3d) -> ImageCopyBuilder {
        self.raw.srcOffset = src_offset.raw;
        self
    }

    pub fn dst_subresource<'m>(mut self, dst_subresource: ImageSubresourceLayers) -> ImageCopyBuilder {
        self.raw.dstSubresource = dst_subresource.raw;
        self
    }

    pub fn dst_offset<'m>(mut self, dst_offset: Offset3d) -> ImageCopyBuilder {
        self.raw.dstOffset = dst_offset.raw;
        self
    }

    pub fn extent<'m>(mut self, extent: Extent3d) -> ImageCopyBuilder {
        self.raw.extent = extent.raw;
        self
    }

    pub fn get_src_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
        unsafe { &*(&self.raw.srcSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn get_src_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.srcSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn get_src_offset<'a>(&'a self) -> &'a Offset3d {
        unsafe { &*(&self.raw.srcOffset as *const vks::VkOffset3D as *const Offset3d) }
    }

    pub fn get_src_offset_mut<'a>(&'a mut self) -> &'a mut Offset3d {
        unsafe { &mut *(&mut self.raw.srcOffset as *mut  vks::VkOffset3D as *mut Offset3d) }
    }

    pub fn get_dst_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
        unsafe { &*(&self.raw.dstSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn get_dst_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.dstSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn get_dst_offset<'a>(&'a self) -> &'a Offset3d {
        unsafe { &*(&self.raw.dstOffset as *const vks::VkOffset3D as *const Offset3d) }
    }

    pub fn get_dst_offset_mut<'a>(&'a mut self) -> &'a mut Offset3d {
        unsafe { &mut *(&mut self.raw.dstOffset as *mut  vks::VkOffset3D as *mut Offset3d) }
    }

    pub fn get_extent<'a>(&'a self) -> &'a Extent3d {
        unsafe { &*(&self.raw.extent as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn get_extent_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn build(self) -> ImageCopy {
        ImageCopy {
            raw: self.raw,
        }
    }
}


/// A `VkImageBlit`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageBlit {
    raw: vks::VkImageBlit,
}

impl ImageBlit {
    pub fn builder() -> ImageBlitBuilder {
        ImageBlitBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageBlit) -> ImageBlit {
        ImageBlit { raw, }
    }

    pub fn src_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
        unsafe { &*(&self.raw.srcSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn src_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.srcSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn src_offsets<'a>(&'a self) -> &[Offset3d] {
        unsafe { slice::from_raw_parts(&self.raw.srcOffsets as *const vks::VkOffset3D as *const _, 2 as usize) }
    }

    pub fn dst_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
        unsafe { &*(&self.raw.dstSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn dst_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.dstSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn dst_offsets<'a>(&'a self) -> &[Offset3d] {
        unsafe { slice::from_raw_parts(&self.raw.dstOffsets as *const vks::VkOffset3D as *const _, 2 as usize) }
    }

    pub fn set_src_subresource<'m>(&mut self, src_subresource: ImageSubresourceLayers) {
        self.raw.srcSubresource = src_subresource.raw;
    }

    pub fn set_src_offsets<'m>(&mut self, src_offsets: [Offset3d; 2]) {
        self.raw.srcOffsets = [src_offsets[0].raw, src_offsets[1].raw, ];
    }

    pub fn set_dst_subresource<'m>(&mut self, dst_subresource: ImageSubresourceLayers) {
        self.raw.dstSubresource = dst_subresource.raw;
    }

    pub fn set_dst_offsets<'m>(&mut self, dst_offsets: [Offset3d; 2]) {
        self.raw.dstOffsets = [dst_offsets[0].raw, dst_offsets[1].raw, ];
    }

    pub fn as_raw(&self) -> &vks::VkImageBlit {
        &self.raw
    }
}

impl From<ImageBlit> for vks::VkImageBlit {
    fn from(f: ImageBlit) -> vks::VkImageBlit {
        f.raw
    }
}


/// A builder for `VkImageBlit`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageBlitBuilder {
    raw: vks::VkImageBlit,
}

impl ImageBlitBuilder {
    pub fn new() -> ImageBlitBuilder {
        ImageBlitBuilder {
            raw: vks::VkImageBlit::default(),
        }
    }

    pub fn src_subresource<'m>(mut self, src_subresource: ImageSubresourceLayers) -> ImageBlitBuilder {
        self.raw.srcSubresource = src_subresource.raw;
        self
    }

    pub fn src_offsets<'m>(mut self, src_offsets: [Offset3d; 2]) -> ImageBlitBuilder {
        self.raw.srcOffsets = [src_offsets[0].raw, src_offsets[1].raw, ];
        self
    }

    pub fn dst_subresource<'m>(mut self, dst_subresource: ImageSubresourceLayers) -> ImageBlitBuilder {
        self.raw.dstSubresource = dst_subresource.raw;
        self
    }

    pub fn dst_offsets<'m>(mut self, dst_offsets: [Offset3d; 2]) -> ImageBlitBuilder {
        self.raw.dstOffsets = [dst_offsets[0].raw, dst_offsets[1].raw, ];
        self
    }

    pub fn get_src_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
        unsafe { &*(&self.raw.srcSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn get_src_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.srcSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn get_src_offsets<'a>(&'a self) -> &[Offset3d] {
        unsafe { slice::from_raw_parts(&self.raw.srcOffsets as *const vks::VkOffset3D as *const _, 2 as usize) }
    }

    pub fn get_dst_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
        unsafe { &*(&self.raw.dstSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn get_dst_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.dstSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn get_dst_offsets<'a>(&'a self) -> &[Offset3d] {
        unsafe { slice::from_raw_parts(&self.raw.dstOffsets as *const vks::VkOffset3D as *const _, 2 as usize) }
    }

    pub fn build(self) -> ImageBlit {
        ImageBlit {
            raw: self.raw,
        }
    }
}


/// A `VkBufferImageCopy`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct BufferImageCopy {
    raw: vks::VkBufferImageCopy,
}

impl BufferImageCopy {
    pub fn builder() -> BufferImageCopyBuilder {
        BufferImageCopyBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkBufferImageCopy) -> BufferImageCopy {
        BufferImageCopy { raw, }
    }

    pub fn buffer_offset<'a>(&'a self) -> u64 {
        self.raw.bufferOffset.into()
    }

    pub fn buffer_row_length<'a>(&'a self) -> u32 {
        self.raw.bufferRowLength.into()
    }

    pub fn buffer_image_height<'a>(&'a self) -> u32 {
        self.raw.bufferImageHeight.into()
    }

    pub fn image_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
        unsafe { &*(&self.raw.imageSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn image_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.imageSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn image_offset<'a>(&'a self) -> &'a Offset3d {
        unsafe { &*(&self.raw.imageOffset as *const vks::VkOffset3D as *const Offset3d) }
    }

    pub fn image_offset_mut<'a>(&'a mut self) -> &'a mut Offset3d {
        unsafe { &mut *(&mut self.raw.imageOffset as *mut  vks::VkOffset3D as *mut Offset3d) }
    }

    pub fn image_extent<'a>(&'a self) -> &'a Extent3d {
        unsafe { &*(&self.raw.imageExtent as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn image_extent_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.imageExtent as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn set_buffer_offset<'m>(&mut self, buffer_offset: u64) {
        self.raw.bufferOffset = buffer_offset.into();
    }

    pub fn set_buffer_row_length<'m>(&mut self, buffer_row_length: u32) {
        self.raw.bufferRowLength = buffer_row_length.into();
    }

    pub fn set_buffer_image_height<'m>(&mut self, buffer_image_height: u32) {
        self.raw.bufferImageHeight = buffer_image_height.into();
    }

    pub fn set_image_subresource<'m>(&mut self, image_subresource: ImageSubresourceLayers) {
        self.raw.imageSubresource = image_subresource.raw;
    }

    pub fn set_image_offset<'m>(&mut self, image_offset: Offset3d) {
        self.raw.imageOffset = image_offset.raw;
    }

    pub fn set_image_extent<'m>(&mut self, image_extent: Extent3d) {
        self.raw.imageExtent = image_extent.raw;
    }

    pub fn as_raw(&self) -> &vks::VkBufferImageCopy {
        &self.raw
    }
}

impl From<BufferImageCopy> for vks::VkBufferImageCopy {
    fn from(f: BufferImageCopy) -> vks::VkBufferImageCopy {
        f.raw
    }
}


/// A builder for `VkBufferImageCopy`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct BufferImageCopyBuilder {
    raw: vks::VkBufferImageCopy,
}

impl BufferImageCopyBuilder {
    pub fn new() -> BufferImageCopyBuilder {
        BufferImageCopyBuilder {
            raw: vks::VkBufferImageCopy::default(),
        }
    }

    pub fn buffer_offset<'m>(mut self, buffer_offset: u64) -> BufferImageCopyBuilder {
        self.raw.bufferOffset = buffer_offset.into();
        self
    }

    pub fn buffer_row_length<'m>(mut self, buffer_row_length: u32) -> BufferImageCopyBuilder {
        self.raw.bufferRowLength = buffer_row_length.into();
        self
    }

    pub fn buffer_image_height<'m>(mut self, buffer_image_height: u32) -> BufferImageCopyBuilder {
        self.raw.bufferImageHeight = buffer_image_height.into();
        self
    }

    pub fn image_subresource<'m>(mut self, image_subresource: ImageSubresourceLayers) -> BufferImageCopyBuilder {
        self.raw.imageSubresource = image_subresource.raw;
        self
    }

    pub fn image_offset<'m>(mut self, image_offset: Offset3d) -> BufferImageCopyBuilder {
        self.raw.imageOffset = image_offset.raw;
        self
    }

    pub fn image_extent<'m>(mut self, image_extent: Extent3d) -> BufferImageCopyBuilder {
        self.raw.imageExtent = image_extent.raw;
        self
    }

    pub fn get_buffer_offset<'a>(&'a self) -> u64 {
        self.raw.bufferOffset.into()
    }

    pub fn get_buffer_row_length<'a>(&'a self) -> u32 {
        self.raw.bufferRowLength.into()
    }

    pub fn get_buffer_image_height<'a>(&'a self) -> u32 {
        self.raw.bufferImageHeight.into()
    }

    pub fn get_image_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
        unsafe { &*(&self.raw.imageSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn get_image_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.imageSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn get_image_offset<'a>(&'a self) -> &'a Offset3d {
        unsafe { &*(&self.raw.imageOffset as *const vks::VkOffset3D as *const Offset3d) }
    }

    pub fn get_image_offset_mut<'a>(&'a mut self) -> &'a mut Offset3d {
        unsafe { &mut *(&mut self.raw.imageOffset as *mut  vks::VkOffset3D as *mut Offset3d) }
    }

    pub fn get_image_extent<'a>(&'a self) -> &'a Extent3d {
        unsafe { &*(&self.raw.imageExtent as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn get_image_extent_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.imageExtent as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn build(self) -> BufferImageCopy {
        BufferImageCopy {
            raw: self.raw,
        }
    }
}


/// A `VkImageResolve`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageResolve {
    raw: vks::VkImageResolve,
}

impl ImageResolve {
    pub fn builder() -> ImageResolveBuilder {
        ImageResolveBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageResolve) -> ImageResolve {
        ImageResolve { raw, }
    }

    pub fn src_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
        unsafe { &*(&self.raw.srcSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn src_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.srcSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn src_offset<'a>(&'a self) -> &'a Offset3d {
        unsafe { &*(&self.raw.srcOffset as *const vks::VkOffset3D as *const Offset3d) }
    }

    pub fn src_offset_mut<'a>(&'a mut self) -> &'a mut Offset3d {
        unsafe { &mut *(&mut self.raw.srcOffset as *mut  vks::VkOffset3D as *mut Offset3d) }
    }

    pub fn dst_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
        unsafe { &*(&self.raw.dstSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn dst_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.dstSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn dst_offset<'a>(&'a self) -> &'a Offset3d {
        unsafe { &*(&self.raw.dstOffset as *const vks::VkOffset3D as *const Offset3d) }
    }

    pub fn dst_offset_mut<'a>(&'a mut self) -> &'a mut Offset3d {
        unsafe { &mut *(&mut self.raw.dstOffset as *mut  vks::VkOffset3D as *mut Offset3d) }
    }

    pub fn extent<'a>(&'a self) -> &'a Extent3d {
        unsafe { &*(&self.raw.extent as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn extent_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn set_src_subresource<'m>(&mut self, src_subresource: ImageSubresourceLayers) {
        self.raw.srcSubresource = src_subresource.raw;
    }

    pub fn set_src_offset<'m>(&mut self, src_offset: Offset3d) {
        self.raw.srcOffset = src_offset.raw;
    }

    pub fn set_dst_subresource<'m>(&mut self, dst_subresource: ImageSubresourceLayers) {
        self.raw.dstSubresource = dst_subresource.raw;
    }

    pub fn set_dst_offset<'m>(&mut self, dst_offset: Offset3d) {
        self.raw.dstOffset = dst_offset.raw;
    }

    pub fn set_extent<'m>(&mut self, extent: Extent3d) {
        self.raw.extent = extent.raw;
    }

    pub fn as_raw(&self) -> &vks::VkImageResolve {
        &self.raw
    }
}

impl From<ImageResolve> for vks::VkImageResolve {
    fn from(f: ImageResolve) -> vks::VkImageResolve {
        f.raw
    }
}


/// A builder for `VkImageResolve`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageResolveBuilder {
    raw: vks::VkImageResolve,
}

impl ImageResolveBuilder {
    pub fn new() -> ImageResolveBuilder {
        ImageResolveBuilder {
            raw: vks::VkImageResolve::default(),
        }
    }

    pub fn src_subresource<'m>(mut self, src_subresource: ImageSubresourceLayers) -> ImageResolveBuilder {
        self.raw.srcSubresource = src_subresource.raw;
        self
    }

    pub fn src_offset<'m>(mut self, src_offset: Offset3d) -> ImageResolveBuilder {
        self.raw.srcOffset = src_offset.raw;
        self
    }

    pub fn dst_subresource<'m>(mut self, dst_subresource: ImageSubresourceLayers) -> ImageResolveBuilder {
        self.raw.dstSubresource = dst_subresource.raw;
        self
    }

    pub fn dst_offset<'m>(mut self, dst_offset: Offset3d) -> ImageResolveBuilder {
        self.raw.dstOffset = dst_offset.raw;
        self
    }

    pub fn extent<'m>(mut self, extent: Extent3d) -> ImageResolveBuilder {
        self.raw.extent = extent.raw;
        self
    }

    pub fn get_src_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
        unsafe { &*(&self.raw.srcSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn get_src_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.srcSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn get_src_offset<'a>(&'a self) -> &'a Offset3d {
        unsafe { &*(&self.raw.srcOffset as *const vks::VkOffset3D as *const Offset3d) }
    }

    pub fn get_src_offset_mut<'a>(&'a mut self) -> &'a mut Offset3d {
        unsafe { &mut *(&mut self.raw.srcOffset as *mut  vks::VkOffset3D as *mut Offset3d) }
    }

    pub fn get_dst_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
        unsafe { &*(&self.raw.dstSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn get_dst_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.dstSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn get_dst_offset<'a>(&'a self) -> &'a Offset3d {
        unsafe { &*(&self.raw.dstOffset as *const vks::VkOffset3D as *const Offset3d) }
    }

    pub fn get_dst_offset_mut<'a>(&'a mut self) -> &'a mut Offset3d {
        unsafe { &mut *(&mut self.raw.dstOffset as *mut  vks::VkOffset3D as *mut Offset3d) }
    }

    pub fn get_extent<'a>(&'a self) -> &'a Extent3d {
        unsafe { &*(&self.raw.extent as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn get_extent_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn build(self) -> ImageResolve {
        ImageResolve {
            raw: self.raw,
        }
    }
}


/// A `VkShaderModuleCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ShaderModuleCreateInfo<'s> {
    raw: vks::VkShaderModuleCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> ShaderModuleCreateInfo<'s> {
    pub fn builder<'b>() -> ShaderModuleCreateInfoBuilder<'b> {
        ShaderModuleCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkShaderModuleCreateInfo) -> ShaderModuleCreateInfo<'s> {
        ShaderModuleCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> ShaderModuleCreateFlags {
        ShaderModuleCreateFlags::from_bits(self.raw.flags)
            .expect("ShaderModuleCreateInfo::flags: error converting flags")
    }

    pub fn code<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pCode as *const _, self.raw.codeSize as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: ShaderModuleCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_code<'m, 'a>(&mut self, code: &'a [u32])
            where 'a: 's {
        self.raw.codeSize = code.len() * 4;
        self.raw.pCode = code.as_ptr() as *const u32 as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkShaderModuleCreateInfo {
        &self.raw
    }
}

impl<'s> From<ShaderModuleCreateInfo<'s>> for vks::VkShaderModuleCreateInfo {
    fn from(f: ShaderModuleCreateInfo<'s>) -> vks::VkShaderModuleCreateInfo {
        f.raw
    }
}


/// A builder for `VkShaderModuleCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ShaderModuleCreateInfoBuilder<'b> {
    raw: vks::VkShaderModuleCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ShaderModuleCreateInfoBuilder<'b> {
    pub fn new() -> ShaderModuleCreateInfoBuilder<'b> {
        ShaderModuleCreateInfoBuilder {
            raw: vks::VkShaderModuleCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ShaderModuleCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: ShaderModuleCreateFlags) -> ShaderModuleCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn code<'m, 'a>(mut self, code: &'a [u32]) -> ShaderModuleCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.codeSize = code.len() * 4;
        self.raw.pCode = code.as_ptr() as *const u32 as *const _;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> ShaderModuleCreateFlags {
        ShaderModuleCreateFlags::from_bits(self.raw.flags)
            .expect("ShaderModuleCreateInfo::flags: error converting flags")
    }

    pub fn get_code<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pCode as *const _, self.raw.codeSize as usize) }
    }

    pub fn build(self) -> ShaderModuleCreateInfo<'b> {
        ShaderModuleCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDescriptorSetLayoutBinding`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DescriptorSetLayoutBinding<'s> {
    raw: vks::VkDescriptorSetLayoutBinding,
    _p: PhantomData<&'s ()>,
}

impl<'s> DescriptorSetLayoutBinding<'s> {
    pub fn builder<'b>() -> DescriptorSetLayoutBindingBuilder<'b> {
        DescriptorSetLayoutBindingBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDescriptorSetLayoutBinding) -> DescriptorSetLayoutBinding<'s> {
        DescriptorSetLayoutBinding { raw, _p: PhantomData }
    }

    pub fn binding<'a>(&'a self) -> u32 {
        self.raw.binding.into()
    }

    pub fn descriptor_type<'a>(&'a self) -> DescriptorType {
        self.raw.descriptorType.into()
    }

    pub fn descriptor_count<'a>(&'a self) -> u32 {
        self.raw.descriptorCount.into()
    }

    pub fn stage_flags<'a>(&'a self) -> ShaderStageFlags {
        ShaderStageFlags::from_bits(self.raw.stageFlags)
            .expect("DescriptorSetLayoutBinding::stage_flags: error converting flags")
    }

    pub fn immutable_samplers<'a>(&'a self) -> &'a vks::VkSampler {
        unsafe { &*(self.raw.pImmutableSamplers as *const _) }
    }

    pub fn set_binding<'m>(&mut self, binding: u32) {
        self.raw.binding = binding.into();
    }

    pub fn set_descriptor_type<'m>(&mut self, descriptor_type: DescriptorType) {
        self.raw.descriptorType = descriptor_type.into();
    }

    pub fn set_descriptor_count<'m>(&mut self, descriptor_count: u32) {
        self.raw.descriptorCount = descriptor_count.into();
    }

    pub fn set_stage_flags<'m>(&mut self, stage_flags: ShaderStageFlags) {
        self.raw.stageFlags = stage_flags.bits();
    }

    pub fn set_immutable_samplers<'m, 'a>(&mut self, immutable_samplers: &'a [SamplerHandle])
            where 'a: 's {
        self.raw.pImmutableSamplers = immutable_samplers.as_ptr() as *const vks::VkSampler;
    }

    pub fn as_raw(&self) -> &vks::VkDescriptorSetLayoutBinding {
        &self.raw
    }
}

impl<'s> From<DescriptorSetLayoutBinding<'s>> for vks::VkDescriptorSetLayoutBinding {
    fn from(f: DescriptorSetLayoutBinding<'s>) -> vks::VkDescriptorSetLayoutBinding {
        f.raw
    }
}


/// A builder for `VkDescriptorSetLayoutBinding`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DescriptorSetLayoutBindingBuilder<'b> {
    raw: vks::VkDescriptorSetLayoutBinding,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DescriptorSetLayoutBindingBuilder<'b> {
    pub fn new() -> DescriptorSetLayoutBindingBuilder<'b> {
        DescriptorSetLayoutBindingBuilder {
            raw: vks::VkDescriptorSetLayoutBinding::default(),
            _p: PhantomData,
        }
    }

    pub fn binding<'m>(mut self, binding: u32) -> DescriptorSetLayoutBindingBuilder<'b> {
        self.raw.binding = binding.into();
        self
    }

    pub fn descriptor_type<'m>(mut self, descriptor_type: DescriptorType) -> DescriptorSetLayoutBindingBuilder<'b> {
        self.raw.descriptorType = descriptor_type.into();
        self
    }

    pub fn descriptor_count<'m>(mut self, descriptor_count: u32) -> DescriptorSetLayoutBindingBuilder<'b> {
        self.raw.descriptorCount = descriptor_count.into();
        self
    }

    pub fn stage_flags<'m>(mut self, stage_flags: ShaderStageFlags) -> DescriptorSetLayoutBindingBuilder<'b> {
        self.raw.stageFlags = stage_flags.bits();
        self
    }

    pub fn immutable_samplers<'m, 'a>(mut self, immutable_samplers: &'a [SamplerHandle]) -> DescriptorSetLayoutBindingBuilder<'b>
            where 'a: 'b {
        self.raw.pImmutableSamplers = immutable_samplers.as_ptr() as *const vks::VkSampler;
        self
    }

    pub fn get_binding<'a>(&'a self) -> u32 {
        self.raw.binding.into()
    }

    pub fn get_descriptor_type<'a>(&'a self) -> DescriptorType {
        self.raw.descriptorType.into()
    }

    pub fn get_descriptor_count<'a>(&'a self) -> u32 {
        self.raw.descriptorCount.into()
    }

    pub fn get_stage_flags<'a>(&'a self) -> ShaderStageFlags {
        ShaderStageFlags::from_bits(self.raw.stageFlags)
            .expect("DescriptorSetLayoutBinding::stage_flags: error converting flags")
    }

    pub fn get_immutable_samplers<'a>(&'a self) -> &'a vks::VkSampler {
        unsafe { &*(self.raw.pImmutableSamplers as *const _) }
    }

    pub fn build(self) -> DescriptorSetLayoutBinding<'b> {
        DescriptorSetLayoutBinding {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDescriptorSetLayoutCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DescriptorSetLayoutCreateInfo<'s> {
    raw: vks::VkDescriptorSetLayoutCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> DescriptorSetLayoutCreateInfo<'s> {
    pub fn builder<'b>() -> DescriptorSetLayoutCreateInfoBuilder<'b> {
        DescriptorSetLayoutCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDescriptorSetLayoutCreateInfo) -> DescriptorSetLayoutCreateInfo<'s> {
        DescriptorSetLayoutCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> DescriptorSetLayoutCreateFlags {
        DescriptorSetLayoutCreateFlags::from_bits(self.raw.flags)
            .expect("DescriptorSetLayoutCreateInfo::flags: error converting flags")
    }

    pub fn bindings<'a>(&'a self) -> &'a [DescriptorSetLayoutBinding] {
        unsafe { slice::from_raw_parts(self.raw.pBindings as *const _, self.raw.bindingCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: DescriptorSetLayoutCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_bindings<'m, 'a>(&mut self, bindings: &'a [DescriptorSetLayoutBinding])
            where 'a: 's {
        assert!(self.raw.bindingCount == 0 || self.raw.bindingCount == bindings.len() as _, 
            "count inconsistency found when specifying `DescriptorSetLayoutCreateInfo::bindings`.");
        self.raw.bindingCount = bindings.len() as _;
        self.raw.pBindings = bindings.as_ptr() as *const vks::VkDescriptorSetLayoutBinding;
    }

    pub fn as_raw(&self) -> &vks::VkDescriptorSetLayoutCreateInfo {
        &self.raw
    }
}

impl<'s> From<DescriptorSetLayoutCreateInfo<'s>> for vks::VkDescriptorSetLayoutCreateInfo {
    fn from(f: DescriptorSetLayoutCreateInfo<'s>) -> vks::VkDescriptorSetLayoutCreateInfo {
        f.raw
    }
}


/// A builder for `VkDescriptorSetLayoutCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DescriptorSetLayoutCreateInfoBuilder<'b> {
    raw: vks::VkDescriptorSetLayoutCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DescriptorSetLayoutCreateInfoBuilder<'b> {
    pub fn new() -> DescriptorSetLayoutCreateInfoBuilder<'b> {
        DescriptorSetLayoutCreateInfoBuilder {
            raw: vks::VkDescriptorSetLayoutCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DescriptorSetLayoutCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: DescriptorSetLayoutCreateFlags) -> DescriptorSetLayoutCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn bindings<'m, 'a>(mut self, bindings: &'a [DescriptorSetLayoutBinding]) -> DescriptorSetLayoutCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.bindingCount == 0 || self.raw.bindingCount == bindings.len() as _, 
            "count inconsistency found when specifying `DescriptorSetLayoutCreateInfo::bindings`.");
        self.raw.bindingCount = bindings.len() as _;
        self.raw.pBindings = bindings.as_ptr() as *const vks::VkDescriptorSetLayoutBinding;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> DescriptorSetLayoutCreateFlags {
        DescriptorSetLayoutCreateFlags::from_bits(self.raw.flags)
            .expect("DescriptorSetLayoutCreateInfo::flags: error converting flags")
    }

    pub fn get_bindings<'a>(&'a self) -> &'a [DescriptorSetLayoutBinding] {
        unsafe { slice::from_raw_parts(self.raw.pBindings as *const _, self.raw.bindingCount as usize) }
    }

    pub fn build(self) -> DescriptorSetLayoutCreateInfo<'b> {
        DescriptorSetLayoutCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDescriptorPoolSize`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DescriptorPoolSize {
    raw: vks::VkDescriptorPoolSize,
}

impl DescriptorPoolSize {
    pub fn builder() -> DescriptorPoolSizeBuilder {
        DescriptorPoolSizeBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDescriptorPoolSize) -> DescriptorPoolSize {
        DescriptorPoolSize { raw, }
    }

    pub fn type_of<'a>(&'a self) -> DescriptorType {
        self.raw.type_.into()
    }

    pub fn descriptor_count<'a>(&'a self) -> u32 {
        self.raw.descriptorCount.into()
    }

    pub fn set_type_of<'m>(&mut self, type_of: DescriptorType) {
        self.raw.type_ = type_of.into();
    }

    pub fn set_descriptor_count<'m>(&mut self, descriptor_count: u32) {
        self.raw.descriptorCount = descriptor_count.into();
    }

    pub fn as_raw(&self) -> &vks::VkDescriptorPoolSize {
        &self.raw
    }
}

impl From<DescriptorPoolSize> for vks::VkDescriptorPoolSize {
    fn from(f: DescriptorPoolSize) -> vks::VkDescriptorPoolSize {
        f.raw
    }
}


/// A builder for `VkDescriptorPoolSize`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DescriptorPoolSizeBuilder {
    raw: vks::VkDescriptorPoolSize,
}

impl DescriptorPoolSizeBuilder {
    pub fn new() -> DescriptorPoolSizeBuilder {
        DescriptorPoolSizeBuilder {
            raw: vks::VkDescriptorPoolSize::default(),
        }
    }

    pub fn type_of<'m>(mut self, type_of: DescriptorType) -> DescriptorPoolSizeBuilder {
        self.raw.type_ = type_of.into();
        self
    }

    pub fn descriptor_count<'m>(mut self, descriptor_count: u32) -> DescriptorPoolSizeBuilder {
        self.raw.descriptorCount = descriptor_count.into();
        self
    }

    pub fn get_type_of<'a>(&'a self) -> DescriptorType {
        self.raw.type_.into()
    }

    pub fn get_descriptor_count<'a>(&'a self) -> u32 {
        self.raw.descriptorCount.into()
    }

    pub fn build(self) -> DescriptorPoolSize {
        DescriptorPoolSize {
            raw: self.raw,
        }
    }
}


/// A `VkDescriptorPoolCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DescriptorPoolCreateInfo<'s> {
    raw: vks::VkDescriptorPoolCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> DescriptorPoolCreateInfo<'s> {
    pub fn builder<'b>() -> DescriptorPoolCreateInfoBuilder<'b> {
        DescriptorPoolCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDescriptorPoolCreateInfo) -> DescriptorPoolCreateInfo<'s> {
        DescriptorPoolCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> DescriptorPoolCreateFlags {
        DescriptorPoolCreateFlags::from_bits(self.raw.flags)
            .expect("DescriptorPoolCreateInfo::flags: error converting flags")
    }

    pub fn max_sets<'a>(&'a self) -> u32 {
        self.raw.maxSets.into()
    }

    pub fn pool_sizes<'a>(&'a self) -> &'a [DescriptorPoolSize] {
        unsafe { slice::from_raw_parts(self.raw.pPoolSizes as *const _, self.raw.poolSizeCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: DescriptorPoolCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_max_sets<'m>(&mut self, max_sets: u32) {
        self.raw.maxSets = max_sets.into();
    }

    pub fn set_pool_sizes<'m, 'a>(&mut self, pool_sizes: &'a [DescriptorPoolSize])
            where 'a: 's {
        assert!(self.raw.poolSizeCount == 0 || self.raw.poolSizeCount == pool_sizes.len() as _, 
            "count inconsistency found when specifying `DescriptorPoolCreateInfo::pool_sizes`.");
        self.raw.poolSizeCount = pool_sizes.len() as _;
        self.raw.pPoolSizes = pool_sizes.as_ptr() as *const vks::VkDescriptorPoolSize;
    }

    pub fn as_raw(&self) -> &vks::VkDescriptorPoolCreateInfo {
        &self.raw
    }
}

impl<'s> From<DescriptorPoolCreateInfo<'s>> for vks::VkDescriptorPoolCreateInfo {
    fn from(f: DescriptorPoolCreateInfo<'s>) -> vks::VkDescriptorPoolCreateInfo {
        f.raw
    }
}


/// A builder for `VkDescriptorPoolCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DescriptorPoolCreateInfoBuilder<'b> {
    raw: vks::VkDescriptorPoolCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DescriptorPoolCreateInfoBuilder<'b> {
    pub fn new() -> DescriptorPoolCreateInfoBuilder<'b> {
        DescriptorPoolCreateInfoBuilder {
            raw: vks::VkDescriptorPoolCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DescriptorPoolCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: DescriptorPoolCreateFlags) -> DescriptorPoolCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn max_sets<'m>(mut self, max_sets: u32) -> DescriptorPoolCreateInfoBuilder<'b> {
        self.raw.maxSets = max_sets.into();
        self
    }

    pub fn pool_sizes<'m, 'a>(mut self, pool_sizes: &'a [DescriptorPoolSize]) -> DescriptorPoolCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.poolSizeCount == 0 || self.raw.poolSizeCount == pool_sizes.len() as _, 
            "count inconsistency found when specifying `DescriptorPoolCreateInfo::pool_sizes`.");
        self.raw.poolSizeCount = pool_sizes.len() as _;
        self.raw.pPoolSizes = pool_sizes.as_ptr() as *const vks::VkDescriptorPoolSize;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> DescriptorPoolCreateFlags {
        DescriptorPoolCreateFlags::from_bits(self.raw.flags)
            .expect("DescriptorPoolCreateInfo::flags: error converting flags")
    }

    pub fn get_max_sets<'a>(&'a self) -> u32 {
        self.raw.maxSets.into()
    }

    pub fn get_pool_sizes<'a>(&'a self) -> &'a [DescriptorPoolSize] {
        unsafe { slice::from_raw_parts(self.raw.pPoolSizes as *const _, self.raw.poolSizeCount as usize) }
    }

    pub fn build(self) -> DescriptorPoolCreateInfo<'b> {
        DescriptorPoolCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDescriptorSetAllocateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DescriptorSetAllocateInfo<'s> {
    raw: vks::VkDescriptorSetAllocateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> DescriptorSetAllocateInfo<'s> {
    pub fn builder<'b>() -> DescriptorSetAllocateInfoBuilder<'b> {
        DescriptorSetAllocateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDescriptorSetAllocateInfo) -> DescriptorSetAllocateInfo<'s> {
        DescriptorSetAllocateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn descriptor_pool<'a>(&'a self) -> vks::VkDescriptorPool {
        self.raw.descriptorPool
    }

    pub fn set_layouts<'a>(&'a self) -> &'a [vks::VkDescriptorSetLayout] {
        unsafe { slice::from_raw_parts(self.raw.pSetLayouts as *const _, self.raw.descriptorSetCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_descriptor_pool<'m, H>(&mut self, descriptor_pool: H)
            where H: Handle<Target=DescriptorPoolHandle> {
        self.raw.descriptorPool = descriptor_pool.handle().0;
    }

    pub fn set_set_layouts<'m, 'a>(&mut self, set_layouts: &'a [DescriptorSetLayoutHandle])
            where 'a: 's {
        assert!(self.raw.descriptorSetCount == 0 || self.raw.descriptorSetCount == set_layouts.len() as _, 
            "count inconsistency found when specifying `DescriptorSetAllocateInfo::set_layouts`.");
        self.raw.descriptorSetCount = set_layouts.len() as _;
        self.raw.pSetLayouts = set_layouts.as_ptr() as *const vks::VkDescriptorSetLayout;
    }

    pub fn as_raw(&self) -> &vks::VkDescriptorSetAllocateInfo {
        &self.raw
    }
}

impl<'s> From<DescriptorSetAllocateInfo<'s>> for vks::VkDescriptorSetAllocateInfo {
    fn from(f: DescriptorSetAllocateInfo<'s>) -> vks::VkDescriptorSetAllocateInfo {
        f.raw
    }
}


/// A builder for `VkDescriptorSetAllocateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DescriptorSetAllocateInfoBuilder<'b> {
    raw: vks::VkDescriptorSetAllocateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DescriptorSetAllocateInfoBuilder<'b> {
    pub fn new() -> DescriptorSetAllocateInfoBuilder<'b> {
        DescriptorSetAllocateInfoBuilder {
            raw: vks::VkDescriptorSetAllocateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DescriptorSetAllocateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn descriptor_pool<'m, H>(mut self, descriptor_pool: H) -> DescriptorSetAllocateInfoBuilder<'b>
            where H: Handle<Target=DescriptorPoolHandle> {
        self.raw.descriptorPool = descriptor_pool.handle().0;
        self
    }

    pub fn set_layouts<'m, 'a>(mut self, set_layouts: &'a [DescriptorSetLayoutHandle]) -> DescriptorSetAllocateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.descriptorSetCount == 0 || self.raw.descriptorSetCount == set_layouts.len() as _, 
            "count inconsistency found when specifying `DescriptorSetAllocateInfo::set_layouts`.");
        self.raw.descriptorSetCount = set_layouts.len() as _;
        self.raw.pSetLayouts = set_layouts.as_ptr() as *const vks::VkDescriptorSetLayout;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_descriptor_pool<'a>(&'a self) -> vks::VkDescriptorPool {
        self.raw.descriptorPool
    }

    pub fn get_set_layouts<'a>(&'a self) -> &'a [vks::VkDescriptorSetLayout] {
        unsafe { slice::from_raw_parts(self.raw.pSetLayouts as *const _, self.raw.descriptorSetCount as usize) }
    }

    pub fn build(self) -> DescriptorSetAllocateInfo<'b> {
        DescriptorSetAllocateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSpecializationMapEntry`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SpecializationMapEntry {
    raw: vks::VkSpecializationMapEntry,
}

impl SpecializationMapEntry {
    pub fn builder() -> SpecializationMapEntryBuilder {
        SpecializationMapEntryBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSpecializationMapEntry) -> SpecializationMapEntry {
        SpecializationMapEntry { raw, }
    }

    pub fn constant_id<'a>(&'a self) -> u32 {
        self.raw.constantID.into()
    }

    pub fn offset<'a>(&'a self) -> u32 {
        self.raw.offset.into()
    }

    pub fn size<'a>(&'a self) -> usize {
        self.raw.size.into()
    }

    pub fn set_constant_id<'m>(&mut self, constant_id: u32) {
        self.raw.constantID = constant_id.into();
    }

    pub fn set_offset<'m>(&mut self, offset: u32) {
        self.raw.offset = offset.into();
    }

    pub fn set_size<'m>(&mut self, size: usize) {
        self.raw.size = size.into();
    }

    pub fn as_raw(&self) -> &vks::VkSpecializationMapEntry {
        &self.raw
    }
}

impl From<SpecializationMapEntry> for vks::VkSpecializationMapEntry {
    fn from(f: SpecializationMapEntry) -> vks::VkSpecializationMapEntry {
        f.raw
    }
}


/// A builder for `VkSpecializationMapEntry`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SpecializationMapEntryBuilder {
    raw: vks::VkSpecializationMapEntry,
}

impl SpecializationMapEntryBuilder {
    pub fn new() -> SpecializationMapEntryBuilder {
        SpecializationMapEntryBuilder {
            raw: vks::VkSpecializationMapEntry::default(),
        }
    }

    pub fn constant_id<'m>(mut self, constant_id: u32) -> SpecializationMapEntryBuilder {
        self.raw.constantID = constant_id.into();
        self
    }

    pub fn offset<'m>(mut self, offset: u32) -> SpecializationMapEntryBuilder {
        self.raw.offset = offset.into();
        self
    }

    pub fn size<'m>(mut self, size: usize) -> SpecializationMapEntryBuilder {
        self.raw.size = size.into();
        self
    }

    pub fn get_constant_id<'a>(&'a self) -> u32 {
        self.raw.constantID.into()
    }

    pub fn get_offset<'a>(&'a self) -> u32 {
        self.raw.offset.into()
    }

    pub fn get_size<'a>(&'a self) -> usize {
        self.raw.size.into()
    }

    pub fn build(self) -> SpecializationMapEntry {
        SpecializationMapEntry {
            raw: self.raw,
        }
    }
}


/// A `VkSpecializationInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SpecializationInfo<'s> {
    raw: vks::VkSpecializationInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> SpecializationInfo<'s> {
    pub fn builder<'b>() -> SpecializationInfoBuilder<'b> {
        SpecializationInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSpecializationInfo) -> SpecializationInfo<'s> {
        SpecializationInfo { raw, _p: PhantomData }
    }

    pub fn map_entries<'a>(&'a self) -> &'a [SpecializationMapEntry] {
        unsafe { slice::from_raw_parts(self.raw.pMapEntries as *const _, self.raw.mapEntryCount as usize) }
    }

    pub fn data_size<'a>(&'a self) -> usize {
        self.raw.dataSize.into()
    }

    pub fn data<'a>(&'a self) -> *const c_void {
        self.raw.pData
    }

    pub fn set_map_entries<'m, 'a>(&mut self, map_entries: &'a [SpecializationMapEntry])
            where 'a: 's {
        assert!(self.raw.mapEntryCount == 0 || self.raw.mapEntryCount == map_entries.len() as _, 
            "count inconsistency found when specifying `SpecializationInfo::map_entries`.");
        self.raw.mapEntryCount = map_entries.len() as _;
        self.raw.pMapEntries = map_entries.as_ptr() as *const vks::VkSpecializationMapEntry;
    }

    pub fn set_data_size<'m>(&mut self, data_size: usize) {
        self.raw.dataSize = data_size.into();
    }

    pub unsafe fn set_data<'m>(&mut self, data: *const c_void) {
        self.raw.pData = data;
    }

    pub fn as_raw(&self) -> &vks::VkSpecializationInfo {
        &self.raw
    }
}

impl<'s> From<SpecializationInfo<'s>> for vks::VkSpecializationInfo {
    fn from(f: SpecializationInfo<'s>) -> vks::VkSpecializationInfo {
        f.raw
    }
}


/// A builder for `VkSpecializationInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SpecializationInfoBuilder<'b> {
    raw: vks::VkSpecializationInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SpecializationInfoBuilder<'b> {
    pub fn new() -> SpecializationInfoBuilder<'b> {
        SpecializationInfoBuilder {
            raw: vks::VkSpecializationInfo::default(),
            _p: PhantomData,
        }
    }

    pub fn map_entries<'m, 'a>(mut self, map_entries: &'a [SpecializationMapEntry]) -> SpecializationInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.mapEntryCount == 0 || self.raw.mapEntryCount == map_entries.len() as _, 
            "count inconsistency found when specifying `SpecializationInfo::map_entries`.");
        self.raw.mapEntryCount = map_entries.len() as _;
        self.raw.pMapEntries = map_entries.as_ptr() as *const vks::VkSpecializationMapEntry;
        self
    }

    pub fn data_size<'m>(mut self, data_size: usize) -> SpecializationInfoBuilder<'b> {
        self.raw.dataSize = data_size.into();
        self
    }

    pub unsafe fn data<'m>(mut self, data: *const c_void) -> SpecializationInfoBuilder<'b> {
        self.raw.pData = data;
        self
    }

    pub fn get_map_entries<'a>(&'a self) -> &'a [SpecializationMapEntry] {
        unsafe { slice::from_raw_parts(self.raw.pMapEntries as *const _, self.raw.mapEntryCount as usize) }
    }

    pub fn get_data_size<'a>(&'a self) -> usize {
        self.raw.dataSize.into()
    }

    pub fn get_data<'a>(&'a self) -> *const c_void {
        self.raw.pData
    }

    pub fn build(self) -> SpecializationInfo<'b> {
        SpecializationInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineShaderStageCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineShaderStageCreateInfo<'s> {
    raw: vks::VkPipelineShaderStageCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineShaderStageCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineShaderStageCreateInfoBuilder<'b> {
        PipelineShaderStageCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineShaderStageCreateInfo) -> PipelineShaderStageCreateInfo<'s> {
        PipelineShaderStageCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineShaderStageCreateFlags {
        PipelineShaderStageCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineShaderStageCreateInfo::flags: error converting flags")
    }

    pub fn stage<'a>(&'a self) -> ShaderStageFlags {
        ShaderStageFlags::from_bits(self.raw.stage)
            .expect("PipelineShaderStageCreateInfo::stage: error converting flags")
    }

    pub fn module<'a>(&'a self) -> vks::VkShaderModule {
        self.raw.module
    }

    pub fn name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(self.raw.pName) }
    }

    pub fn specialization_info<'a>(&'a self) -> &'a SpecializationInfo {
        unsafe { &*(self.raw.pSpecializationInfo as *const vks::VkSpecializationInfo as *const _) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineShaderStageCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_stage<'m>(&mut self, stage: ShaderStageFlags) {
        self.raw.stage = stage.bits();
    }

    pub fn set_module<'m, H>(&mut self, module: H)
            where H: Handle<Target=ShaderModuleHandle> {
        self.raw.module = module.handle().0;
    }

    pub fn set_name<'m, 'a>(&mut self, name: &'a CStr)
            where 'a: 's {
        self.raw.pName = name.as_ptr();
    }

    pub fn set_specialization_info<'m, 'a>(&mut self, specialization_info: &'a SpecializationInfo)
            where 'a: 's {
        self.raw.pSpecializationInfo = specialization_info.as_raw();
    }

    pub fn as_raw(&self) -> &vks::VkPipelineShaderStageCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineShaderStageCreateInfo<'s>> for vks::VkPipelineShaderStageCreateInfo {
    fn from(f: PipelineShaderStageCreateInfo<'s>) -> vks::VkPipelineShaderStageCreateInfo {
        f.raw
    }
}


/// A builder for `VkPipelineShaderStageCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineShaderStageCreateInfoBuilder<'b> {
    raw: vks::VkPipelineShaderStageCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineShaderStageCreateInfoBuilder<'b> {
    pub fn new() -> PipelineShaderStageCreateInfoBuilder<'b> {
        PipelineShaderStageCreateInfoBuilder {
            raw: vks::VkPipelineShaderStageCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineShaderStageCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineShaderStageCreateFlags) -> PipelineShaderStageCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn stage<'m>(mut self, stage: ShaderStageFlags) -> PipelineShaderStageCreateInfoBuilder<'b> {
        self.raw.stage = stage.bits();
        self
    }

    pub fn module<'m, H>(mut self, module: H) -> PipelineShaderStageCreateInfoBuilder<'b>
            where H: Handle<Target=ShaderModuleHandle> {
        self.raw.module = module.handle().0;
        self
    }

    pub fn name<'m, 'a>(mut self, name: &'a CStr) -> PipelineShaderStageCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pName = name.as_ptr();
        self
    }

    pub fn specialization_info<'m, 'a>(mut self, specialization_info: &'a SpecializationInfo) -> PipelineShaderStageCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pSpecializationInfo = specialization_info.as_raw();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> PipelineShaderStageCreateFlags {
        PipelineShaderStageCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineShaderStageCreateInfo::flags: error converting flags")
    }

    pub fn get_stage<'a>(&'a self) -> ShaderStageFlags {
        ShaderStageFlags::from_bits(self.raw.stage)
            .expect("PipelineShaderStageCreateInfo::stage: error converting flags")
    }

    pub fn get_module<'a>(&'a self) -> vks::VkShaderModule {
        self.raw.module
    }

    pub fn get_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(self.raw.pName) }
    }

    pub fn get_specialization_info<'a>(&'a self) -> &'a SpecializationInfo {
        unsafe { &*(self.raw.pSpecializationInfo as *const vks::VkSpecializationInfo as *const _) }
    }

    pub fn build(self) -> PipelineShaderStageCreateInfo<'b> {
        PipelineShaderStageCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkComputePipelineCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ComputePipelineCreateInfo<'s> {
    raw: vks::VkComputePipelineCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> ComputePipelineCreateInfo<'s> {
    pub fn builder<'b>() -> ComputePipelineCreateInfoBuilder<'b> {
        ComputePipelineCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkComputePipelineCreateInfo) -> ComputePipelineCreateInfo<'s> {
        ComputePipelineCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineCreateFlags {
        PipelineCreateFlags::from_bits(self.raw.flags)
            .expect("ComputePipelineCreateInfo::flags: error converting flags")
    }

    pub fn stage<'a>(&'a self) -> &'a PipelineShaderStageCreateInfo {
        unsafe { &*(&self.raw.stage as *const vks::VkPipelineShaderStageCreateInfo as *const PipelineShaderStageCreateInfo) }
    }

    pub fn stage_mut<'a>(&'a mut self) -> &'a mut PipelineShaderStageCreateInfo {
        unsafe { &mut *(&mut self.raw.stage as *mut  vks::VkPipelineShaderStageCreateInfo as *mut PipelineShaderStageCreateInfo) }
    }

    pub fn layout<'a>(&'a self) -> vks::VkPipelineLayout {
        self.raw.layout
    }

    pub fn base_pipeline_handle<'a>(&'a self) -> vks::VkPipeline {
        self.raw.basePipelineHandle
    }

    pub fn base_pipeline_index<'a>(&'a self) -> i32 {
        self.raw.basePipelineIndex.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_stage<'m>(&mut self, stage: PipelineShaderStageCreateInfo) {
        self.raw.stage = stage.raw;
    }

    pub fn set_layout<'m, H>(&mut self, layout: H)
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.layout = layout.handle().0;
    }

    pub fn set_base_pipeline_handle<'m, H>(&mut self, base_pipeline_handle: H)
            where H: Handle<Target=PipelineHandle> {
        self.raw.basePipelineHandle = base_pipeline_handle.handle().0;
    }

    pub fn set_base_pipeline_index<'m>(&mut self, base_pipeline_index: i32) {
        self.raw.basePipelineIndex = base_pipeline_index.into();
    }

    pub fn as_raw(&self) -> &vks::VkComputePipelineCreateInfo {
        &self.raw
    }
}

impl<'s> From<ComputePipelineCreateInfo<'s>> for vks::VkComputePipelineCreateInfo {
    fn from(f: ComputePipelineCreateInfo<'s>) -> vks::VkComputePipelineCreateInfo {
        f.raw
    }
}


/// A builder for `VkComputePipelineCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ComputePipelineCreateInfoBuilder<'b> {
    raw: vks::VkComputePipelineCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ComputePipelineCreateInfoBuilder<'b> {
    pub fn new() -> ComputePipelineCreateInfoBuilder<'b> {
        ComputePipelineCreateInfoBuilder {
            raw: vks::VkComputePipelineCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ComputePipelineCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineCreateFlags) -> ComputePipelineCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn stage<'m>(mut self, stage: PipelineShaderStageCreateInfo) -> ComputePipelineCreateInfoBuilder<'b> {
        self.raw.stage = stage.raw;
        self
    }

    pub fn layout<'m, H>(mut self, layout: H) -> ComputePipelineCreateInfoBuilder<'b>
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.layout = layout.handle().0;
        self
    }

    pub fn base_pipeline_handle<'m, H>(mut self, base_pipeline_handle: H) -> ComputePipelineCreateInfoBuilder<'b>
            where H: Handle<Target=PipelineHandle> {
        self.raw.basePipelineHandle = base_pipeline_handle.handle().0;
        self
    }

    pub fn base_pipeline_index<'m>(mut self, base_pipeline_index: i32) -> ComputePipelineCreateInfoBuilder<'b> {
        self.raw.basePipelineIndex = base_pipeline_index.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> PipelineCreateFlags {
        PipelineCreateFlags::from_bits(self.raw.flags)
            .expect("ComputePipelineCreateInfo::flags: error converting flags")
    }

    pub fn get_stage<'a>(&'a self) -> &'a PipelineShaderStageCreateInfo {
        unsafe { &*(&self.raw.stage as *const vks::VkPipelineShaderStageCreateInfo as *const PipelineShaderStageCreateInfo) }
    }

    pub fn get_stage_mut<'a>(&'a mut self) -> &'a mut PipelineShaderStageCreateInfo {
        unsafe { &mut *(&mut self.raw.stage as *mut  vks::VkPipelineShaderStageCreateInfo as *mut PipelineShaderStageCreateInfo) }
    }

    pub fn get_layout<'a>(&'a self) -> vks::VkPipelineLayout {
        self.raw.layout
    }

    pub fn get_base_pipeline_handle<'a>(&'a self) -> vks::VkPipeline {
        self.raw.basePipelineHandle
    }

    pub fn get_base_pipeline_index<'a>(&'a self) -> i32 {
        self.raw.basePipelineIndex.into()
    }

    pub fn build(self) -> ComputePipelineCreateInfo<'b> {
        ComputePipelineCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkVertexInputBindingDescription`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct VertexInputBindingDescription {
    raw: vks::VkVertexInputBindingDescription,
}

impl VertexInputBindingDescription {
    pub fn builder() -> VertexInputBindingDescriptionBuilder {
        VertexInputBindingDescriptionBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkVertexInputBindingDescription) -> VertexInputBindingDescription {
        VertexInputBindingDescription { raw, }
    }

    pub fn binding<'a>(&'a self) -> u32 {
        self.raw.binding.into()
    }

    pub fn stride<'a>(&'a self) -> u32 {
        self.raw.stride.into()
    }

    pub fn input_rate<'a>(&'a self) -> VertexInputRate {
        self.raw.inputRate.into()
    }

    pub fn set_binding<'m>(&mut self, binding: u32) {
        self.raw.binding = binding.into();
    }

    pub fn set_stride<'m>(&mut self, stride: u32) {
        self.raw.stride = stride.into();
    }

    pub fn set_input_rate<'m>(&mut self, input_rate: VertexInputRate) {
        self.raw.inputRate = input_rate.into();
    }

    pub fn as_raw(&self) -> &vks::VkVertexInputBindingDescription {
        &self.raw
    }
}

impl From<VertexInputBindingDescription> for vks::VkVertexInputBindingDescription {
    fn from(f: VertexInputBindingDescription) -> vks::VkVertexInputBindingDescription {
        f.raw
    }
}


/// A builder for `VkVertexInputBindingDescription`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct VertexInputBindingDescriptionBuilder {
    raw: vks::VkVertexInputBindingDescription,
}

impl VertexInputBindingDescriptionBuilder {
    pub fn new() -> VertexInputBindingDescriptionBuilder {
        VertexInputBindingDescriptionBuilder {
            raw: vks::VkVertexInputBindingDescription::default(),
        }
    }

    pub fn binding<'m>(mut self, binding: u32) -> VertexInputBindingDescriptionBuilder {
        self.raw.binding = binding.into();
        self
    }

    pub fn stride<'m>(mut self, stride: u32) -> VertexInputBindingDescriptionBuilder {
        self.raw.stride = stride.into();
        self
    }

    pub fn input_rate<'m>(mut self, input_rate: VertexInputRate) -> VertexInputBindingDescriptionBuilder {
        self.raw.inputRate = input_rate.into();
        self
    }

    pub fn get_binding<'a>(&'a self) -> u32 {
        self.raw.binding.into()
    }

    pub fn get_stride<'a>(&'a self) -> u32 {
        self.raw.stride.into()
    }

    pub fn get_input_rate<'a>(&'a self) -> VertexInputRate {
        self.raw.inputRate.into()
    }

    pub fn build(self) -> VertexInputBindingDescription {
        VertexInputBindingDescription {
            raw: self.raw,
        }
    }
}


/// A `VkVertexInputAttributeDescription`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct VertexInputAttributeDescription {
    raw: vks::VkVertexInputAttributeDescription,
}

impl VertexInputAttributeDescription {
    pub fn builder() -> VertexInputAttributeDescriptionBuilder {
        VertexInputAttributeDescriptionBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkVertexInputAttributeDescription) -> VertexInputAttributeDescription {
        VertexInputAttributeDescription { raw, }
    }

    pub fn location<'a>(&'a self) -> u32 {
        self.raw.location.into()
    }

    pub fn binding<'a>(&'a self) -> u32 {
        self.raw.binding.into()
    }

    pub fn format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn offset<'a>(&'a self) -> u32 {
        self.raw.offset.into()
    }

    pub fn set_location<'m>(&mut self, location: u32) {
        self.raw.location = location.into();
    }

    pub fn set_binding<'m>(&mut self, binding: u32) {
        self.raw.binding = binding.into();
    }

    pub fn set_format<'m>(&mut self, format: Format) {
        self.raw.format = format.into();
    }

    pub fn set_offset<'m>(&mut self, offset: u32) {
        self.raw.offset = offset.into();
    }

    pub fn as_raw(&self) -> &vks::VkVertexInputAttributeDescription {
        &self.raw
    }
}

impl From<VertexInputAttributeDescription> for vks::VkVertexInputAttributeDescription {
    fn from(f: VertexInputAttributeDescription) -> vks::VkVertexInputAttributeDescription {
        f.raw
    }
}


/// A builder for `VkVertexInputAttributeDescription`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct VertexInputAttributeDescriptionBuilder {
    raw: vks::VkVertexInputAttributeDescription,
}

impl VertexInputAttributeDescriptionBuilder {
    pub fn new() -> VertexInputAttributeDescriptionBuilder {
        VertexInputAttributeDescriptionBuilder {
            raw: vks::VkVertexInputAttributeDescription::default(),
        }
    }

    pub fn location<'m>(mut self, location: u32) -> VertexInputAttributeDescriptionBuilder {
        self.raw.location = location.into();
        self
    }

    pub fn binding<'m>(mut self, binding: u32) -> VertexInputAttributeDescriptionBuilder {
        self.raw.binding = binding.into();
        self
    }

    pub fn format<'m>(mut self, format: Format) -> VertexInputAttributeDescriptionBuilder {
        self.raw.format = format.into();
        self
    }

    pub fn offset<'m>(mut self, offset: u32) -> VertexInputAttributeDescriptionBuilder {
        self.raw.offset = offset.into();
        self
    }

    pub fn get_location<'a>(&'a self) -> u32 {
        self.raw.location.into()
    }

    pub fn get_binding<'a>(&'a self) -> u32 {
        self.raw.binding.into()
    }

    pub fn get_format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn get_offset<'a>(&'a self) -> u32 {
        self.raw.offset.into()
    }

    pub fn build(self) -> VertexInputAttributeDescription {
        VertexInputAttributeDescription {
            raw: self.raw,
        }
    }
}


/// A `VkPipelineVertexInputStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineVertexInputStateCreateInfo<'s> {
    raw: vks::VkPipelineVertexInputStateCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineVertexInputStateCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineVertexInputStateCreateInfoBuilder<'b> {
        PipelineVertexInputStateCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineVertexInputStateCreateInfo) -> PipelineVertexInputStateCreateInfo<'s> {
        PipelineVertexInputStateCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineVertexInputStateCreateFlags {
        PipelineVertexInputStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineVertexInputStateCreateInfo::flags: error converting flags")
    }

    pub fn vertex_binding_descriptions<'a>(&'a self) -> &'a [VertexInputBindingDescription] {
        unsafe { slice::from_raw_parts(self.raw.pVertexBindingDescriptions as *const _, self.raw.vertexBindingDescriptionCount as usize) }
    }

    pub fn vertex_attribute_descriptions<'a>(&'a self) -> &'a [VertexInputAttributeDescription] {
        unsafe { slice::from_raw_parts(self.raw.pVertexAttributeDescriptions as *const _, self.raw.vertexAttributeDescriptionCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineVertexInputStateCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_vertex_binding_descriptions<'m, 'a>(&mut self, vertex_binding_descriptions: &'a [VertexInputBindingDescription])
            where 'a: 's {
        assert!(self.raw.vertexBindingDescriptionCount == 0 || self.raw.vertexBindingDescriptionCount == vertex_binding_descriptions.len() as _, 
            "count inconsistency found when specifying `PipelineVertexInputStateCreateInfo::vertex_binding_descriptions`.");
        self.raw.vertexBindingDescriptionCount = vertex_binding_descriptions.len() as _;
        self.raw.pVertexBindingDescriptions = vertex_binding_descriptions.as_ptr() as *const vks::VkVertexInputBindingDescription;
    }

    pub fn set_vertex_attribute_descriptions<'m, 'a>(&mut self, vertex_attribute_descriptions: &'a [VertexInputAttributeDescription])
            where 'a: 's {
        assert!(self.raw.vertexAttributeDescriptionCount == 0 || self.raw.vertexAttributeDescriptionCount == vertex_attribute_descriptions.len() as _, 
            "count inconsistency found when specifying `PipelineVertexInputStateCreateInfo::vertex_attribute_descriptions`.");
        self.raw.vertexAttributeDescriptionCount = vertex_attribute_descriptions.len() as _;
        self.raw.pVertexAttributeDescriptions = vertex_attribute_descriptions.as_ptr() as *const vks::VkVertexInputAttributeDescription;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineVertexInputStateCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineVertexInputStateCreateInfo<'s>> for vks::VkPipelineVertexInputStateCreateInfo {
    fn from(f: PipelineVertexInputStateCreateInfo<'s>) -> vks::VkPipelineVertexInputStateCreateInfo {
        f.raw
    }
}


/// A builder for `VkPipelineVertexInputStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineVertexInputStateCreateInfoBuilder<'b> {
    raw: vks::VkPipelineVertexInputStateCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineVertexInputStateCreateInfoBuilder<'b> {
    pub fn new() -> PipelineVertexInputStateCreateInfoBuilder<'b> {
        PipelineVertexInputStateCreateInfoBuilder {
            raw: vks::VkPipelineVertexInputStateCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineVertexInputStateCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineVertexInputStateCreateFlags) -> PipelineVertexInputStateCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn vertex_binding_descriptions<'m, 'a>(mut self, vertex_binding_descriptions: &'a [VertexInputBindingDescription]) -> PipelineVertexInputStateCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.vertexBindingDescriptionCount == 0 || self.raw.vertexBindingDescriptionCount == vertex_binding_descriptions.len() as _, 
            "count inconsistency found when specifying `PipelineVertexInputStateCreateInfo::vertex_binding_descriptions`.");
        self.raw.vertexBindingDescriptionCount = vertex_binding_descriptions.len() as _;
        self.raw.pVertexBindingDescriptions = vertex_binding_descriptions.as_ptr() as *const vks::VkVertexInputBindingDescription;
        self
    }

    pub fn vertex_attribute_descriptions<'m, 'a>(mut self, vertex_attribute_descriptions: &'a [VertexInputAttributeDescription]) -> PipelineVertexInputStateCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.vertexAttributeDescriptionCount == 0 || self.raw.vertexAttributeDescriptionCount == vertex_attribute_descriptions.len() as _, 
            "count inconsistency found when specifying `PipelineVertexInputStateCreateInfo::vertex_attribute_descriptions`.");
        self.raw.vertexAttributeDescriptionCount = vertex_attribute_descriptions.len() as _;
        self.raw.pVertexAttributeDescriptions = vertex_attribute_descriptions.as_ptr() as *const vks::VkVertexInputAttributeDescription;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> PipelineVertexInputStateCreateFlags {
        PipelineVertexInputStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineVertexInputStateCreateInfo::flags: error converting flags")
    }

    pub fn get_vertex_binding_descriptions<'a>(&'a self) -> &'a [VertexInputBindingDescription] {
        unsafe { slice::from_raw_parts(self.raw.pVertexBindingDescriptions as *const _, self.raw.vertexBindingDescriptionCount as usize) }
    }

    pub fn get_vertex_attribute_descriptions<'a>(&'a self) -> &'a [VertexInputAttributeDescription] {
        unsafe { slice::from_raw_parts(self.raw.pVertexAttributeDescriptions as *const _, self.raw.vertexAttributeDescriptionCount as usize) }
    }

    pub fn build(self) -> PipelineVertexInputStateCreateInfo<'b> {
        PipelineVertexInputStateCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineInputAssemblyStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineInputAssemblyStateCreateInfo<'s> {
    raw: vks::VkPipelineInputAssemblyStateCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineInputAssemblyStateCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineInputAssemblyStateCreateInfoBuilder<'b> {
        PipelineInputAssemblyStateCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineInputAssemblyStateCreateInfo) -> PipelineInputAssemblyStateCreateInfo<'s> {
        PipelineInputAssemblyStateCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineInputAssemblyStateCreateFlags {
        PipelineInputAssemblyStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineInputAssemblyStateCreateInfo::flags: error converting flags")
    }

    pub fn topology<'a>(&'a self) -> PrimitiveTopology {
        self.raw.topology.into()
    }

    pub fn primitive_restart_enable<'a>(&'a self) -> bool {
        self.raw.primitiveRestartEnable != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineInputAssemblyStateCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_topology<'m>(&mut self, topology: PrimitiveTopology) {
        self.raw.topology = topology.into();
    }

    pub fn set_primitive_restart_enable<'m>(&mut self, primitive_restart_enable: bool) {
        self.raw.primitiveRestartEnable = primitive_restart_enable as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineInputAssemblyStateCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineInputAssemblyStateCreateInfo<'s>> for vks::VkPipelineInputAssemblyStateCreateInfo {
    fn from(f: PipelineInputAssemblyStateCreateInfo<'s>) -> vks::VkPipelineInputAssemblyStateCreateInfo {
        f.raw
    }
}


/// A builder for `VkPipelineInputAssemblyStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineInputAssemblyStateCreateInfoBuilder<'b> {
    raw: vks::VkPipelineInputAssemblyStateCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineInputAssemblyStateCreateInfoBuilder<'b> {
    pub fn new() -> PipelineInputAssemblyStateCreateInfoBuilder<'b> {
        PipelineInputAssemblyStateCreateInfoBuilder {
            raw: vks::VkPipelineInputAssemblyStateCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineInputAssemblyStateCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineInputAssemblyStateCreateFlags) -> PipelineInputAssemblyStateCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn topology<'m>(mut self, topology: PrimitiveTopology) -> PipelineInputAssemblyStateCreateInfoBuilder<'b> {
        self.raw.topology = topology.into();
        self
    }

    pub fn primitive_restart_enable<'m>(mut self, primitive_restart_enable: bool) -> PipelineInputAssemblyStateCreateInfoBuilder<'b> {
        self.raw.primitiveRestartEnable = primitive_restart_enable as u32;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> PipelineInputAssemblyStateCreateFlags {
        PipelineInputAssemblyStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineInputAssemblyStateCreateInfo::flags: error converting flags")
    }

    pub fn get_topology<'a>(&'a self) -> PrimitiveTopology {
        self.raw.topology.into()
    }

    pub fn get_primitive_restart_enable<'a>(&'a self) -> bool {
        self.raw.primitiveRestartEnable != 0
    }

    pub fn build(self) -> PipelineInputAssemblyStateCreateInfo<'b> {
        PipelineInputAssemblyStateCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineTessellationStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineTessellationStateCreateInfo<'s> {
    raw: vks::VkPipelineTessellationStateCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineTessellationStateCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineTessellationStateCreateInfoBuilder<'b> {
        PipelineTessellationStateCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineTessellationStateCreateInfo) -> PipelineTessellationStateCreateInfo<'s> {
        PipelineTessellationStateCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineTessellationStateCreateFlags {
        PipelineTessellationStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineTessellationStateCreateInfo::flags: error converting flags")
    }

    pub fn patch_control_points<'a>(&'a self) -> u32 {
        self.raw.patchControlPoints.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineTessellationStateCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_patch_control_points<'m>(&mut self, patch_control_points: u32) {
        self.raw.patchControlPoints = patch_control_points.into();
    }

    pub fn as_raw(&self) -> &vks::VkPipelineTessellationStateCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineTessellationStateCreateInfo<'s>> for vks::VkPipelineTessellationStateCreateInfo {
    fn from(f: PipelineTessellationStateCreateInfo<'s>) -> vks::VkPipelineTessellationStateCreateInfo {
        f.raw
    }
}


/// A builder for `VkPipelineTessellationStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineTessellationStateCreateInfoBuilder<'b> {
    raw: vks::VkPipelineTessellationStateCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineTessellationStateCreateInfoBuilder<'b> {
    pub fn new() -> PipelineTessellationStateCreateInfoBuilder<'b> {
        PipelineTessellationStateCreateInfoBuilder {
            raw: vks::VkPipelineTessellationStateCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineTessellationStateCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineTessellationStateCreateFlags) -> PipelineTessellationStateCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn patch_control_points<'m>(mut self, patch_control_points: u32) -> PipelineTessellationStateCreateInfoBuilder<'b> {
        self.raw.patchControlPoints = patch_control_points.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> PipelineTessellationStateCreateFlags {
        PipelineTessellationStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineTessellationStateCreateInfo::flags: error converting flags")
    }

    pub fn get_patch_control_points<'a>(&'a self) -> u32 {
        self.raw.patchControlPoints.into()
    }

    pub fn build(self) -> PipelineTessellationStateCreateInfo<'b> {
        PipelineTessellationStateCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineViewportStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineViewportStateCreateInfo<'s> {
    raw: vks::VkPipelineViewportStateCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineViewportStateCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineViewportStateCreateInfoBuilder<'b> {
        PipelineViewportStateCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineViewportStateCreateInfo) -> PipelineViewportStateCreateInfo<'s> {
        PipelineViewportStateCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineViewportStateCreateFlags {
        PipelineViewportStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineViewportStateCreateInfo::flags: error converting flags")
    }

    pub fn viewports<'a>(&'a self) -> &'a [Viewport] {
        unsafe { slice::from_raw_parts(self.raw.pViewports as *const _, self.raw.viewportCount as usize) }
    }

    pub fn scissors<'a>(&'a self) -> &'a [Rect2d] {
        unsafe { slice::from_raw_parts(self.raw.pScissors as *const _, self.raw.scissorCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineViewportStateCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_viewports<'m, 'a>(&mut self, viewports: &'a [Viewport])
            where 'a: 's {
        assert!(self.raw.viewportCount == 0 || self.raw.viewportCount == viewports.len() as _, 
            "count inconsistency found when specifying `PipelineViewportStateCreateInfo::viewports`.");
        self.raw.viewportCount = viewports.len() as _;
        self.raw.pViewports = viewports.as_ptr() as *const vks::VkViewport;
    }

    pub fn set_scissors<'m, 'a>(&mut self, scissors: &'a [Rect2d])
            where 'a: 's {
        assert!(self.raw.scissorCount == 0 || self.raw.scissorCount == scissors.len() as _, 
            "count inconsistency found when specifying `PipelineViewportStateCreateInfo::scissors`.");
        self.raw.scissorCount = scissors.len() as _;
        self.raw.pScissors = scissors.as_ptr() as *const vks::VkRect2D;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineViewportStateCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineViewportStateCreateInfo<'s>> for vks::VkPipelineViewportStateCreateInfo {
    fn from(f: PipelineViewportStateCreateInfo<'s>) -> vks::VkPipelineViewportStateCreateInfo {
        f.raw
    }
}


/// A builder for `VkPipelineViewportStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineViewportStateCreateInfoBuilder<'b> {
    raw: vks::VkPipelineViewportStateCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineViewportStateCreateInfoBuilder<'b> {
    pub fn new() -> PipelineViewportStateCreateInfoBuilder<'b> {
        PipelineViewportStateCreateInfoBuilder {
            raw: vks::VkPipelineViewportStateCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineViewportStateCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineViewportStateCreateFlags) -> PipelineViewportStateCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn viewports<'m, 'a>(mut self, viewports: &'a [Viewport]) -> PipelineViewportStateCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.viewportCount == 0 || self.raw.viewportCount == viewports.len() as _, 
            "count inconsistency found when specifying `PipelineViewportStateCreateInfo::viewports`.");
        self.raw.viewportCount = viewports.len() as _;
        self.raw.pViewports = viewports.as_ptr() as *const vks::VkViewport;
        self
    }

    pub fn scissors<'m, 'a>(mut self, scissors: &'a [Rect2d]) -> PipelineViewportStateCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.scissorCount == 0 || self.raw.scissorCount == scissors.len() as _, 
            "count inconsistency found when specifying `PipelineViewportStateCreateInfo::scissors`.");
        self.raw.scissorCount = scissors.len() as _;
        self.raw.pScissors = scissors.as_ptr() as *const vks::VkRect2D;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> PipelineViewportStateCreateFlags {
        PipelineViewportStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineViewportStateCreateInfo::flags: error converting flags")
    }

    pub fn get_viewports<'a>(&'a self) -> &'a [Viewport] {
        unsafe { slice::from_raw_parts(self.raw.pViewports as *const _, self.raw.viewportCount as usize) }
    }

    pub fn get_scissors<'a>(&'a self) -> &'a [Rect2d] {
        unsafe { slice::from_raw_parts(self.raw.pScissors as *const _, self.raw.scissorCount as usize) }
    }

    pub fn build(self) -> PipelineViewportStateCreateInfo<'b> {
        PipelineViewportStateCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineRasterizationStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineRasterizationStateCreateInfo<'s> {
    raw: vks::VkPipelineRasterizationStateCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineRasterizationStateCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        PipelineRasterizationStateCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineRasterizationStateCreateInfo) -> PipelineRasterizationStateCreateInfo<'s> {
        PipelineRasterizationStateCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineRasterizationStateCreateFlags {
        PipelineRasterizationStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineRasterizationStateCreateInfo::flags: error converting flags")
    }

    pub fn depth_clamp_enable<'a>(&'a self) -> bool {
        self.raw.depthClampEnable != 0
    }

    pub fn rasterizer_discard_enable<'a>(&'a self) -> bool {
        self.raw.rasterizerDiscardEnable != 0
    }

    pub fn polygon_mode<'a>(&'a self) -> PolygonMode {
        self.raw.polygonMode.into()
    }

    pub fn cull_mode<'a>(&'a self) -> CullModeFlags {
        CullModeFlags::from_bits(self.raw.cullMode)
            .expect("PipelineRasterizationStateCreateInfo::cull_mode: error converting flags")
    }

    pub fn front_face<'a>(&'a self) -> FrontFace {
        self.raw.frontFace.into()
    }

    pub fn depth_bias_enable<'a>(&'a self) -> bool {
        self.raw.depthBiasEnable != 0
    }

    pub fn depth_bias_constant_factor<'a>(&'a self) -> f32 {
        self.raw.depthBiasConstantFactor.into()
    }

    pub fn depth_bias_clamp<'a>(&'a self) -> f32 {
        self.raw.depthBiasClamp.into()
    }

    pub fn depth_bias_slope_factor<'a>(&'a self) -> f32 {
        self.raw.depthBiasSlopeFactor.into()
    }

    pub fn line_width<'a>(&'a self) -> f32 {
        self.raw.lineWidth.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineRasterizationStateCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_depth_clamp_enable<'m>(&mut self, depth_clamp_enable: bool) {
        self.raw.depthClampEnable = depth_clamp_enable as u32;
    }

    pub fn set_rasterizer_discard_enable<'m>(&mut self, rasterizer_discard_enable: bool) {
        self.raw.rasterizerDiscardEnable = rasterizer_discard_enable as u32;
    }

    pub fn set_polygon_mode<'m>(&mut self, polygon_mode: PolygonMode) {
        self.raw.polygonMode = polygon_mode.into();
    }

    pub fn set_cull_mode<'m>(&mut self, cull_mode: CullModeFlags) {
        self.raw.cullMode = cull_mode.bits();
    }

    pub fn set_front_face<'m>(&mut self, front_face: FrontFace) {
        self.raw.frontFace = front_face.into();
    }

    pub fn set_depth_bias_enable<'m>(&mut self, depth_bias_enable: bool) {
        self.raw.depthBiasEnable = depth_bias_enable as u32;
    }

    pub fn set_depth_bias_constant_factor<'m>(&mut self, depth_bias_constant_factor: f32) {
        self.raw.depthBiasConstantFactor = depth_bias_constant_factor.into();
    }

    pub fn set_depth_bias_clamp<'m>(&mut self, depth_bias_clamp: f32) {
        self.raw.depthBiasClamp = depth_bias_clamp.into();
    }

    pub fn set_depth_bias_slope_factor<'m>(&mut self, depth_bias_slope_factor: f32) {
        self.raw.depthBiasSlopeFactor = depth_bias_slope_factor.into();
    }

    pub fn set_line_width<'m>(&mut self, line_width: f32) {
        self.raw.lineWidth = line_width.into();
    }

    pub fn as_raw(&self) -> &vks::VkPipelineRasterizationStateCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineRasterizationStateCreateInfo<'s>> for vks::VkPipelineRasterizationStateCreateInfo {
    fn from(f: PipelineRasterizationStateCreateInfo<'s>) -> vks::VkPipelineRasterizationStateCreateInfo {
        f.raw
    }
}


/// A builder for `VkPipelineRasterizationStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineRasterizationStateCreateInfoBuilder<'b> {
    raw: vks::VkPipelineRasterizationStateCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineRasterizationStateCreateInfoBuilder<'b> {
    pub fn new() -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        PipelineRasterizationStateCreateInfoBuilder {
            raw: vks::VkPipelineRasterizationStateCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineRasterizationStateCreateFlags) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn depth_clamp_enable<'m>(mut self, depth_clamp_enable: bool) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.depthClampEnable = depth_clamp_enable as u32;
        self
    }

    pub fn rasterizer_discard_enable<'m>(mut self, rasterizer_discard_enable: bool) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.rasterizerDiscardEnable = rasterizer_discard_enable as u32;
        self
    }

    pub fn polygon_mode<'m>(mut self, polygon_mode: PolygonMode) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.polygonMode = polygon_mode.into();
        self
    }

    pub fn cull_mode<'m>(mut self, cull_mode: CullModeFlags) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.cullMode = cull_mode.bits();
        self
    }

    pub fn front_face<'m>(mut self, front_face: FrontFace) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.frontFace = front_face.into();
        self
    }

    pub fn depth_bias_enable<'m>(mut self, depth_bias_enable: bool) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.depthBiasEnable = depth_bias_enable as u32;
        self
    }

    pub fn depth_bias_constant_factor<'m>(mut self, depth_bias_constant_factor: f32) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.depthBiasConstantFactor = depth_bias_constant_factor.into();
        self
    }

    pub fn depth_bias_clamp<'m>(mut self, depth_bias_clamp: f32) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.depthBiasClamp = depth_bias_clamp.into();
        self
    }

    pub fn depth_bias_slope_factor<'m>(mut self, depth_bias_slope_factor: f32) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.depthBiasSlopeFactor = depth_bias_slope_factor.into();
        self
    }

    pub fn line_width<'m>(mut self, line_width: f32) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.lineWidth = line_width.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> PipelineRasterizationStateCreateFlags {
        PipelineRasterizationStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineRasterizationStateCreateInfo::flags: error converting flags")
    }

    pub fn get_depth_clamp_enable<'a>(&'a self) -> bool {
        self.raw.depthClampEnable != 0
    }

    pub fn get_rasterizer_discard_enable<'a>(&'a self) -> bool {
        self.raw.rasterizerDiscardEnable != 0
    }

    pub fn get_polygon_mode<'a>(&'a self) -> PolygonMode {
        self.raw.polygonMode.into()
    }

    pub fn get_cull_mode<'a>(&'a self) -> CullModeFlags {
        CullModeFlags::from_bits(self.raw.cullMode)
            .expect("PipelineRasterizationStateCreateInfo::cull_mode: error converting flags")
    }

    pub fn get_front_face<'a>(&'a self) -> FrontFace {
        self.raw.frontFace.into()
    }

    pub fn get_depth_bias_enable<'a>(&'a self) -> bool {
        self.raw.depthBiasEnable != 0
    }

    pub fn get_depth_bias_constant_factor<'a>(&'a self) -> f32 {
        self.raw.depthBiasConstantFactor.into()
    }

    pub fn get_depth_bias_clamp<'a>(&'a self) -> f32 {
        self.raw.depthBiasClamp.into()
    }

    pub fn get_depth_bias_slope_factor<'a>(&'a self) -> f32 {
        self.raw.depthBiasSlopeFactor.into()
    }

    pub fn get_line_width<'a>(&'a self) -> f32 {
        self.raw.lineWidth.into()
    }

    pub fn build(self) -> PipelineRasterizationStateCreateInfo<'b> {
        PipelineRasterizationStateCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineMultisampleStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineMultisampleStateCreateInfo<'s> {
    raw: vks::VkPipelineMultisampleStateCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineMultisampleStateCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        PipelineMultisampleStateCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineMultisampleStateCreateInfo) -> PipelineMultisampleStateCreateInfo<'s> {
        PipelineMultisampleStateCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineMultisampleStateCreateFlags {
        PipelineMultisampleStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineMultisampleStateCreateInfo::flags: error converting flags")
    }

    pub fn rasterization_samples<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.rasterizationSamples)
            .expect("PipelineMultisampleStateCreateInfo::rasterization_samples: error converting flags")
    }

    pub fn sample_shading_enable<'a>(&'a self) -> bool {
        self.raw.sampleShadingEnable != 0
    }

    pub fn min_sample_shading<'a>(&'a self) -> f32 {
        self.raw.minSampleShading.into()
    }

    pub fn sample_mask<'a>(&'a self) -> &'a u32 {
        unsafe { &*(self.raw.pSampleMask as *const _) }
    }

    pub fn alpha_to_coverage_enable<'a>(&'a self) -> bool {
        self.raw.alphaToCoverageEnable != 0
    }

    pub fn alpha_to_one_enable<'a>(&'a self) -> bool {
        self.raw.alphaToOneEnable != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineMultisampleStateCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_rasterization_samples<'m>(&mut self, rasterization_samples: SampleCountFlags) {
        self.raw.rasterizationSamples = rasterization_samples.bits();
    }

    pub fn set_sample_shading_enable<'m>(&mut self, sample_shading_enable: bool) {
        self.raw.sampleShadingEnable = sample_shading_enable as u32;
    }

    pub fn set_min_sample_shading<'m>(&mut self, min_sample_shading: f32) {
        self.raw.minSampleShading = min_sample_shading.into();
    }

    pub fn set_sample_mask<'m, 'a>(&mut self, sample_mask: &'a u32) {
        self.raw.pSampleMask = sample_mask;
    }

    pub fn set_alpha_to_coverage_enable<'m>(&mut self, alpha_to_coverage_enable: bool) {
        self.raw.alphaToCoverageEnable = alpha_to_coverage_enable as u32;
    }

    pub fn set_alpha_to_one_enable<'m>(&mut self, alpha_to_one_enable: bool) {
        self.raw.alphaToOneEnable = alpha_to_one_enable as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineMultisampleStateCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineMultisampleStateCreateInfo<'s>> for vks::VkPipelineMultisampleStateCreateInfo {
    fn from(f: PipelineMultisampleStateCreateInfo<'s>) -> vks::VkPipelineMultisampleStateCreateInfo {
        f.raw
    }
}


/// A builder for `VkPipelineMultisampleStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineMultisampleStateCreateInfoBuilder<'b> {
    raw: vks::VkPipelineMultisampleStateCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineMultisampleStateCreateInfoBuilder<'b> {
    pub fn new() -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        PipelineMultisampleStateCreateInfoBuilder {
            raw: vks::VkPipelineMultisampleStateCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineMultisampleStateCreateFlags) -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn rasterization_samples<'m>(mut self, rasterization_samples: SampleCountFlags) -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        self.raw.rasterizationSamples = rasterization_samples.bits();
        self
    }

    pub fn sample_shading_enable<'m>(mut self, sample_shading_enable: bool) -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        self.raw.sampleShadingEnable = sample_shading_enable as u32;
        self
    }

    pub fn min_sample_shading<'m>(mut self, min_sample_shading: f32) -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        self.raw.minSampleShading = min_sample_shading.into();
        self
    }

    pub fn sample_mask<'m, 'a>(mut self, sample_mask: &'a u32) -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        self.raw.pSampleMask = sample_mask;
        self
    }

    pub fn alpha_to_coverage_enable<'m>(mut self, alpha_to_coverage_enable: bool) -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        self.raw.alphaToCoverageEnable = alpha_to_coverage_enable as u32;
        self
    }

    pub fn alpha_to_one_enable<'m>(mut self, alpha_to_one_enable: bool) -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        self.raw.alphaToOneEnable = alpha_to_one_enable as u32;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> PipelineMultisampleStateCreateFlags {
        PipelineMultisampleStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineMultisampleStateCreateInfo::flags: error converting flags")
    }

    pub fn get_rasterization_samples<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.rasterizationSamples)
            .expect("PipelineMultisampleStateCreateInfo::rasterization_samples: error converting flags")
    }

    pub fn get_sample_shading_enable<'a>(&'a self) -> bool {
        self.raw.sampleShadingEnable != 0
    }

    pub fn get_min_sample_shading<'a>(&'a self) -> f32 {
        self.raw.minSampleShading.into()
    }

    pub fn get_sample_mask<'a>(&'a self) -> &'a u32 {
        unsafe { &*(self.raw.pSampleMask as *const _) }
    }

    pub fn get_alpha_to_coverage_enable<'a>(&'a self) -> bool {
        self.raw.alphaToCoverageEnable != 0
    }

    pub fn get_alpha_to_one_enable<'a>(&'a self) -> bool {
        self.raw.alphaToOneEnable != 0
    }

    pub fn build(self) -> PipelineMultisampleStateCreateInfo<'b> {
        PipelineMultisampleStateCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineColorBlendAttachmentState`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineColorBlendAttachmentState {
    raw: vks::VkPipelineColorBlendAttachmentState,
}

impl PipelineColorBlendAttachmentState {
    pub fn builder() -> PipelineColorBlendAttachmentStateBuilder {
        PipelineColorBlendAttachmentStateBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineColorBlendAttachmentState) -> PipelineColorBlendAttachmentState {
        PipelineColorBlendAttachmentState { raw, }
    }

    pub fn blend_enable<'a>(&'a self) -> bool {
        self.raw.blendEnable != 0
    }

    pub fn src_color_blend_factor<'a>(&'a self) -> BlendFactor {
        self.raw.srcColorBlendFactor.into()
    }

    pub fn dst_color_blend_factor<'a>(&'a self) -> BlendFactor {
        self.raw.dstColorBlendFactor.into()
    }

    pub fn color_blend_op<'a>(&'a self) -> BlendOp {
        self.raw.colorBlendOp.into()
    }

    pub fn src_alpha_blend_factor<'a>(&'a self) -> BlendFactor {
        self.raw.srcAlphaBlendFactor.into()
    }

    pub fn dst_alpha_blend_factor<'a>(&'a self) -> BlendFactor {
        self.raw.dstAlphaBlendFactor.into()
    }

    pub fn alpha_blend_op<'a>(&'a self) -> BlendOp {
        self.raw.alphaBlendOp.into()
    }

    pub fn color_write_mask<'a>(&'a self) -> ColorComponentFlags {
        ColorComponentFlags::from_bits(self.raw.colorWriteMask)
            .expect("PipelineColorBlendAttachmentState::color_write_mask: error converting flags")
    }

    pub fn set_blend_enable<'m>(&mut self, blend_enable: bool) {
        self.raw.blendEnable = blend_enable as u32;
    }

    pub fn set_src_color_blend_factor<'m>(&mut self, src_color_blend_factor: BlendFactor) {
        self.raw.srcColorBlendFactor = src_color_blend_factor.into();
    }

    pub fn set_dst_color_blend_factor<'m>(&mut self, dst_color_blend_factor: BlendFactor) {
        self.raw.dstColorBlendFactor = dst_color_blend_factor.into();
    }

    pub fn set_color_blend_op<'m>(&mut self, color_blend_op: BlendOp) {
        self.raw.colorBlendOp = color_blend_op.into();
    }

    pub fn set_src_alpha_blend_factor<'m>(&mut self, src_alpha_blend_factor: BlendFactor) {
        self.raw.srcAlphaBlendFactor = src_alpha_blend_factor.into();
    }

    pub fn set_dst_alpha_blend_factor<'m>(&mut self, dst_alpha_blend_factor: BlendFactor) {
        self.raw.dstAlphaBlendFactor = dst_alpha_blend_factor.into();
    }

    pub fn set_alpha_blend_op<'m>(&mut self, alpha_blend_op: BlendOp) {
        self.raw.alphaBlendOp = alpha_blend_op.into();
    }

    pub fn set_color_write_mask<'m>(&mut self, color_write_mask: ColorComponentFlags) {
        self.raw.colorWriteMask = color_write_mask.bits();
    }

    pub fn as_raw(&self) -> &vks::VkPipelineColorBlendAttachmentState {
        &self.raw
    }
}

impl From<PipelineColorBlendAttachmentState> for vks::VkPipelineColorBlendAttachmentState {
    fn from(f: PipelineColorBlendAttachmentState) -> vks::VkPipelineColorBlendAttachmentState {
        f.raw
    }
}


/// A builder for `VkPipelineColorBlendAttachmentState`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineColorBlendAttachmentStateBuilder {
    raw: vks::VkPipelineColorBlendAttachmentState,
}

impl PipelineColorBlendAttachmentStateBuilder {
    pub fn new() -> PipelineColorBlendAttachmentStateBuilder {
        PipelineColorBlendAttachmentStateBuilder {
            raw: vks::VkPipelineColorBlendAttachmentState::default(),
        }
    }

    pub fn blend_enable<'m>(mut self, blend_enable: bool) -> PipelineColorBlendAttachmentStateBuilder {
        self.raw.blendEnable = blend_enable as u32;
        self
    }

    pub fn src_color_blend_factor<'m>(mut self, src_color_blend_factor: BlendFactor) -> PipelineColorBlendAttachmentStateBuilder {
        self.raw.srcColorBlendFactor = src_color_blend_factor.into();
        self
    }

    pub fn dst_color_blend_factor<'m>(mut self, dst_color_blend_factor: BlendFactor) -> PipelineColorBlendAttachmentStateBuilder {
        self.raw.dstColorBlendFactor = dst_color_blend_factor.into();
        self
    }

    pub fn color_blend_op<'m>(mut self, color_blend_op: BlendOp) -> PipelineColorBlendAttachmentStateBuilder {
        self.raw.colorBlendOp = color_blend_op.into();
        self
    }

    pub fn src_alpha_blend_factor<'m>(mut self, src_alpha_blend_factor: BlendFactor) -> PipelineColorBlendAttachmentStateBuilder {
        self.raw.srcAlphaBlendFactor = src_alpha_blend_factor.into();
        self
    }

    pub fn dst_alpha_blend_factor<'m>(mut self, dst_alpha_blend_factor: BlendFactor) -> PipelineColorBlendAttachmentStateBuilder {
        self.raw.dstAlphaBlendFactor = dst_alpha_blend_factor.into();
        self
    }

    pub fn alpha_blend_op<'m>(mut self, alpha_blend_op: BlendOp) -> PipelineColorBlendAttachmentStateBuilder {
        self.raw.alphaBlendOp = alpha_blend_op.into();
        self
    }

    pub fn color_write_mask<'m>(mut self, color_write_mask: ColorComponentFlags) -> PipelineColorBlendAttachmentStateBuilder {
        self.raw.colorWriteMask = color_write_mask.bits();
        self
    }

    pub fn get_blend_enable<'a>(&'a self) -> bool {
        self.raw.blendEnable != 0
    }

    pub fn get_src_color_blend_factor<'a>(&'a self) -> BlendFactor {
        self.raw.srcColorBlendFactor.into()
    }

    pub fn get_dst_color_blend_factor<'a>(&'a self) -> BlendFactor {
        self.raw.dstColorBlendFactor.into()
    }

    pub fn get_color_blend_op<'a>(&'a self) -> BlendOp {
        self.raw.colorBlendOp.into()
    }

    pub fn get_src_alpha_blend_factor<'a>(&'a self) -> BlendFactor {
        self.raw.srcAlphaBlendFactor.into()
    }

    pub fn get_dst_alpha_blend_factor<'a>(&'a self) -> BlendFactor {
        self.raw.dstAlphaBlendFactor.into()
    }

    pub fn get_alpha_blend_op<'a>(&'a self) -> BlendOp {
        self.raw.alphaBlendOp.into()
    }

    pub fn get_color_write_mask<'a>(&'a self) -> ColorComponentFlags {
        ColorComponentFlags::from_bits(self.raw.colorWriteMask)
            .expect("PipelineColorBlendAttachmentState::color_write_mask: error converting flags")
    }

    pub fn build(self) -> PipelineColorBlendAttachmentState {
        PipelineColorBlendAttachmentState {
            raw: self.raw,
        }
    }
}


/// A `VkPipelineColorBlendStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineColorBlendStateCreateInfo<'s> {
    raw: vks::VkPipelineColorBlendStateCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineColorBlendStateCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineColorBlendStateCreateInfoBuilder<'b> {
        PipelineColorBlendStateCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineColorBlendStateCreateInfo) -> PipelineColorBlendStateCreateInfo<'s> {
        PipelineColorBlendStateCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineColorBlendStateCreateFlags {
        PipelineColorBlendStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineColorBlendStateCreateInfo::flags: error converting flags")
    }

    pub fn logic_op_enable<'a>(&'a self) -> bool {
        self.raw.logicOpEnable != 0
    }

    pub fn logic_op<'a>(&'a self) -> LogicOp {
        self.raw.logicOp.into()
    }

    pub fn attachments<'a>(&'a self) -> &'a [PipelineColorBlendAttachmentState] {
        unsafe { slice::from_raw_parts(self.raw.pAttachments as *const _, self.raw.attachmentCount as usize) }
    }

    pub fn blend_constants<'a>(&'a self) -> &[f32] {
        unsafe { slice::from_raw_parts(&self.raw.blendConstants as *const _, 4 as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineColorBlendStateCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_logic_op_enable<'m>(&mut self, logic_op_enable: bool) {
        self.raw.logicOpEnable = logic_op_enable as u32;
    }

    pub fn set_logic_op<'m>(&mut self, logic_op: LogicOp) {
        self.raw.logicOp = logic_op.into();
    }

    pub fn set_attachments<'m, 'a>(&mut self, attachments: &'a [PipelineColorBlendAttachmentState])
            where 'a: 's {
        assert!(self.raw.attachmentCount == 0 || self.raw.attachmentCount == attachments.len() as _, 
            "count inconsistency found when specifying `PipelineColorBlendStateCreateInfo::attachments`.");
        self.raw.attachmentCount = attachments.len() as _;
        self.raw.pAttachments = attachments.as_ptr() as *const vks::VkPipelineColorBlendAttachmentState;
    }

    pub fn set_blend_constants<'m>(&mut self, blend_constants: [f32; 4]) {
        self.raw.blendConstants = blend_constants;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineColorBlendStateCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineColorBlendStateCreateInfo<'s>> for vks::VkPipelineColorBlendStateCreateInfo {
    fn from(f: PipelineColorBlendStateCreateInfo<'s>) -> vks::VkPipelineColorBlendStateCreateInfo {
        f.raw
    }
}


/// A builder for `VkPipelineColorBlendStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineColorBlendStateCreateInfoBuilder<'b> {
    raw: vks::VkPipelineColorBlendStateCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineColorBlendStateCreateInfoBuilder<'b> {
    pub fn new() -> PipelineColorBlendStateCreateInfoBuilder<'b> {
        PipelineColorBlendStateCreateInfoBuilder {
            raw: vks::VkPipelineColorBlendStateCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineColorBlendStateCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineColorBlendStateCreateFlags) -> PipelineColorBlendStateCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn logic_op_enable<'m>(mut self, logic_op_enable: bool) -> PipelineColorBlendStateCreateInfoBuilder<'b> {
        self.raw.logicOpEnable = logic_op_enable as u32;
        self
    }

    pub fn logic_op<'m>(mut self, logic_op: LogicOp) -> PipelineColorBlendStateCreateInfoBuilder<'b> {
        self.raw.logicOp = logic_op.into();
        self
    }

    pub fn attachments<'m, 'a>(mut self, attachments: &'a [PipelineColorBlendAttachmentState]) -> PipelineColorBlendStateCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.attachmentCount == 0 || self.raw.attachmentCount == attachments.len() as _, 
            "count inconsistency found when specifying `PipelineColorBlendStateCreateInfo::attachments`.");
        self.raw.attachmentCount = attachments.len() as _;
        self.raw.pAttachments = attachments.as_ptr() as *const vks::VkPipelineColorBlendAttachmentState;
        self
    }

    pub fn blend_constants<'m>(mut self, blend_constants: [f32; 4]) -> PipelineColorBlendStateCreateInfoBuilder<'b> {
        self.raw.blendConstants = blend_constants;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> PipelineColorBlendStateCreateFlags {
        PipelineColorBlendStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineColorBlendStateCreateInfo::flags: error converting flags")
    }

    pub fn get_logic_op_enable<'a>(&'a self) -> bool {
        self.raw.logicOpEnable != 0
    }

    pub fn get_logic_op<'a>(&'a self) -> LogicOp {
        self.raw.logicOp.into()
    }

    pub fn get_attachments<'a>(&'a self) -> &'a [PipelineColorBlendAttachmentState] {
        unsafe { slice::from_raw_parts(self.raw.pAttachments as *const _, self.raw.attachmentCount as usize) }
    }

    pub fn get_blend_constants<'a>(&'a self) -> &[f32] {
        unsafe { slice::from_raw_parts(&self.raw.blendConstants as *const _, 4 as usize) }
    }

    pub fn build(self) -> PipelineColorBlendStateCreateInfo<'b> {
        PipelineColorBlendStateCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineDynamicStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineDynamicStateCreateInfo<'s> {
    raw: vks::VkPipelineDynamicStateCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineDynamicStateCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineDynamicStateCreateInfoBuilder<'b> {
        PipelineDynamicStateCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineDynamicStateCreateInfo) -> PipelineDynamicStateCreateInfo<'s> {
        PipelineDynamicStateCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineDynamicStateCreateFlags {
        PipelineDynamicStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineDynamicStateCreateInfo::flags: error converting flags")
    }

    pub fn dynamic_states<'a>(&'a self) -> &'a [DynamicState] {
        unsafe { slice::from_raw_parts(self.raw.pDynamicStates as *const _, self.raw.dynamicStateCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineDynamicStateCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_dynamic_states<'m, 'a>(&mut self, dynamic_states: &'a [DynamicState])
            where 'a: 's {
        assert!(self.raw.dynamicStateCount == 0 || self.raw.dynamicStateCount == dynamic_states.len() as _, 
            "count inconsistency found when specifying `PipelineDynamicStateCreateInfo::dynamic_states`.");
        self.raw.dynamicStateCount = dynamic_states.len() as _;
        self.raw.pDynamicStates = dynamic_states.as_ptr() as *const DynamicState as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineDynamicStateCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineDynamicStateCreateInfo<'s>> for vks::VkPipelineDynamicStateCreateInfo {
    fn from(f: PipelineDynamicStateCreateInfo<'s>) -> vks::VkPipelineDynamicStateCreateInfo {
        f.raw
    }
}


/// A builder for `VkPipelineDynamicStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineDynamicStateCreateInfoBuilder<'b> {
    raw: vks::VkPipelineDynamicStateCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineDynamicStateCreateInfoBuilder<'b> {
    pub fn new() -> PipelineDynamicStateCreateInfoBuilder<'b> {
        PipelineDynamicStateCreateInfoBuilder {
            raw: vks::VkPipelineDynamicStateCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineDynamicStateCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineDynamicStateCreateFlags) -> PipelineDynamicStateCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn dynamic_states<'m, 'a>(mut self, dynamic_states: &'a [DynamicState]) -> PipelineDynamicStateCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.dynamicStateCount == 0 || self.raw.dynamicStateCount == dynamic_states.len() as _, 
            "count inconsistency found when specifying `PipelineDynamicStateCreateInfo::dynamic_states`.");
        self.raw.dynamicStateCount = dynamic_states.len() as _;
        self.raw.pDynamicStates = dynamic_states.as_ptr() as *const DynamicState as *const _;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> PipelineDynamicStateCreateFlags {
        PipelineDynamicStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineDynamicStateCreateInfo::flags: error converting flags")
    }

    pub fn get_dynamic_states<'a>(&'a self) -> &'a [DynamicState] {
        unsafe { slice::from_raw_parts(self.raw.pDynamicStates as *const _, self.raw.dynamicStateCount as usize) }
    }

    pub fn build(self) -> PipelineDynamicStateCreateInfo<'b> {
        PipelineDynamicStateCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkStencilOpState`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct StencilOpState {
    raw: vks::VkStencilOpState,
}

impl StencilOpState {
    pub fn builder() -> StencilOpStateBuilder {
        StencilOpStateBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkStencilOpState) -> StencilOpState {
        StencilOpState { raw, }
    }

    pub fn fail_op<'a>(&'a self) -> StencilOp {
        self.raw.failOp.into()
    }

    pub fn pass_op<'a>(&'a self) -> StencilOp {
        self.raw.passOp.into()
    }

    pub fn depth_fail_op<'a>(&'a self) -> StencilOp {
        self.raw.depthFailOp.into()
    }

    pub fn compare_op<'a>(&'a self) -> CompareOp {
        self.raw.compareOp.into()
    }

    pub fn compare_mask<'a>(&'a self) -> u32 {
        self.raw.compareMask.into()
    }

    pub fn write_mask<'a>(&'a self) -> u32 {
        self.raw.writeMask.into()
    }

    pub fn reference<'a>(&'a self) -> u32 {
        self.raw.reference.into()
    }

    pub fn set_fail_op<'m>(&mut self, fail_op: StencilOp) {
        self.raw.failOp = fail_op.into();
    }

    pub fn set_pass_op<'m>(&mut self, pass_op: StencilOp) {
        self.raw.passOp = pass_op.into();
    }

    pub fn set_depth_fail_op<'m>(&mut self, depth_fail_op: StencilOp) {
        self.raw.depthFailOp = depth_fail_op.into();
    }

    pub fn set_compare_op<'m>(&mut self, compare_op: CompareOp) {
        self.raw.compareOp = compare_op.into();
    }

    pub fn set_compare_mask<'m>(&mut self, compare_mask: u32) {
        self.raw.compareMask = compare_mask.into();
    }

    pub fn set_write_mask<'m>(&mut self, write_mask: u32) {
        self.raw.writeMask = write_mask.into();
    }

    pub fn set_reference<'m>(&mut self, reference: u32) {
        self.raw.reference = reference.into();
    }

    pub fn as_raw(&self) -> &vks::VkStencilOpState {
        &self.raw
    }
}

impl From<StencilOpState> for vks::VkStencilOpState {
    fn from(f: StencilOpState) -> vks::VkStencilOpState {
        f.raw
    }
}


/// A builder for `VkStencilOpState`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct StencilOpStateBuilder {
    raw: vks::VkStencilOpState,
}

impl StencilOpStateBuilder {
    pub fn new() -> StencilOpStateBuilder {
        StencilOpStateBuilder {
            raw: vks::VkStencilOpState::default(),
        }
    }

    pub fn fail_op<'m>(mut self, fail_op: StencilOp) -> StencilOpStateBuilder {
        self.raw.failOp = fail_op.into();
        self
    }

    pub fn pass_op<'m>(mut self, pass_op: StencilOp) -> StencilOpStateBuilder {
        self.raw.passOp = pass_op.into();
        self
    }

    pub fn depth_fail_op<'m>(mut self, depth_fail_op: StencilOp) -> StencilOpStateBuilder {
        self.raw.depthFailOp = depth_fail_op.into();
        self
    }

    pub fn compare_op<'m>(mut self, compare_op: CompareOp) -> StencilOpStateBuilder {
        self.raw.compareOp = compare_op.into();
        self
    }

    pub fn compare_mask<'m>(mut self, compare_mask: u32) -> StencilOpStateBuilder {
        self.raw.compareMask = compare_mask.into();
        self
    }

    pub fn write_mask<'m>(mut self, write_mask: u32) -> StencilOpStateBuilder {
        self.raw.writeMask = write_mask.into();
        self
    }

    pub fn reference<'m>(mut self, reference: u32) -> StencilOpStateBuilder {
        self.raw.reference = reference.into();
        self
    }

    pub fn get_fail_op<'a>(&'a self) -> StencilOp {
        self.raw.failOp.into()
    }

    pub fn get_pass_op<'a>(&'a self) -> StencilOp {
        self.raw.passOp.into()
    }

    pub fn get_depth_fail_op<'a>(&'a self) -> StencilOp {
        self.raw.depthFailOp.into()
    }

    pub fn get_compare_op<'a>(&'a self) -> CompareOp {
        self.raw.compareOp.into()
    }

    pub fn get_compare_mask<'a>(&'a self) -> u32 {
        self.raw.compareMask.into()
    }

    pub fn get_write_mask<'a>(&'a self) -> u32 {
        self.raw.writeMask.into()
    }

    pub fn get_reference<'a>(&'a self) -> u32 {
        self.raw.reference.into()
    }

    pub fn build(self) -> StencilOpState {
        StencilOpState {
            raw: self.raw,
        }
    }
}


/// A `VkPipelineDepthStencilStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineDepthStencilStateCreateInfo<'s> {
    raw: vks::VkPipelineDepthStencilStateCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineDepthStencilStateCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        PipelineDepthStencilStateCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineDepthStencilStateCreateInfo) -> PipelineDepthStencilStateCreateInfo<'s> {
        PipelineDepthStencilStateCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineDepthStencilStateCreateFlags {
        PipelineDepthStencilStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineDepthStencilStateCreateInfo::flags: error converting flags")
    }

    pub fn depth_test_enable<'a>(&'a self) -> bool {
        self.raw.depthTestEnable != 0
    }

    pub fn depth_write_enable<'a>(&'a self) -> bool {
        self.raw.depthWriteEnable != 0
    }

    pub fn depth_compare_op<'a>(&'a self) -> CompareOp {
        self.raw.depthCompareOp.into()
    }

    pub fn depth_bounds_test_enable<'a>(&'a self) -> bool {
        self.raw.depthBoundsTestEnable != 0
    }

    pub fn stencil_test_enable<'a>(&'a self) -> bool {
        self.raw.stencilTestEnable != 0
    }

    pub fn front<'a>(&'a self) -> &'a StencilOpState {
        unsafe { &*(&self.raw.front as *const vks::VkStencilOpState as *const StencilOpState) }
    }

    pub fn front_mut<'a>(&'a mut self) -> &'a mut StencilOpState {
        unsafe { &mut *(&mut self.raw.front as *mut  vks::VkStencilOpState as *mut StencilOpState) }
    }

    pub fn back<'a>(&'a self) -> &'a StencilOpState {
        unsafe { &*(&self.raw.back as *const vks::VkStencilOpState as *const StencilOpState) }
    }

    pub fn back_mut<'a>(&'a mut self) -> &'a mut StencilOpState {
        unsafe { &mut *(&mut self.raw.back as *mut  vks::VkStencilOpState as *mut StencilOpState) }
    }

    pub fn min_depth_bounds<'a>(&'a self) -> f32 {
        self.raw.minDepthBounds.into()
    }

    pub fn max_depth_bounds<'a>(&'a self) -> f32 {
        self.raw.maxDepthBounds.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineDepthStencilStateCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_depth_test_enable<'m>(&mut self, depth_test_enable: bool) {
        self.raw.depthTestEnable = depth_test_enable as u32;
    }

    pub fn set_depth_write_enable<'m>(&mut self, depth_write_enable: bool) {
        self.raw.depthWriteEnable = depth_write_enable as u32;
    }

    pub fn set_depth_compare_op<'m>(&mut self, depth_compare_op: CompareOp) {
        self.raw.depthCompareOp = depth_compare_op.into();
    }

    pub fn set_depth_bounds_test_enable<'m>(&mut self, depth_bounds_test_enable: bool) {
        self.raw.depthBoundsTestEnable = depth_bounds_test_enable as u32;
    }

    pub fn set_stencil_test_enable<'m>(&mut self, stencil_test_enable: bool) {
        self.raw.stencilTestEnable = stencil_test_enable as u32;
    }

    pub fn set_front<'m>(&mut self, front: StencilOpState) {
        self.raw.front = front.raw;
    }

    pub fn set_back<'m>(&mut self, back: StencilOpState) {
        self.raw.back = back.raw;
    }

    pub fn set_min_depth_bounds<'m>(&mut self, min_depth_bounds: f32) {
        self.raw.minDepthBounds = min_depth_bounds.into();
    }

    pub fn set_max_depth_bounds<'m>(&mut self, max_depth_bounds: f32) {
        self.raw.maxDepthBounds = max_depth_bounds.into();
    }

    pub fn as_raw(&self) -> &vks::VkPipelineDepthStencilStateCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineDepthStencilStateCreateInfo<'s>> for vks::VkPipelineDepthStencilStateCreateInfo {
    fn from(f: PipelineDepthStencilStateCreateInfo<'s>) -> vks::VkPipelineDepthStencilStateCreateInfo {
        f.raw
    }
}


/// A builder for `VkPipelineDepthStencilStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineDepthStencilStateCreateInfoBuilder<'b> {
    raw: vks::VkPipelineDepthStencilStateCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineDepthStencilStateCreateInfoBuilder<'b> {
    pub fn new() -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        PipelineDepthStencilStateCreateInfoBuilder {
            raw: vks::VkPipelineDepthStencilStateCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineDepthStencilStateCreateFlags) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn depth_test_enable<'m>(mut self, depth_test_enable: bool) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.depthTestEnable = depth_test_enable as u32;
        self
    }

    pub fn depth_write_enable<'m>(mut self, depth_write_enable: bool) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.depthWriteEnable = depth_write_enable as u32;
        self
    }

    pub fn depth_compare_op<'m>(mut self, depth_compare_op: CompareOp) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.depthCompareOp = depth_compare_op.into();
        self
    }

    pub fn depth_bounds_test_enable<'m>(mut self, depth_bounds_test_enable: bool) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.depthBoundsTestEnable = depth_bounds_test_enable as u32;
        self
    }

    pub fn stencil_test_enable<'m>(mut self, stencil_test_enable: bool) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.stencilTestEnable = stencil_test_enable as u32;
        self
    }

    pub fn front<'m>(mut self, front: StencilOpState) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.front = front.raw;
        self
    }

    pub fn back<'m>(mut self, back: StencilOpState) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.back = back.raw;
        self
    }

    pub fn min_depth_bounds<'m>(mut self, min_depth_bounds: f32) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.minDepthBounds = min_depth_bounds.into();
        self
    }

    pub fn max_depth_bounds<'m>(mut self, max_depth_bounds: f32) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.maxDepthBounds = max_depth_bounds.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> PipelineDepthStencilStateCreateFlags {
        PipelineDepthStencilStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineDepthStencilStateCreateInfo::flags: error converting flags")
    }

    pub fn get_depth_test_enable<'a>(&'a self) -> bool {
        self.raw.depthTestEnable != 0
    }

    pub fn get_depth_write_enable<'a>(&'a self) -> bool {
        self.raw.depthWriteEnable != 0
    }

    pub fn get_depth_compare_op<'a>(&'a self) -> CompareOp {
        self.raw.depthCompareOp.into()
    }

    pub fn get_depth_bounds_test_enable<'a>(&'a self) -> bool {
        self.raw.depthBoundsTestEnable != 0
    }

    pub fn get_stencil_test_enable<'a>(&'a self) -> bool {
        self.raw.stencilTestEnable != 0
    }

    pub fn get_front<'a>(&'a self) -> &'a StencilOpState {
        unsafe { &*(&self.raw.front as *const vks::VkStencilOpState as *const StencilOpState) }
    }

    pub fn get_front_mut<'a>(&'a mut self) -> &'a mut StencilOpState {
        unsafe { &mut *(&mut self.raw.front as *mut  vks::VkStencilOpState as *mut StencilOpState) }
    }

    pub fn get_back<'a>(&'a self) -> &'a StencilOpState {
        unsafe { &*(&self.raw.back as *const vks::VkStencilOpState as *const StencilOpState) }
    }

    pub fn get_back_mut<'a>(&'a mut self) -> &'a mut StencilOpState {
        unsafe { &mut *(&mut self.raw.back as *mut  vks::VkStencilOpState as *mut StencilOpState) }
    }

    pub fn get_min_depth_bounds<'a>(&'a self) -> f32 {
        self.raw.minDepthBounds.into()
    }

    pub fn get_max_depth_bounds<'a>(&'a self) -> f32 {
        self.raw.maxDepthBounds.into()
    }

    pub fn build(self) -> PipelineDepthStencilStateCreateInfo<'b> {
        PipelineDepthStencilStateCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkGraphicsPipelineCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct GraphicsPipelineCreateInfo<'s> {
    raw: vks::VkGraphicsPipelineCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> GraphicsPipelineCreateInfo<'s> {
    pub fn builder<'b>() -> GraphicsPipelineCreateInfoBuilder<'b> {
        GraphicsPipelineCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkGraphicsPipelineCreateInfo) -> GraphicsPipelineCreateInfo<'s> {
        GraphicsPipelineCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineCreateFlags {
        PipelineCreateFlags::from_bits(self.raw.flags)
            .expect("GraphicsPipelineCreateInfo::flags: error converting flags")
    }

    pub fn stages<'a>(&'a self) -> &'a [PipelineShaderStageCreateInfo] {
        unsafe { slice::from_raw_parts(self.raw.pStages as *const _, self.raw.stageCount as usize) }
    }

    pub fn vertex_input_state<'a>(&'a self) -> &'a PipelineVertexInputStateCreateInfo {
        unsafe { &*(self.raw.pVertexInputState as *const vks::VkPipelineVertexInputStateCreateInfo as *const _) }
    }

    pub fn input_assembly_state<'a>(&'a self) -> &'a PipelineInputAssemblyStateCreateInfo {
        unsafe { &*(self.raw.pInputAssemblyState as *const vks::VkPipelineInputAssemblyStateCreateInfo as *const _) }
    }

    pub fn tessellation_state<'a>(&'a self) -> &'a PipelineTessellationStateCreateInfo {
        unsafe { &*(self.raw.pTessellationState as *const vks::VkPipelineTessellationStateCreateInfo as *const _) }
    }

    pub fn viewport_state<'a>(&'a self) -> &'a PipelineViewportStateCreateInfo {
        unsafe { &*(self.raw.pViewportState as *const vks::VkPipelineViewportStateCreateInfo as *const _) }
    }

    pub fn rasterization_state<'a>(&'a self) -> &'a PipelineRasterizationStateCreateInfo {
        unsafe { &*(self.raw.pRasterizationState as *const vks::VkPipelineRasterizationStateCreateInfo as *const _) }
    }

    pub fn multisample_state<'a>(&'a self) -> &'a PipelineMultisampleStateCreateInfo {
        unsafe { &*(self.raw.pMultisampleState as *const vks::VkPipelineMultisampleStateCreateInfo as *const _) }
    }

    pub fn depth_stencil_state<'a>(&'a self) -> &'a PipelineDepthStencilStateCreateInfo {
        unsafe { &*(self.raw.pDepthStencilState as *const vks::VkPipelineDepthStencilStateCreateInfo as *const _) }
    }

    pub fn color_blend_state<'a>(&'a self) -> &'a PipelineColorBlendStateCreateInfo {
        unsafe { &*(self.raw.pColorBlendState as *const vks::VkPipelineColorBlendStateCreateInfo as *const _) }
    }

    pub fn dynamic_state<'a>(&'a self) -> &'a PipelineDynamicStateCreateInfo {
        unsafe { &*(self.raw.pDynamicState as *const vks::VkPipelineDynamicStateCreateInfo as *const _) }
    }

    pub fn layout<'a>(&'a self) -> vks::VkPipelineLayout {
        self.raw.layout
    }

    pub fn render_pass<'a>(&'a self) -> vks::VkRenderPass {
        self.raw.renderPass
    }

    pub fn subpass<'a>(&'a self) -> u32 {
        self.raw.subpass.into()
    }

    pub fn base_pipeline_handle<'a>(&'a self) -> vks::VkPipeline {
        self.raw.basePipelineHandle
    }

    pub fn base_pipeline_index<'a>(&'a self) -> i32 {
        self.raw.basePipelineIndex.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_stages<'m, 'a>(&mut self, stages: &'a [PipelineShaderStageCreateInfo])
            where 'a: 's {
        assert!(self.raw.stageCount == 0 || self.raw.stageCount == stages.len() as _, 
            "count inconsistency found when specifying `GraphicsPipelineCreateInfo::stages`.");
        self.raw.stageCount = stages.len() as _;
        self.raw.pStages = stages.as_ptr() as *const vks::VkPipelineShaderStageCreateInfo;
    }

    pub fn set_vertex_input_state<'m, 'a>(&mut self, vertex_input_state: &'a PipelineVertexInputStateCreateInfo)
            where 'a: 's {
        self.raw.pVertexInputState = vertex_input_state.as_raw();
    }

    pub fn set_input_assembly_state<'m, 'a>(&mut self, input_assembly_state: &'a PipelineInputAssemblyStateCreateInfo)
            where 'a: 's {
        self.raw.pInputAssemblyState = input_assembly_state.as_raw();
    }

    pub fn set_tessellation_state<'m, 'a>(&mut self, tessellation_state: &'a PipelineTessellationStateCreateInfo)
            where 'a: 's {
        self.raw.pTessellationState = tessellation_state.as_raw();
    }

    pub fn set_viewport_state<'m, 'a>(&mut self, viewport_state: &'a PipelineViewportStateCreateInfo)
            where 'a: 's {
        self.raw.pViewportState = viewport_state.as_raw();
    }

    pub fn set_rasterization_state<'m, 'a>(&mut self, rasterization_state: &'a PipelineRasterizationStateCreateInfo)
            where 'a: 's {
        self.raw.pRasterizationState = rasterization_state.as_raw();
    }

    pub fn set_multisample_state<'m, 'a>(&mut self, multisample_state: &'a PipelineMultisampleStateCreateInfo)
            where 'a: 's {
        self.raw.pMultisampleState = multisample_state.as_raw();
    }

    pub fn set_depth_stencil_state<'m, 'a>(&mut self, depth_stencil_state: &'a PipelineDepthStencilStateCreateInfo)
            where 'a: 's {
        self.raw.pDepthStencilState = depth_stencil_state.as_raw();
    }

    pub fn set_color_blend_state<'m, 'a>(&mut self, color_blend_state: &'a PipelineColorBlendStateCreateInfo)
            where 'a: 's {
        self.raw.pColorBlendState = color_blend_state.as_raw();
    }

    pub fn set_dynamic_state<'m, 'a>(&mut self, dynamic_state: &'a PipelineDynamicStateCreateInfo)
            where 'a: 's {
        self.raw.pDynamicState = dynamic_state.as_raw();
    }

    pub fn set_layout<'m, H>(&mut self, layout: H)
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.layout = layout.handle().0;
    }

    pub fn set_render_pass<'m, H>(&mut self, render_pass: H)
            where H: Handle<Target=RenderPassHandle> {
        self.raw.renderPass = render_pass.handle().0;
    }

    pub fn set_subpass<'m>(&mut self, subpass: u32) {
        self.raw.subpass = subpass.into();
    }

    pub fn set_base_pipeline_handle<'m, H>(&mut self, base_pipeline_handle: H)
            where H: Handle<Target=PipelineHandle> {
        self.raw.basePipelineHandle = base_pipeline_handle.handle().0;
    }

    pub fn set_base_pipeline_index<'m>(&mut self, base_pipeline_index: i32) {
        self.raw.basePipelineIndex = base_pipeline_index.into();
    }

    pub fn as_raw(&self) -> &vks::VkGraphicsPipelineCreateInfo {
        &self.raw
    }
}

impl<'s> From<GraphicsPipelineCreateInfo<'s>> for vks::VkGraphicsPipelineCreateInfo {
    fn from(f: GraphicsPipelineCreateInfo<'s>) -> vks::VkGraphicsPipelineCreateInfo {
        f.raw
    }
}


/// A builder for `VkGraphicsPipelineCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct GraphicsPipelineCreateInfoBuilder<'b> {
    raw: vks::VkGraphicsPipelineCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> GraphicsPipelineCreateInfoBuilder<'b> {
    pub fn new() -> GraphicsPipelineCreateInfoBuilder<'b> {
        GraphicsPipelineCreateInfoBuilder {
            raw: vks::VkGraphicsPipelineCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> GraphicsPipelineCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineCreateFlags) -> GraphicsPipelineCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn stages<'m, 'a>(mut self, stages: &'a [PipelineShaderStageCreateInfo]) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.stageCount == 0 || self.raw.stageCount == stages.len() as _, 
            "count inconsistency found when specifying `GraphicsPipelineCreateInfo::stages`.");
        self.raw.stageCount = stages.len() as _;
        self.raw.pStages = stages.as_ptr() as *const vks::VkPipelineShaderStageCreateInfo;
        self
    }

    pub fn vertex_input_state<'m, 'a>(mut self, vertex_input_state: &'a PipelineVertexInputStateCreateInfo) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pVertexInputState = vertex_input_state.as_raw();
        self
    }

    pub fn input_assembly_state<'m, 'a>(mut self, input_assembly_state: &'a PipelineInputAssemblyStateCreateInfo) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pInputAssemblyState = input_assembly_state.as_raw();
        self
    }

    pub fn tessellation_state<'m, 'a>(mut self, tessellation_state: &'a PipelineTessellationStateCreateInfo) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pTessellationState = tessellation_state.as_raw();
        self
    }

    pub fn viewport_state<'m, 'a>(mut self, viewport_state: &'a PipelineViewportStateCreateInfo) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pViewportState = viewport_state.as_raw();
        self
    }

    pub fn rasterization_state<'m, 'a>(mut self, rasterization_state: &'a PipelineRasterizationStateCreateInfo) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pRasterizationState = rasterization_state.as_raw();
        self
    }

    pub fn multisample_state<'m, 'a>(mut self, multisample_state: &'a PipelineMultisampleStateCreateInfo) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pMultisampleState = multisample_state.as_raw();
        self
    }

    pub fn depth_stencil_state<'m, 'a>(mut self, depth_stencil_state: &'a PipelineDepthStencilStateCreateInfo) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pDepthStencilState = depth_stencil_state.as_raw();
        self
    }

    pub fn color_blend_state<'m, 'a>(mut self, color_blend_state: &'a PipelineColorBlendStateCreateInfo) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pColorBlendState = color_blend_state.as_raw();
        self
    }

    pub fn dynamic_state<'m, 'a>(mut self, dynamic_state: &'a PipelineDynamicStateCreateInfo) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pDynamicState = dynamic_state.as_raw();
        self
    }

    pub fn layout<'m, H>(mut self, layout: H) -> GraphicsPipelineCreateInfoBuilder<'b>
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.layout = layout.handle().0;
        self
    }

    pub fn render_pass<'m, H>(mut self, render_pass: H) -> GraphicsPipelineCreateInfoBuilder<'b>
            where H: Handle<Target=RenderPassHandle> {
        self.raw.renderPass = render_pass.handle().0;
        self
    }

    pub fn subpass<'m>(mut self, subpass: u32) -> GraphicsPipelineCreateInfoBuilder<'b> {
        self.raw.subpass = subpass.into();
        self
    }

    pub fn base_pipeline_handle<'m, H>(mut self, base_pipeline_handle: H) -> GraphicsPipelineCreateInfoBuilder<'b>
            where H: Handle<Target=PipelineHandle> {
        self.raw.basePipelineHandle = base_pipeline_handle.handle().0;
        self
    }

    pub fn base_pipeline_index<'m>(mut self, base_pipeline_index: i32) -> GraphicsPipelineCreateInfoBuilder<'b> {
        self.raw.basePipelineIndex = base_pipeline_index.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> PipelineCreateFlags {
        PipelineCreateFlags::from_bits(self.raw.flags)
            .expect("GraphicsPipelineCreateInfo::flags: error converting flags")
    }

    pub fn get_stages<'a>(&'a self) -> &'a [PipelineShaderStageCreateInfo] {
        unsafe { slice::from_raw_parts(self.raw.pStages as *const _, self.raw.stageCount as usize) }
    }

    pub fn get_vertex_input_state<'a>(&'a self) -> &'a PipelineVertexInputStateCreateInfo {
        unsafe { &*(self.raw.pVertexInputState as *const vks::VkPipelineVertexInputStateCreateInfo as *const _) }
    }

    pub fn get_input_assembly_state<'a>(&'a self) -> &'a PipelineInputAssemblyStateCreateInfo {
        unsafe { &*(self.raw.pInputAssemblyState as *const vks::VkPipelineInputAssemblyStateCreateInfo as *const _) }
    }

    pub fn get_tessellation_state<'a>(&'a self) -> &'a PipelineTessellationStateCreateInfo {
        unsafe { &*(self.raw.pTessellationState as *const vks::VkPipelineTessellationStateCreateInfo as *const _) }
    }

    pub fn get_viewport_state<'a>(&'a self) -> &'a PipelineViewportStateCreateInfo {
        unsafe { &*(self.raw.pViewportState as *const vks::VkPipelineViewportStateCreateInfo as *const _) }
    }

    pub fn get_rasterization_state<'a>(&'a self) -> &'a PipelineRasterizationStateCreateInfo {
        unsafe { &*(self.raw.pRasterizationState as *const vks::VkPipelineRasterizationStateCreateInfo as *const _) }
    }

    pub fn get_multisample_state<'a>(&'a self) -> &'a PipelineMultisampleStateCreateInfo {
        unsafe { &*(self.raw.pMultisampleState as *const vks::VkPipelineMultisampleStateCreateInfo as *const _) }
    }

    pub fn get_depth_stencil_state<'a>(&'a self) -> &'a PipelineDepthStencilStateCreateInfo {
        unsafe { &*(self.raw.pDepthStencilState as *const vks::VkPipelineDepthStencilStateCreateInfo as *const _) }
    }

    pub fn get_color_blend_state<'a>(&'a self) -> &'a PipelineColorBlendStateCreateInfo {
        unsafe { &*(self.raw.pColorBlendState as *const vks::VkPipelineColorBlendStateCreateInfo as *const _) }
    }

    pub fn get_dynamic_state<'a>(&'a self) -> &'a PipelineDynamicStateCreateInfo {
        unsafe { &*(self.raw.pDynamicState as *const vks::VkPipelineDynamicStateCreateInfo as *const _) }
    }

    pub fn get_layout<'a>(&'a self) -> vks::VkPipelineLayout {
        self.raw.layout
    }

    pub fn get_render_pass<'a>(&'a self) -> vks::VkRenderPass {
        self.raw.renderPass
    }

    pub fn get_subpass<'a>(&'a self) -> u32 {
        self.raw.subpass.into()
    }

    pub fn get_base_pipeline_handle<'a>(&'a self) -> vks::VkPipeline {
        self.raw.basePipelineHandle
    }

    pub fn get_base_pipeline_index<'a>(&'a self) -> i32 {
        self.raw.basePipelineIndex.into()
    }

    pub fn build(self) -> GraphicsPipelineCreateInfo<'b> {
        GraphicsPipelineCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineCacheCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineCacheCreateInfo<'s> {
    raw: vks::VkPipelineCacheCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineCacheCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineCacheCreateInfoBuilder<'b> {
        PipelineCacheCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineCacheCreateInfo) -> PipelineCacheCreateInfo<'s> {
        PipelineCacheCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineCacheCreateFlags {
        PipelineCacheCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineCacheCreateInfo::flags: error converting flags")
    }

    pub fn initial_data_size<'a>(&'a self) -> usize {
        self.raw.initialDataSize.into()
    }

    pub fn initial_data<'a>(&'a self) -> *const c_void {
        self.raw.pInitialData
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineCacheCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_initial_data_size<'m>(&mut self, initial_data_size: usize) {
        self.raw.initialDataSize = initial_data_size.into();
    }

    pub unsafe fn set_initial_data<'m>(&mut self, initial_data: *const c_void) {
        self.raw.pInitialData = initial_data;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineCacheCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineCacheCreateInfo<'s>> for vks::VkPipelineCacheCreateInfo {
    fn from(f: PipelineCacheCreateInfo<'s>) -> vks::VkPipelineCacheCreateInfo {
        f.raw
    }
}


/// A builder for `VkPipelineCacheCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineCacheCreateInfoBuilder<'b> {
    raw: vks::VkPipelineCacheCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineCacheCreateInfoBuilder<'b> {
    pub fn new() -> PipelineCacheCreateInfoBuilder<'b> {
        PipelineCacheCreateInfoBuilder {
            raw: vks::VkPipelineCacheCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineCacheCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineCacheCreateFlags) -> PipelineCacheCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn initial_data_size<'m>(mut self, initial_data_size: usize) -> PipelineCacheCreateInfoBuilder<'b> {
        self.raw.initialDataSize = initial_data_size.into();
        self
    }

    pub unsafe fn initial_data<'m>(mut self, initial_data: *const c_void) -> PipelineCacheCreateInfoBuilder<'b> {
        self.raw.pInitialData = initial_data;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> PipelineCacheCreateFlags {
        PipelineCacheCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineCacheCreateInfo::flags: error converting flags")
    }

    pub fn get_initial_data_size<'a>(&'a self) -> usize {
        self.raw.initialDataSize.into()
    }

    pub fn get_initial_data<'a>(&'a self) -> *const c_void {
        self.raw.pInitialData
    }

    pub fn build(self) -> PipelineCacheCreateInfo<'b> {
        PipelineCacheCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPushConstantRange`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PushConstantRange {
    raw: vks::VkPushConstantRange,
}

impl PushConstantRange {
    pub fn builder() -> PushConstantRangeBuilder {
        PushConstantRangeBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPushConstantRange) -> PushConstantRange {
        PushConstantRange { raw, }
    }

    pub fn stage_flags<'a>(&'a self) -> ShaderStageFlags {
        ShaderStageFlags::from_bits(self.raw.stageFlags)
            .expect("PushConstantRange::stage_flags: error converting flags")
    }

    pub fn offset<'a>(&'a self) -> u32 {
        self.raw.offset.into()
    }

    pub fn size<'a>(&'a self) -> u32 {
        self.raw.size.into()
    }

    pub fn set_stage_flags<'m>(&mut self, stage_flags: ShaderStageFlags) {
        self.raw.stageFlags = stage_flags.bits();
    }

    pub fn set_offset<'m>(&mut self, offset: u32) {
        self.raw.offset = offset.into();
    }

    pub fn set_size<'m>(&mut self, size: u32) {
        self.raw.size = size.into();
    }

    pub fn as_raw(&self) -> &vks::VkPushConstantRange {
        &self.raw
    }
}

impl From<PushConstantRange> for vks::VkPushConstantRange {
    fn from(f: PushConstantRange) -> vks::VkPushConstantRange {
        f.raw
    }
}


/// A builder for `VkPushConstantRange`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PushConstantRangeBuilder {
    raw: vks::VkPushConstantRange,
}

impl PushConstantRangeBuilder {
    pub fn new() -> PushConstantRangeBuilder {
        PushConstantRangeBuilder {
            raw: vks::VkPushConstantRange::default(),
        }
    }

    pub fn stage_flags<'m>(mut self, stage_flags: ShaderStageFlags) -> PushConstantRangeBuilder {
        self.raw.stageFlags = stage_flags.bits();
        self
    }

    pub fn offset<'m>(mut self, offset: u32) -> PushConstantRangeBuilder {
        self.raw.offset = offset.into();
        self
    }

    pub fn size<'m>(mut self, size: u32) -> PushConstantRangeBuilder {
        self.raw.size = size.into();
        self
    }

    pub fn get_stage_flags<'a>(&'a self) -> ShaderStageFlags {
        ShaderStageFlags::from_bits(self.raw.stageFlags)
            .expect("PushConstantRange::stage_flags: error converting flags")
    }

    pub fn get_offset<'a>(&'a self) -> u32 {
        self.raw.offset.into()
    }

    pub fn get_size<'a>(&'a self) -> u32 {
        self.raw.size.into()
    }

    pub fn build(self) -> PushConstantRange {
        PushConstantRange {
            raw: self.raw,
        }
    }
}


/// A `VkPipelineLayoutCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineLayoutCreateInfo<'s> {
    raw: vks::VkPipelineLayoutCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineLayoutCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineLayoutCreateInfoBuilder<'b> {
        PipelineLayoutCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineLayoutCreateInfo) -> PipelineLayoutCreateInfo<'s> {
        PipelineLayoutCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineLayoutCreateFlags {
        PipelineLayoutCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineLayoutCreateInfo::flags: error converting flags")
    }

    pub fn set_layouts<'a>(&'a self) -> &'a [vks::VkDescriptorSetLayout] {
        unsafe { slice::from_raw_parts(self.raw.pSetLayouts as *const _, self.raw.setLayoutCount as usize) }
    }

    pub fn push_constant_ranges<'a>(&'a self) -> &'a [PushConstantRange] {
        unsafe { slice::from_raw_parts(self.raw.pPushConstantRanges as *const _, self.raw.pushConstantRangeCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineLayoutCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_set_layouts<'m, 'a>(&mut self, set_layouts: &'a [DescriptorSetLayoutHandle])
            where 'a: 's {
        assert!(self.raw.setLayoutCount == 0 || self.raw.setLayoutCount == set_layouts.len() as _, 
            "count inconsistency found when specifying `PipelineLayoutCreateInfo::set_layouts`.");
        self.raw.setLayoutCount = set_layouts.len() as _;
        self.raw.pSetLayouts = set_layouts.as_ptr() as *const vks::VkDescriptorSetLayout;
    }

    pub fn set_push_constant_ranges<'m, 'a>(&mut self, push_constant_ranges: &'a [PushConstantRange])
            where 'a: 's {
        assert!(self.raw.pushConstantRangeCount == 0 || self.raw.pushConstantRangeCount == push_constant_ranges.len() as _, 
            "count inconsistency found when specifying `PipelineLayoutCreateInfo::push_constant_ranges`.");
        self.raw.pushConstantRangeCount = push_constant_ranges.len() as _;
        self.raw.pPushConstantRanges = push_constant_ranges.as_ptr() as *const vks::VkPushConstantRange;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineLayoutCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineLayoutCreateInfo<'s>> for vks::VkPipelineLayoutCreateInfo {
    fn from(f: PipelineLayoutCreateInfo<'s>) -> vks::VkPipelineLayoutCreateInfo {
        f.raw
    }
}


/// A builder for `VkPipelineLayoutCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineLayoutCreateInfoBuilder<'b> {
    raw: vks::VkPipelineLayoutCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineLayoutCreateInfoBuilder<'b> {
    pub fn new() -> PipelineLayoutCreateInfoBuilder<'b> {
        PipelineLayoutCreateInfoBuilder {
            raw: vks::VkPipelineLayoutCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineLayoutCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineLayoutCreateFlags) -> PipelineLayoutCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn set_layouts<'m, 'a>(mut self, set_layouts: &'a [DescriptorSetLayoutHandle]) -> PipelineLayoutCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.setLayoutCount == 0 || self.raw.setLayoutCount == set_layouts.len() as _, 
            "count inconsistency found when specifying `PipelineLayoutCreateInfo::set_layouts`.");
        self.raw.setLayoutCount = set_layouts.len() as _;
        self.raw.pSetLayouts = set_layouts.as_ptr() as *const vks::VkDescriptorSetLayout;
        self
    }

    pub fn push_constant_ranges<'m, 'a>(mut self, push_constant_ranges: &'a [PushConstantRange]) -> PipelineLayoutCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.pushConstantRangeCount == 0 || self.raw.pushConstantRangeCount == push_constant_ranges.len() as _, 
            "count inconsistency found when specifying `PipelineLayoutCreateInfo::push_constant_ranges`.");
        self.raw.pushConstantRangeCount = push_constant_ranges.len() as _;
        self.raw.pPushConstantRanges = push_constant_ranges.as_ptr() as *const vks::VkPushConstantRange;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> PipelineLayoutCreateFlags {
        PipelineLayoutCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineLayoutCreateInfo::flags: error converting flags")
    }

    pub fn get_set_layouts<'a>(&'a self) -> &'a [vks::VkDescriptorSetLayout] {
        unsafe { slice::from_raw_parts(self.raw.pSetLayouts as *const _, self.raw.setLayoutCount as usize) }
    }

    pub fn get_push_constant_ranges<'a>(&'a self) -> &'a [PushConstantRange] {
        unsafe { slice::from_raw_parts(self.raw.pPushConstantRanges as *const _, self.raw.pushConstantRangeCount as usize) }
    }

    pub fn build(self) -> PipelineLayoutCreateInfo<'b> {
        PipelineLayoutCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSamplerCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SamplerCreateInfo<'s> {
    raw: vks::VkSamplerCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> SamplerCreateInfo<'s> {
    pub fn builder<'b>() -> SamplerCreateInfoBuilder<'b> {
        SamplerCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSamplerCreateInfo) -> SamplerCreateInfo<'s> {
        SamplerCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> SamplerCreateFlags {
        SamplerCreateFlags::from_bits(self.raw.flags)
            .expect("SamplerCreateInfo::flags: error converting flags")
    }

    pub fn mag_filter<'a>(&'a self) -> Filter {
        self.raw.magFilter.into()
    }

    pub fn min_filter<'a>(&'a self) -> Filter {
        self.raw.minFilter.into()
    }

    pub fn mipmap_mode<'a>(&'a self) -> SamplerMipmapMode {
        self.raw.mipmapMode.into()
    }

    pub fn address_mode_u<'a>(&'a self) -> SamplerAddressMode {
        self.raw.addressModeU.into()
    }

    pub fn address_mode_v<'a>(&'a self) -> SamplerAddressMode {
        self.raw.addressModeV.into()
    }

    pub fn address_mode_w<'a>(&'a self) -> SamplerAddressMode {
        self.raw.addressModeW.into()
    }

    pub fn mip_lod_bias<'a>(&'a self) -> f32 {
        self.raw.mipLodBias.into()
    }

    pub fn anisotropy_enable<'a>(&'a self) -> bool {
        self.raw.anisotropyEnable != 0
    }

    pub fn max_anisotropy<'a>(&'a self) -> f32 {
        self.raw.maxAnisotropy.into()
    }

    pub fn compare_enable<'a>(&'a self) -> bool {
        self.raw.compareEnable != 0
    }

    pub fn compare_op<'a>(&'a self) -> CompareOp {
        self.raw.compareOp.into()
    }

    pub fn min_lod<'a>(&'a self) -> f32 {
        self.raw.minLod.into()
    }

    pub fn max_lod<'a>(&'a self) -> f32 {
        self.raw.maxLod.into()
    }

    pub fn border_color<'a>(&'a self) -> BorderColor {
        self.raw.borderColor.into()
    }

    pub fn unnormalized_coordinates<'a>(&'a self) -> bool {
        self.raw.unnormalizedCoordinates != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: SamplerCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_mag_filter<'m>(&mut self, mag_filter: Filter) {
        self.raw.magFilter = mag_filter.into();
    }

    pub fn set_min_filter<'m>(&mut self, min_filter: Filter) {
        self.raw.minFilter = min_filter.into();
    }

    pub fn set_mipmap_mode<'m>(&mut self, mipmap_mode: SamplerMipmapMode) {
        self.raw.mipmapMode = mipmap_mode.into();
    }

    pub fn set_address_mode_u<'m>(&mut self, address_mode_u: SamplerAddressMode) {
        self.raw.addressModeU = address_mode_u.into();
    }

    pub fn set_address_mode_v<'m>(&mut self, address_mode_v: SamplerAddressMode) {
        self.raw.addressModeV = address_mode_v.into();
    }

    pub fn set_address_mode_w<'m>(&mut self, address_mode_w: SamplerAddressMode) {
        self.raw.addressModeW = address_mode_w.into();
    }

    pub fn set_mip_lod_bias<'m>(&mut self, mip_lod_bias: f32) {
        self.raw.mipLodBias = mip_lod_bias.into();
    }

    pub fn set_anisotropy_enable<'m>(&mut self, anisotropy_enable: bool) {
        self.raw.anisotropyEnable = anisotropy_enable as u32;
    }

    pub fn set_max_anisotropy<'m>(&mut self, max_anisotropy: f32) {
        self.raw.maxAnisotropy = max_anisotropy.into();
    }

    pub fn set_compare_enable<'m>(&mut self, compare_enable: bool) {
        self.raw.compareEnable = compare_enable as u32;
    }

    pub fn set_compare_op<'m>(&mut self, compare_op: CompareOp) {
        self.raw.compareOp = compare_op.into();
    }

    pub fn set_min_lod<'m>(&mut self, min_lod: f32) {
        self.raw.minLod = min_lod.into();
    }

    pub fn set_max_lod<'m>(&mut self, max_lod: f32) {
        self.raw.maxLod = max_lod.into();
    }

    pub fn set_border_color<'m>(&mut self, border_color: BorderColor) {
        self.raw.borderColor = border_color.into();
    }

    pub fn set_unnormalized_coordinates<'m>(&mut self, unnormalized_coordinates: bool) {
        self.raw.unnormalizedCoordinates = unnormalized_coordinates as u32;
    }

    pub fn as_raw(&self) -> &vks::VkSamplerCreateInfo {
        &self.raw
    }
}

impl<'s> From<SamplerCreateInfo<'s>> for vks::VkSamplerCreateInfo {
    fn from(f: SamplerCreateInfo<'s>) -> vks::VkSamplerCreateInfo {
        f.raw
    }
}


/// A builder for `VkSamplerCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SamplerCreateInfoBuilder<'b> {
    raw: vks::VkSamplerCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SamplerCreateInfoBuilder<'b> {
    pub fn new() -> SamplerCreateInfoBuilder<'b> {
        SamplerCreateInfoBuilder {
            raw: vks::VkSamplerCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> SamplerCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: SamplerCreateFlags) -> SamplerCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn mag_filter<'m>(mut self, mag_filter: Filter) -> SamplerCreateInfoBuilder<'b> {
        self.raw.magFilter = mag_filter.into();
        self
    }

    pub fn min_filter<'m>(mut self, min_filter: Filter) -> SamplerCreateInfoBuilder<'b> {
        self.raw.minFilter = min_filter.into();
        self
    }

    pub fn mipmap_mode<'m>(mut self, mipmap_mode: SamplerMipmapMode) -> SamplerCreateInfoBuilder<'b> {
        self.raw.mipmapMode = mipmap_mode.into();
        self
    }

    pub fn address_mode_u<'m>(mut self, address_mode_u: SamplerAddressMode) -> SamplerCreateInfoBuilder<'b> {
        self.raw.addressModeU = address_mode_u.into();
        self
    }

    pub fn address_mode_v<'m>(mut self, address_mode_v: SamplerAddressMode) -> SamplerCreateInfoBuilder<'b> {
        self.raw.addressModeV = address_mode_v.into();
        self
    }

    pub fn address_mode_w<'m>(mut self, address_mode_w: SamplerAddressMode) -> SamplerCreateInfoBuilder<'b> {
        self.raw.addressModeW = address_mode_w.into();
        self
    }

    pub fn mip_lod_bias<'m>(mut self, mip_lod_bias: f32) -> SamplerCreateInfoBuilder<'b> {
        self.raw.mipLodBias = mip_lod_bias.into();
        self
    }

    pub fn anisotropy_enable<'m>(mut self, anisotropy_enable: bool) -> SamplerCreateInfoBuilder<'b> {
        self.raw.anisotropyEnable = anisotropy_enable as u32;
        self
    }

    pub fn max_anisotropy<'m>(mut self, max_anisotropy: f32) -> SamplerCreateInfoBuilder<'b> {
        self.raw.maxAnisotropy = max_anisotropy.into();
        self
    }

    pub fn compare_enable<'m>(mut self, compare_enable: bool) -> SamplerCreateInfoBuilder<'b> {
        self.raw.compareEnable = compare_enable as u32;
        self
    }

    pub fn compare_op<'m>(mut self, compare_op: CompareOp) -> SamplerCreateInfoBuilder<'b> {
        self.raw.compareOp = compare_op.into();
        self
    }

    pub fn min_lod<'m>(mut self, min_lod: f32) -> SamplerCreateInfoBuilder<'b> {
        self.raw.minLod = min_lod.into();
        self
    }

    pub fn max_lod<'m>(mut self, max_lod: f32) -> SamplerCreateInfoBuilder<'b> {
        self.raw.maxLod = max_lod.into();
        self
    }

    pub fn border_color<'m>(mut self, border_color: BorderColor) -> SamplerCreateInfoBuilder<'b> {
        self.raw.borderColor = border_color.into();
        self
    }

    pub fn unnormalized_coordinates<'m>(mut self, unnormalized_coordinates: bool) -> SamplerCreateInfoBuilder<'b> {
        self.raw.unnormalizedCoordinates = unnormalized_coordinates as u32;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> SamplerCreateFlags {
        SamplerCreateFlags::from_bits(self.raw.flags)
            .expect("SamplerCreateInfo::flags: error converting flags")
    }

    pub fn get_mag_filter<'a>(&'a self) -> Filter {
        self.raw.magFilter.into()
    }

    pub fn get_min_filter<'a>(&'a self) -> Filter {
        self.raw.minFilter.into()
    }

    pub fn get_mipmap_mode<'a>(&'a self) -> SamplerMipmapMode {
        self.raw.mipmapMode.into()
    }

    pub fn get_address_mode_u<'a>(&'a self) -> SamplerAddressMode {
        self.raw.addressModeU.into()
    }

    pub fn get_address_mode_v<'a>(&'a self) -> SamplerAddressMode {
        self.raw.addressModeV.into()
    }

    pub fn get_address_mode_w<'a>(&'a self) -> SamplerAddressMode {
        self.raw.addressModeW.into()
    }

    pub fn get_mip_lod_bias<'a>(&'a self) -> f32 {
        self.raw.mipLodBias.into()
    }

    pub fn get_anisotropy_enable<'a>(&'a self) -> bool {
        self.raw.anisotropyEnable != 0
    }

    pub fn get_max_anisotropy<'a>(&'a self) -> f32 {
        self.raw.maxAnisotropy.into()
    }

    pub fn get_compare_enable<'a>(&'a self) -> bool {
        self.raw.compareEnable != 0
    }

    pub fn get_compare_op<'a>(&'a self) -> CompareOp {
        self.raw.compareOp.into()
    }

    pub fn get_min_lod<'a>(&'a self) -> f32 {
        self.raw.minLod.into()
    }

    pub fn get_max_lod<'a>(&'a self) -> f32 {
        self.raw.maxLod.into()
    }

    pub fn get_border_color<'a>(&'a self) -> BorderColor {
        self.raw.borderColor.into()
    }

    pub fn get_unnormalized_coordinates<'a>(&'a self) -> bool {
        self.raw.unnormalizedCoordinates != 0
    }

    pub fn build(self) -> SamplerCreateInfo<'b> {
        SamplerCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkCommandPoolCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct CommandPoolCreateInfo<'s> {
    raw: vks::VkCommandPoolCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> CommandPoolCreateInfo<'s> {
    pub fn builder<'b>() -> CommandPoolCreateInfoBuilder<'b> {
        CommandPoolCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkCommandPoolCreateInfo) -> CommandPoolCreateInfo<'s> {
        CommandPoolCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> CommandPoolCreateFlags {
        CommandPoolCreateFlags::from_bits(self.raw.flags)
            .expect("CommandPoolCreateInfo::flags: error converting flags")
    }

    pub fn queue_family_index<'a>(&'a self) -> u32 {
        self.raw.queueFamilyIndex.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: CommandPoolCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_queue_family_index<'m>(&mut self, queue_family_index: u32) {
        self.raw.queueFamilyIndex = queue_family_index.into();
    }

    pub fn as_raw(&self) -> &vks::VkCommandPoolCreateInfo {
        &self.raw
    }
}

impl<'s> From<CommandPoolCreateInfo<'s>> for vks::VkCommandPoolCreateInfo {
    fn from(f: CommandPoolCreateInfo<'s>) -> vks::VkCommandPoolCreateInfo {
        f.raw
    }
}


/// A builder for `VkCommandPoolCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct CommandPoolCreateInfoBuilder<'b> {
    raw: vks::VkCommandPoolCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> CommandPoolCreateInfoBuilder<'b> {
    pub fn new() -> CommandPoolCreateInfoBuilder<'b> {
        CommandPoolCreateInfoBuilder {
            raw: vks::VkCommandPoolCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> CommandPoolCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: CommandPoolCreateFlags) -> CommandPoolCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn queue_family_index<'m>(mut self, queue_family_index: u32) -> CommandPoolCreateInfoBuilder<'b> {
        self.raw.queueFamilyIndex = queue_family_index.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> CommandPoolCreateFlags {
        CommandPoolCreateFlags::from_bits(self.raw.flags)
            .expect("CommandPoolCreateInfo::flags: error converting flags")
    }

    pub fn get_queue_family_index<'a>(&'a self) -> u32 {
        self.raw.queueFamilyIndex.into()
    }

    pub fn build(self) -> CommandPoolCreateInfo<'b> {
        CommandPoolCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkCommandBufferAllocateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct CommandBufferAllocateInfo<'s> {
    raw: vks::VkCommandBufferAllocateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> CommandBufferAllocateInfo<'s> {
    pub fn builder<'b>() -> CommandBufferAllocateInfoBuilder<'b> {
        CommandBufferAllocateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkCommandBufferAllocateInfo) -> CommandBufferAllocateInfo<'s> {
        CommandBufferAllocateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn command_pool<'a>(&'a self) -> vks::VkCommandPool {
        self.raw.commandPool
    }

    pub fn level<'a>(&'a self) -> CommandBufferLevel {
        self.raw.level.into()
    }

    pub fn command_buffer_count<'a>(&'a self) -> u32 {
        self.raw.commandBufferCount.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_command_pool<'m, H>(&mut self, command_pool: H)
            where H: Handle<Target=CommandPoolHandle> {
        self.raw.commandPool = command_pool.handle().0;
    }

    pub fn set_level<'m>(&mut self, level: CommandBufferLevel) {
        self.raw.level = level.into();
    }

    pub fn set_command_buffer_count<'m>(&mut self, command_buffer_count: u32) {
        self.raw.commandBufferCount = command_buffer_count.into();
    }

    pub fn as_raw(&self) -> &vks::VkCommandBufferAllocateInfo {
        &self.raw
    }
}

impl<'s> From<CommandBufferAllocateInfo<'s>> for vks::VkCommandBufferAllocateInfo {
    fn from(f: CommandBufferAllocateInfo<'s>) -> vks::VkCommandBufferAllocateInfo {
        f.raw
    }
}


/// A builder for `VkCommandBufferAllocateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct CommandBufferAllocateInfoBuilder<'b> {
    raw: vks::VkCommandBufferAllocateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> CommandBufferAllocateInfoBuilder<'b> {
    pub fn new() -> CommandBufferAllocateInfoBuilder<'b> {
        CommandBufferAllocateInfoBuilder {
            raw: vks::VkCommandBufferAllocateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> CommandBufferAllocateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn command_pool<'m, H>(mut self, command_pool: H) -> CommandBufferAllocateInfoBuilder<'b>
            where H: Handle<Target=CommandPoolHandle> {
        self.raw.commandPool = command_pool.handle().0;
        self
    }

    pub fn level<'m>(mut self, level: CommandBufferLevel) -> CommandBufferAllocateInfoBuilder<'b> {
        self.raw.level = level.into();
        self
    }

    pub fn command_buffer_count<'m>(mut self, command_buffer_count: u32) -> CommandBufferAllocateInfoBuilder<'b> {
        self.raw.commandBufferCount = command_buffer_count.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_command_pool<'a>(&'a self) -> vks::VkCommandPool {
        self.raw.commandPool
    }

    pub fn get_level<'a>(&'a self) -> CommandBufferLevel {
        self.raw.level.into()
    }

    pub fn get_command_buffer_count<'a>(&'a self) -> u32 {
        self.raw.commandBufferCount.into()
    }

    pub fn build(self) -> CommandBufferAllocateInfo<'b> {
        CommandBufferAllocateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkCommandBufferInheritanceInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct CommandBufferInheritanceInfo<'s> {
    raw: vks::VkCommandBufferInheritanceInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> CommandBufferInheritanceInfo<'s> {
    pub fn builder<'b>() -> CommandBufferInheritanceInfoBuilder<'b> {
        CommandBufferInheritanceInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkCommandBufferInheritanceInfo) -> CommandBufferInheritanceInfo<'s> {
        CommandBufferInheritanceInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn render_pass<'a>(&'a self) -> vks::VkRenderPass {
        self.raw.renderPass
    }

    pub fn subpass<'a>(&'a self) -> u32 {
        self.raw.subpass.into()
    }

    pub fn framebuffer<'a>(&'a self) -> vks::VkFramebuffer {
        self.raw.framebuffer
    }

    pub fn occlusion_query_enable<'a>(&'a self) -> bool {
        self.raw.occlusionQueryEnable != 0
    }

    pub fn query_flags<'a>(&'a self) -> QueryControlFlags {
        QueryControlFlags::from_bits(self.raw.queryFlags)
            .expect("CommandBufferInheritanceInfo::query_flags: error converting flags")
    }

    pub fn pipeline_statistics<'a>(&'a self) -> QueryPipelineStatisticFlags {
        QueryPipelineStatisticFlags::from_bits(self.raw.pipelineStatistics)
            .expect("CommandBufferInheritanceInfo::pipeline_statistics: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_render_pass<'m, H>(&mut self, render_pass: H)
            where H: Handle<Target=RenderPassHandle> {
        self.raw.renderPass = render_pass.handle().0;
    }

    pub fn set_subpass<'m>(&mut self, subpass: u32) {
        self.raw.subpass = subpass.into();
    }

    pub fn set_framebuffer<'m, H>(&mut self, framebuffer: H)
            where H: Handle<Target=FramebufferHandle> {
        self.raw.framebuffer = framebuffer.handle().0;
    }

    pub fn set_occlusion_query_enable<'m>(&mut self, occlusion_query_enable: bool) {
        self.raw.occlusionQueryEnable = occlusion_query_enable as u32;
    }

    pub fn set_query_flags<'m>(&mut self, query_flags: QueryControlFlags) {
        self.raw.queryFlags = query_flags.bits();
    }

    pub fn set_pipeline_statistics<'m>(&mut self, pipeline_statistics: QueryPipelineStatisticFlags) {
        self.raw.pipelineStatistics = pipeline_statistics.bits();
    }

    pub fn as_raw(&self) -> &vks::VkCommandBufferInheritanceInfo {
        &self.raw
    }
}

impl<'s> From<CommandBufferInheritanceInfo<'s>> for vks::VkCommandBufferInheritanceInfo {
    fn from(f: CommandBufferInheritanceInfo<'s>) -> vks::VkCommandBufferInheritanceInfo {
        f.raw
    }
}


/// A builder for `VkCommandBufferInheritanceInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct CommandBufferInheritanceInfoBuilder<'b> {
    raw: vks::VkCommandBufferInheritanceInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> CommandBufferInheritanceInfoBuilder<'b> {
    pub fn new() -> CommandBufferInheritanceInfoBuilder<'b> {
        CommandBufferInheritanceInfoBuilder {
            raw: vks::VkCommandBufferInheritanceInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> CommandBufferInheritanceInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn render_pass<'m, H>(mut self, render_pass: H) -> CommandBufferInheritanceInfoBuilder<'b>
            where H: Handle<Target=RenderPassHandle> {
        self.raw.renderPass = render_pass.handle().0;
        self
    }

    pub fn subpass<'m>(mut self, subpass: u32) -> CommandBufferInheritanceInfoBuilder<'b> {
        self.raw.subpass = subpass.into();
        self
    }

    pub fn framebuffer<'m, H>(mut self, framebuffer: H) -> CommandBufferInheritanceInfoBuilder<'b>
            where H: Handle<Target=FramebufferHandle> {
        self.raw.framebuffer = framebuffer.handle().0;
        self
    }

    pub fn occlusion_query_enable<'m>(mut self, occlusion_query_enable: bool) -> CommandBufferInheritanceInfoBuilder<'b> {
        self.raw.occlusionQueryEnable = occlusion_query_enable as u32;
        self
    }

    pub fn query_flags<'m>(mut self, query_flags: QueryControlFlags) -> CommandBufferInheritanceInfoBuilder<'b> {
        self.raw.queryFlags = query_flags.bits();
        self
    }

    pub fn pipeline_statistics<'m>(mut self, pipeline_statistics: QueryPipelineStatisticFlags) -> CommandBufferInheritanceInfoBuilder<'b> {
        self.raw.pipelineStatistics = pipeline_statistics.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_render_pass<'a>(&'a self) -> vks::VkRenderPass {
        self.raw.renderPass
    }

    pub fn get_subpass<'a>(&'a self) -> u32 {
        self.raw.subpass.into()
    }

    pub fn get_framebuffer<'a>(&'a self) -> vks::VkFramebuffer {
        self.raw.framebuffer
    }

    pub fn get_occlusion_query_enable<'a>(&'a self) -> bool {
        self.raw.occlusionQueryEnable != 0
    }

    pub fn get_query_flags<'a>(&'a self) -> QueryControlFlags {
        QueryControlFlags::from_bits(self.raw.queryFlags)
            .expect("CommandBufferInheritanceInfo::query_flags: error converting flags")
    }

    pub fn get_pipeline_statistics<'a>(&'a self) -> QueryPipelineStatisticFlags {
        QueryPipelineStatisticFlags::from_bits(self.raw.pipelineStatistics)
            .expect("CommandBufferInheritanceInfo::pipeline_statistics: error converting flags")
    }

    pub fn build(self) -> CommandBufferInheritanceInfo<'b> {
        CommandBufferInheritanceInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkCommandBufferBeginInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct CommandBufferBeginInfo<'s> {
    raw: vks::VkCommandBufferBeginInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> CommandBufferBeginInfo<'s> {
    pub fn builder<'b>() -> CommandBufferBeginInfoBuilder<'b> {
        CommandBufferBeginInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkCommandBufferBeginInfo) -> CommandBufferBeginInfo<'s> {
        CommandBufferBeginInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> CommandBufferUsageFlags {
        CommandBufferUsageFlags::from_bits(self.raw.flags)
            .expect("CommandBufferBeginInfo::flags: error converting flags")
    }

    pub fn inheritance_info<'a>(&'a self) -> &'a CommandBufferInheritanceInfo {
        unsafe { &*(self.raw.pInheritanceInfo as *const vks::VkCommandBufferInheritanceInfo as *const _) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: CommandBufferUsageFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_inheritance_info<'m, 'a>(&mut self, inheritance_info: &'a CommandBufferInheritanceInfo)
            where 'a: 's {
        self.raw.pInheritanceInfo = inheritance_info.as_raw();
    }

    pub fn as_raw(&self) -> &vks::VkCommandBufferBeginInfo {
        &self.raw
    }
}

impl<'s> From<CommandBufferBeginInfo<'s>> for vks::VkCommandBufferBeginInfo {
    fn from(f: CommandBufferBeginInfo<'s>) -> vks::VkCommandBufferBeginInfo {
        f.raw
    }
}


/// A builder for `VkCommandBufferBeginInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct CommandBufferBeginInfoBuilder<'b> {
    raw: vks::VkCommandBufferBeginInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> CommandBufferBeginInfoBuilder<'b> {
    pub fn new() -> CommandBufferBeginInfoBuilder<'b> {
        CommandBufferBeginInfoBuilder {
            raw: vks::VkCommandBufferBeginInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> CommandBufferBeginInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: CommandBufferUsageFlags) -> CommandBufferBeginInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn inheritance_info<'m, 'a>(mut self, inheritance_info: &'a CommandBufferInheritanceInfo) -> CommandBufferBeginInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pInheritanceInfo = inheritance_info.as_raw();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> CommandBufferUsageFlags {
        CommandBufferUsageFlags::from_bits(self.raw.flags)
            .expect("CommandBufferBeginInfo::flags: error converting flags")
    }

    pub fn get_inheritance_info<'a>(&'a self) -> &'a CommandBufferInheritanceInfo {
        unsafe { &*(self.raw.pInheritanceInfo as *const vks::VkCommandBufferInheritanceInfo as *const _) }
    }

    pub fn build(self) -> CommandBufferBeginInfo<'b> {
        CommandBufferBeginInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkRenderPassBeginInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct RenderPassBeginInfo<'s> {
    raw: vks::VkRenderPassBeginInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> RenderPassBeginInfo<'s> {
    pub fn builder<'b>() -> RenderPassBeginInfoBuilder<'b> {
        RenderPassBeginInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkRenderPassBeginInfo) -> RenderPassBeginInfo<'s> {
        RenderPassBeginInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn render_pass<'a>(&'a self) -> vks::VkRenderPass {
        self.raw.renderPass
    }

    pub fn framebuffer<'a>(&'a self) -> vks::VkFramebuffer {
        self.raw.framebuffer
    }

    pub fn render_area<'a>(&'a self) -> &'a Rect2d {
        unsafe { &*(&self.raw.renderArea as *const vks::VkRect2D as *const Rect2d) }
    }

    pub fn render_area_mut<'a>(&'a mut self) -> &'a mut Rect2d {
        unsafe { &mut *(&mut self.raw.renderArea as *mut  vks::VkRect2D as *mut Rect2d) }
    }

    pub fn clear_values<'a>(&'a self) -> &'a [ClearValue] {
        unsafe { slice::from_raw_parts(self.raw.pClearValues as *const _, self.raw.clearValueCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_render_pass<'m, H>(&mut self, render_pass: H)
            where H: Handle<Target=RenderPassHandle> {
        self.raw.renderPass = render_pass.handle().0;
    }

    pub fn set_framebuffer<'m, H>(&mut self, framebuffer: H)
            where H: Handle<Target=FramebufferHandle> {
        self.raw.framebuffer = framebuffer.handle().0;
    }

    pub fn set_render_area<'m>(&mut self, render_area: Rect2d) {
        self.raw.renderArea = render_area.raw;
    }

    pub fn set_clear_values<'m, 'a>(&mut self, clear_values: &'a [ClearValue])
            where 'a: 's {
        assert!(self.raw.clearValueCount == 0 || self.raw.clearValueCount == clear_values.len() as _, 
            "count inconsistency found when specifying `RenderPassBeginInfo::clear_values`.");
        self.raw.clearValueCount = clear_values.len() as _;
        self.raw.pClearValues = clear_values.as_ptr() as *const ClearValue as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkRenderPassBeginInfo {
        &self.raw
    }
}

impl<'s> From<RenderPassBeginInfo<'s>> for vks::VkRenderPassBeginInfo {
    fn from(f: RenderPassBeginInfo<'s>) -> vks::VkRenderPassBeginInfo {
        f.raw
    }
}


/// A builder for `VkRenderPassBeginInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct RenderPassBeginInfoBuilder<'b> {
    raw: vks::VkRenderPassBeginInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> RenderPassBeginInfoBuilder<'b> {
    pub fn new() -> RenderPassBeginInfoBuilder<'b> {
        RenderPassBeginInfoBuilder {
            raw: vks::VkRenderPassBeginInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> RenderPassBeginInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn render_pass<'m, H>(mut self, render_pass: H) -> RenderPassBeginInfoBuilder<'b>
            where H: Handle<Target=RenderPassHandle> {
        self.raw.renderPass = render_pass.handle().0;
        self
    }

    pub fn framebuffer<'m, H>(mut self, framebuffer: H) -> RenderPassBeginInfoBuilder<'b>
            where H: Handle<Target=FramebufferHandle> {
        self.raw.framebuffer = framebuffer.handle().0;
        self
    }

    pub fn render_area<'m>(mut self, render_area: Rect2d) -> RenderPassBeginInfoBuilder<'b> {
        self.raw.renderArea = render_area.raw;
        self
    }

    pub fn clear_values<'m, 'a>(mut self, clear_values: &'a [ClearValue]) -> RenderPassBeginInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.clearValueCount == 0 || self.raw.clearValueCount == clear_values.len() as _, 
            "count inconsistency found when specifying `RenderPassBeginInfo::clear_values`.");
        self.raw.clearValueCount = clear_values.len() as _;
        self.raw.pClearValues = clear_values.as_ptr() as *const ClearValue as *const _;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_render_pass<'a>(&'a self) -> vks::VkRenderPass {
        self.raw.renderPass
    }

    pub fn get_framebuffer<'a>(&'a self) -> vks::VkFramebuffer {
        self.raw.framebuffer
    }

    pub fn get_render_area<'a>(&'a self) -> &'a Rect2d {
        unsafe { &*(&self.raw.renderArea as *const vks::VkRect2D as *const Rect2d) }
    }

    pub fn get_render_area_mut<'a>(&'a mut self) -> &'a mut Rect2d {
        unsafe { &mut *(&mut self.raw.renderArea as *mut  vks::VkRect2D as *mut Rect2d) }
    }

    pub fn get_clear_values<'a>(&'a self) -> &'a [ClearValue] {
        unsafe { slice::from_raw_parts(self.raw.pClearValues as *const _, self.raw.clearValueCount as usize) }
    }

    pub fn build(self) -> RenderPassBeginInfo<'b> {
        RenderPassBeginInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkClearDepthStencilValue`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ClearDepthStencilValue {
    raw: vks::VkClearDepthStencilValue,
}

impl ClearDepthStencilValue {
    pub fn builder() -> ClearDepthStencilValueBuilder {
        ClearDepthStencilValueBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkClearDepthStencilValue) -> ClearDepthStencilValue {
        ClearDepthStencilValue { raw, }
    }

    pub fn depth<'a>(&'a self) -> f32 {
        self.raw.depth.into()
    }

    pub fn stencil<'a>(&'a self) -> u32 {
        self.raw.stencil.into()
    }

    pub fn set_depth<'m>(&mut self, depth: f32) {
        self.raw.depth = depth.into();
    }

    pub fn set_stencil<'m>(&mut self, stencil: u32) {
        self.raw.stencil = stencil.into();
    }

    pub fn as_raw(&self) -> &vks::VkClearDepthStencilValue {
        &self.raw
    }
}

impl From<ClearDepthStencilValue> for vks::VkClearDepthStencilValue {
    fn from(f: ClearDepthStencilValue) -> vks::VkClearDepthStencilValue {
        f.raw
    }
}


/// A builder for `VkClearDepthStencilValue`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ClearDepthStencilValueBuilder {
    raw: vks::VkClearDepthStencilValue,
}

impl ClearDepthStencilValueBuilder {
    pub fn new() -> ClearDepthStencilValueBuilder {
        ClearDepthStencilValueBuilder {
            raw: vks::VkClearDepthStencilValue::default(),
        }
    }

    pub fn depth<'m>(mut self, depth: f32) -> ClearDepthStencilValueBuilder {
        self.raw.depth = depth.into();
        self
    }

    pub fn stencil<'m>(mut self, stencil: u32) -> ClearDepthStencilValueBuilder {
        self.raw.stencil = stencil.into();
        self
    }

    pub fn get_depth<'a>(&'a self) -> f32 {
        self.raw.depth.into()
    }

    pub fn get_stencil<'a>(&'a self) -> u32 {
        self.raw.stencil.into()
    }

    pub fn build(self) -> ClearDepthStencilValue {
        ClearDepthStencilValue {
            raw: self.raw,
        }
    }
}


/// A `VkClearAttachment`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ClearAttachment {
    raw: vks::VkClearAttachment,
}

impl ClearAttachment {
    pub fn builder() -> ClearAttachmentBuilder {
        ClearAttachmentBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkClearAttachment) -> ClearAttachment {
        ClearAttachment { raw, }
    }

    pub fn aspect_mask<'a>(&'a self) -> ImageAspectFlags {
        ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("ClearAttachment::aspect_mask: error converting flags")
    }

    pub fn color_attachment<'a>(&'a self) -> u32 {
        self.raw.colorAttachment.into()
    }

    pub fn clear_value<'a>(&'a self) -> ClearValue {
        self.raw.clearValue.into()
    }

    pub fn set_aspect_mask<'m>(&mut self, aspect_mask: ImageAspectFlags) {
        self.raw.aspectMask = aspect_mask.bits();
    }

    pub fn set_color_attachment<'m>(&mut self, color_attachment: u32) {
        self.raw.colorAttachment = color_attachment.into();
    }

    pub fn set_clear_value<'m>(&mut self, clear_value: ClearValue) {
        self.raw.clearValue = clear_value.into();
    }

    pub fn as_raw(&self) -> &vks::VkClearAttachment {
        &self.raw
    }
}

impl From<ClearAttachment> for vks::VkClearAttachment {
    fn from(f: ClearAttachment) -> vks::VkClearAttachment {
        f.raw
    }
}


/// A builder for `VkClearAttachment`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ClearAttachmentBuilder {
    raw: vks::VkClearAttachment,
}

impl ClearAttachmentBuilder {
    pub fn new() -> ClearAttachmentBuilder {
        ClearAttachmentBuilder {
            raw: vks::VkClearAttachment::default(),
        }
    }

    pub fn aspect_mask<'m>(mut self, aspect_mask: ImageAspectFlags) -> ClearAttachmentBuilder {
        self.raw.aspectMask = aspect_mask.bits();
        self
    }

    pub fn color_attachment<'m>(mut self, color_attachment: u32) -> ClearAttachmentBuilder {
        self.raw.colorAttachment = color_attachment.into();
        self
    }

    pub fn clear_value<'m>(mut self, clear_value: ClearValue) -> ClearAttachmentBuilder {
        self.raw.clearValue = clear_value.into();
        self
    }

    pub fn get_aspect_mask<'a>(&'a self) -> ImageAspectFlags {
        ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("ClearAttachment::aspect_mask: error converting flags")
    }

    pub fn get_color_attachment<'a>(&'a self) -> u32 {
        self.raw.colorAttachment.into()
    }

    pub fn get_clear_value<'a>(&'a self) -> ClearValue {
        self.raw.clearValue.into()
    }

    pub fn build(self) -> ClearAttachment {
        ClearAttachment {
            raw: self.raw,
        }
    }
}


/// A `VkAttachmentDescription`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct AttachmentDescription {
    raw: vks::VkAttachmentDescription,
}

impl AttachmentDescription {
    pub fn builder() -> AttachmentDescriptionBuilder {
        AttachmentDescriptionBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkAttachmentDescription) -> AttachmentDescription {
        AttachmentDescription { raw, }
    }

    pub fn flags<'a>(&'a self) -> AttachmentDescriptionFlags {
        AttachmentDescriptionFlags::from_bits(self.raw.flags)
            .expect("AttachmentDescription::flags: error converting flags")
    }

    pub fn format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn samples<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.samples)
            .expect("AttachmentDescription::samples: error converting flags")
    }

    pub fn load_op<'a>(&'a self) -> AttachmentLoadOp {
        self.raw.loadOp.into()
    }

    pub fn store_op<'a>(&'a self) -> AttachmentStoreOp {
        self.raw.storeOp.into()
    }

    pub fn stencil_load_op<'a>(&'a self) -> AttachmentLoadOp {
        self.raw.stencilLoadOp.into()
    }

    pub fn stencil_store_op<'a>(&'a self) -> AttachmentStoreOp {
        self.raw.stencilStoreOp.into()
    }

    pub fn initial_layout<'a>(&'a self) -> ImageLayout {
        self.raw.initialLayout.into()
    }

    pub fn final_layout<'a>(&'a self) -> ImageLayout {
        self.raw.finalLayout.into()
    }

    pub fn set_flags<'m>(&mut self, flags: AttachmentDescriptionFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_format<'m>(&mut self, format: Format) {
        self.raw.format = format.into();
    }

    pub fn set_samples<'m>(&mut self, samples: SampleCountFlags) {
        self.raw.samples = samples.bits();
    }

    pub fn set_load_op<'m>(&mut self, load_op: AttachmentLoadOp) {
        self.raw.loadOp = load_op.into();
    }

    pub fn set_store_op<'m>(&mut self, store_op: AttachmentStoreOp) {
        self.raw.storeOp = store_op.into();
    }

    pub fn set_stencil_load_op<'m>(&mut self, stencil_load_op: AttachmentLoadOp) {
        self.raw.stencilLoadOp = stencil_load_op.into();
    }

    pub fn set_stencil_store_op<'m>(&mut self, stencil_store_op: AttachmentStoreOp) {
        self.raw.stencilStoreOp = stencil_store_op.into();
    }

    pub fn set_initial_layout<'m>(&mut self, initial_layout: ImageLayout) {
        self.raw.initialLayout = initial_layout.into();
    }

    pub fn set_final_layout<'m>(&mut self, final_layout: ImageLayout) {
        self.raw.finalLayout = final_layout.into();
    }

    pub fn as_raw(&self) -> &vks::VkAttachmentDescription {
        &self.raw
    }
}

impl From<AttachmentDescription> for vks::VkAttachmentDescription {
    fn from(f: AttachmentDescription) -> vks::VkAttachmentDescription {
        f.raw
    }
}


/// A builder for `VkAttachmentDescription`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct AttachmentDescriptionBuilder {
    raw: vks::VkAttachmentDescription,
}

impl AttachmentDescriptionBuilder {
    pub fn new() -> AttachmentDescriptionBuilder {
        AttachmentDescriptionBuilder {
            raw: vks::VkAttachmentDescription::default(),
        }
    }

    pub fn flags<'m>(mut self, flags: AttachmentDescriptionFlags) -> AttachmentDescriptionBuilder {
        self.raw.flags = flags.bits();
        self
    }

    pub fn format<'m>(mut self, format: Format) -> AttachmentDescriptionBuilder {
        self.raw.format = format.into();
        self
    }

    pub fn samples<'m>(mut self, samples: SampleCountFlags) -> AttachmentDescriptionBuilder {
        self.raw.samples = samples.bits();
        self
    }

    pub fn load_op<'m>(mut self, load_op: AttachmentLoadOp) -> AttachmentDescriptionBuilder {
        self.raw.loadOp = load_op.into();
        self
    }

    pub fn store_op<'m>(mut self, store_op: AttachmentStoreOp) -> AttachmentDescriptionBuilder {
        self.raw.storeOp = store_op.into();
        self
    }

    pub fn stencil_load_op<'m>(mut self, stencil_load_op: AttachmentLoadOp) -> AttachmentDescriptionBuilder {
        self.raw.stencilLoadOp = stencil_load_op.into();
        self
    }

    pub fn stencil_store_op<'m>(mut self, stencil_store_op: AttachmentStoreOp) -> AttachmentDescriptionBuilder {
        self.raw.stencilStoreOp = stencil_store_op.into();
        self
    }

    pub fn initial_layout<'m>(mut self, initial_layout: ImageLayout) -> AttachmentDescriptionBuilder {
        self.raw.initialLayout = initial_layout.into();
        self
    }

    pub fn final_layout<'m>(mut self, final_layout: ImageLayout) -> AttachmentDescriptionBuilder {
        self.raw.finalLayout = final_layout.into();
        self
    }

    pub fn get_flags<'a>(&'a self) -> AttachmentDescriptionFlags {
        AttachmentDescriptionFlags::from_bits(self.raw.flags)
            .expect("AttachmentDescription::flags: error converting flags")
    }

    pub fn get_format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn get_samples<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.samples)
            .expect("AttachmentDescription::samples: error converting flags")
    }

    pub fn get_load_op<'a>(&'a self) -> AttachmentLoadOp {
        self.raw.loadOp.into()
    }

    pub fn get_store_op<'a>(&'a self) -> AttachmentStoreOp {
        self.raw.storeOp.into()
    }

    pub fn get_stencil_load_op<'a>(&'a self) -> AttachmentLoadOp {
        self.raw.stencilLoadOp.into()
    }

    pub fn get_stencil_store_op<'a>(&'a self) -> AttachmentStoreOp {
        self.raw.stencilStoreOp.into()
    }

    pub fn get_initial_layout<'a>(&'a self) -> ImageLayout {
        self.raw.initialLayout.into()
    }

    pub fn get_final_layout<'a>(&'a self) -> ImageLayout {
        self.raw.finalLayout.into()
    }

    pub fn build(self) -> AttachmentDescription {
        AttachmentDescription {
            raw: self.raw,
        }
    }
}


/// A `VkAttachmentReference`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct AttachmentReference {
    raw: vks::VkAttachmentReference,
}

impl AttachmentReference {
    pub fn builder() -> AttachmentReferenceBuilder {
        AttachmentReferenceBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkAttachmentReference) -> AttachmentReference {
        AttachmentReference { raw, }
    }

    pub fn attachment<'a>(&'a self) -> u32 {
        self.raw.attachment.into()
    }

    pub fn layout<'a>(&'a self) -> ImageLayout {
        self.raw.layout.into()
    }

    pub fn set_attachment<'m>(&mut self, attachment: u32) {
        self.raw.attachment = attachment.into();
    }

    pub fn set_layout<'m>(&mut self, layout: ImageLayout) {
        self.raw.layout = layout.into();
    }

    pub fn as_raw(&self) -> &vks::VkAttachmentReference {
        &self.raw
    }
}

impl From<AttachmentReference> for vks::VkAttachmentReference {
    fn from(f: AttachmentReference) -> vks::VkAttachmentReference {
        f.raw
    }
}


/// A builder for `VkAttachmentReference`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct AttachmentReferenceBuilder {
    raw: vks::VkAttachmentReference,
}

impl AttachmentReferenceBuilder {
    pub fn new() -> AttachmentReferenceBuilder {
        AttachmentReferenceBuilder {
            raw: vks::VkAttachmentReference::default(),
        }
    }

    pub fn attachment<'m>(mut self, attachment: u32) -> AttachmentReferenceBuilder {
        self.raw.attachment = attachment.into();
        self
    }

    pub fn layout<'m>(mut self, layout: ImageLayout) -> AttachmentReferenceBuilder {
        self.raw.layout = layout.into();
        self
    }

    pub fn get_attachment<'a>(&'a self) -> u32 {
        self.raw.attachment.into()
    }

    pub fn get_layout<'a>(&'a self) -> ImageLayout {
        self.raw.layout.into()
    }

    pub fn build(self) -> AttachmentReference {
        AttachmentReference {
            raw: self.raw,
        }
    }
}


/// A `VkSubpassDescription`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SubpassDescription<'s> {
    raw: vks::VkSubpassDescription,
    _p: PhantomData<&'s ()>,
}

impl<'s> SubpassDescription<'s> {
    pub fn builder<'b>() -> SubpassDescriptionBuilder<'b> {
        SubpassDescriptionBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSubpassDescription) -> SubpassDescription<'s> {
        SubpassDescription { raw, _p: PhantomData }
    }

    pub fn flags<'a>(&'a self) -> SubpassDescriptionFlags {
        SubpassDescriptionFlags::from_bits(self.raw.flags)
            .expect("SubpassDescription::flags: error converting flags")
    }

    pub fn pipeline_bind_point<'a>(&'a self) -> PipelineBindPoint {
        self.raw.pipelineBindPoint.into()
    }

    pub fn input_attachments<'a>(&'a self) -> &'a [AttachmentReference] {
        unsafe { slice::from_raw_parts(self.raw.pInputAttachments as *const _, self.raw.inputAttachmentCount as usize) }
    }

    pub fn color_attachments<'a>(&'a self) -> &'a [AttachmentReference] {
        unsafe { slice::from_raw_parts(self.raw.pColorAttachments as *const _, self.raw.colorAttachmentCount as usize) }
    }

    pub fn resolve_attachments<'a>(&'a self) -> &'a [AttachmentReference] {
        unsafe { slice::from_raw_parts(self.raw.pResolveAttachments as *const _, self.raw.colorAttachmentCount as usize) }
    }

    pub fn depth_stencil_attachment<'a>(&'a self) -> &'a AttachmentReference {
        unsafe { &*(self.raw.pDepthStencilAttachment as *const vks::VkAttachmentReference as *const _) }
    }

    pub fn preserve_attachments<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pPreserveAttachments as *const _, self.raw.preserveAttachmentCount as usize) }
    }

    pub fn set_flags<'m>(&mut self, flags: SubpassDescriptionFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_pipeline_bind_point<'m>(&mut self, pipeline_bind_point: PipelineBindPoint) {
        self.raw.pipelineBindPoint = pipeline_bind_point.into();
    }

    pub fn set_input_attachments<'m, 'a>(&mut self, input_attachments: &'a [AttachmentReference])
            where 'a: 's {
        assert!(self.raw.inputAttachmentCount == 0 || self.raw.inputAttachmentCount == input_attachments.len() as _, 
            "count inconsistency found when specifying `SubpassDescription::input_attachments`.");
        self.raw.inputAttachmentCount = input_attachments.len() as _;
        self.raw.pInputAttachments = input_attachments.as_ptr() as *const vks::VkAttachmentReference;
    }

    pub fn set_color_attachments<'m, 'a>(&mut self, color_attachments: &'a [AttachmentReference])
            where 'a: 's {
        assert!(self.raw.colorAttachmentCount == 0 || self.raw.colorAttachmentCount == color_attachments.len() as _, 
            "count inconsistency found when specifying `SubpassDescription::color_attachments`.");
        self.raw.colorAttachmentCount = color_attachments.len() as _;
        self.raw.pColorAttachments = color_attachments.as_ptr() as *const vks::VkAttachmentReference;
    }

    pub fn set_resolve_attachments<'m, 'a>(&mut self, resolve_attachments: &'a [AttachmentReference])
            where 'a: 's {
        assert!(self.raw.colorAttachmentCount == 0 || self.raw.colorAttachmentCount == resolve_attachments.len() as _, 
            "count inconsistency found when specifying `SubpassDescription::resolve_attachments`.");
        self.raw.colorAttachmentCount = resolve_attachments.len() as _;
        self.raw.pResolveAttachments = resolve_attachments.as_ptr() as *const vks::VkAttachmentReference;
    }

    pub fn set_depth_stencil_attachment<'m, 'a>(&mut self, depth_stencil_attachment: &'a AttachmentReference)
            where 'a: 's {
        self.raw.pDepthStencilAttachment = depth_stencil_attachment.as_raw();
    }

    pub fn set_preserve_attachments<'m, 'a>(&mut self, preserve_attachments: &'a [u32])
            where 'a: 's {
        assert!(self.raw.preserveAttachmentCount == 0 || self.raw.preserveAttachmentCount == preserve_attachments.len() as _, 
            "count inconsistency found when specifying `SubpassDescription::preserve_attachments`.");
        self.raw.preserveAttachmentCount = preserve_attachments.len() as _;
        self.raw.pPreserveAttachments = preserve_attachments.as_ptr() as *const u32 as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkSubpassDescription {
        &self.raw
    }
}

impl<'s> From<SubpassDescription<'s>> for vks::VkSubpassDescription {
    fn from(f: SubpassDescription<'s>) -> vks::VkSubpassDescription {
        f.raw
    }
}


/// A builder for `VkSubpassDescription`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SubpassDescriptionBuilder<'b> {
    raw: vks::VkSubpassDescription,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SubpassDescriptionBuilder<'b> {
    pub fn new() -> SubpassDescriptionBuilder<'b> {
        SubpassDescriptionBuilder {
            raw: vks::VkSubpassDescription::default(),
            _p: PhantomData,
        }
    }

    pub fn flags<'m>(mut self, flags: SubpassDescriptionFlags) -> SubpassDescriptionBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn pipeline_bind_point<'m>(mut self, pipeline_bind_point: PipelineBindPoint) -> SubpassDescriptionBuilder<'b> {
        self.raw.pipelineBindPoint = pipeline_bind_point.into();
        self
    }

    pub fn input_attachments<'m, 'a>(mut self, input_attachments: &'a [AttachmentReference]) -> SubpassDescriptionBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.inputAttachmentCount == 0 || self.raw.inputAttachmentCount == input_attachments.len() as _, 
            "count inconsistency found when specifying `SubpassDescription::input_attachments`.");
        self.raw.inputAttachmentCount = input_attachments.len() as _;
        self.raw.pInputAttachments = input_attachments.as_ptr() as *const vks::VkAttachmentReference;
        self
    }

    pub fn color_attachments<'m, 'a>(mut self, color_attachments: &'a [AttachmentReference]) -> SubpassDescriptionBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.colorAttachmentCount == 0 || self.raw.colorAttachmentCount == color_attachments.len() as _, 
            "count inconsistency found when specifying `SubpassDescription::color_attachments`.");
        self.raw.colorAttachmentCount = color_attachments.len() as _;
        self.raw.pColorAttachments = color_attachments.as_ptr() as *const vks::VkAttachmentReference;
        self
    }

    pub fn resolve_attachments<'m, 'a>(mut self, resolve_attachments: &'a [AttachmentReference]) -> SubpassDescriptionBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.colorAttachmentCount == 0 || self.raw.colorAttachmentCount == resolve_attachments.len() as _, 
            "count inconsistency found when specifying `SubpassDescription::resolve_attachments`.");
        self.raw.colorAttachmentCount = resolve_attachments.len() as _;
        self.raw.pResolveAttachments = resolve_attachments.as_ptr() as *const vks::VkAttachmentReference;
        self
    }

    pub fn depth_stencil_attachment<'m, 'a>(mut self, depth_stencil_attachment: &'a AttachmentReference) -> SubpassDescriptionBuilder<'b>
            where 'a: 'b {
        self.raw.pDepthStencilAttachment = depth_stencil_attachment.as_raw();
        self
    }

    pub fn preserve_attachments<'m, 'a>(mut self, preserve_attachments: &'a [u32]) -> SubpassDescriptionBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.preserveAttachmentCount == 0 || self.raw.preserveAttachmentCount == preserve_attachments.len() as _, 
            "count inconsistency found when specifying `SubpassDescription::preserve_attachments`.");
        self.raw.preserveAttachmentCount = preserve_attachments.len() as _;
        self.raw.pPreserveAttachments = preserve_attachments.as_ptr() as *const u32 as *const _;
        self
    }

    pub fn get_flags<'a>(&'a self) -> SubpassDescriptionFlags {
        SubpassDescriptionFlags::from_bits(self.raw.flags)
            .expect("SubpassDescription::flags: error converting flags")
    }

    pub fn get_pipeline_bind_point<'a>(&'a self) -> PipelineBindPoint {
        self.raw.pipelineBindPoint.into()
    }

    pub fn get_input_attachments<'a>(&'a self) -> &'a [AttachmentReference] {
        unsafe { slice::from_raw_parts(self.raw.pInputAttachments as *const _, self.raw.inputAttachmentCount as usize) }
    }

    pub fn get_color_attachments<'a>(&'a self) -> &'a [AttachmentReference] {
        unsafe { slice::from_raw_parts(self.raw.pColorAttachments as *const _, self.raw.colorAttachmentCount as usize) }
    }

    pub fn get_resolve_attachments<'a>(&'a self) -> &'a [AttachmentReference] {
        unsafe { slice::from_raw_parts(self.raw.pResolveAttachments as *const _, self.raw.colorAttachmentCount as usize) }
    }

    pub fn get_depth_stencil_attachment<'a>(&'a self) -> &'a AttachmentReference {
        unsafe { &*(self.raw.pDepthStencilAttachment as *const vks::VkAttachmentReference as *const _) }
    }

    pub fn get_preserve_attachments<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pPreserveAttachments as *const _, self.raw.preserveAttachmentCount as usize) }
    }

    pub fn build(self) -> SubpassDescription<'b> {
        SubpassDescription {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSubpassDependency`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SubpassDependency {
    raw: vks::VkSubpassDependency,
}

impl SubpassDependency {
    pub fn builder() -> SubpassDependencyBuilder {
        SubpassDependencyBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSubpassDependency) -> SubpassDependency {
        SubpassDependency { raw, }
    }

    pub fn src_subpass<'a>(&'a self) -> u32 {
        self.raw.srcSubpass.into()
    }

    pub fn dst_subpass<'a>(&'a self) -> u32 {
        self.raw.dstSubpass.into()
    }

    pub fn src_stage_mask<'a>(&'a self) -> PipelineStageFlags {
        PipelineStageFlags::from_bits(self.raw.srcStageMask)
            .expect("SubpassDependency::src_stage_mask: error converting flags")
    }

    pub fn dst_stage_mask<'a>(&'a self) -> PipelineStageFlags {
        PipelineStageFlags::from_bits(self.raw.dstStageMask)
            .expect("SubpassDependency::dst_stage_mask: error converting flags")
    }

    pub fn src_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.srcAccessMask)
            .expect("SubpassDependency::src_access_mask: error converting flags")
    }

    pub fn dst_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.dstAccessMask)
            .expect("SubpassDependency::dst_access_mask: error converting flags")
    }

    pub fn dependency_flags<'a>(&'a self) -> DependencyFlags {
        DependencyFlags::from_bits(self.raw.dependencyFlags)
            .expect("SubpassDependency::dependency_flags: error converting flags")
    }

    pub fn set_src_subpass<'m>(&mut self, src_subpass: u32) {
        self.raw.srcSubpass = src_subpass.into();
    }

    pub fn set_dst_subpass<'m>(&mut self, dst_subpass: u32) {
        self.raw.dstSubpass = dst_subpass.into();
    }

    pub fn set_src_stage_mask<'m>(&mut self, src_stage_mask: PipelineStageFlags) {
        self.raw.srcStageMask = src_stage_mask.bits();
    }

    pub fn set_dst_stage_mask<'m>(&mut self, dst_stage_mask: PipelineStageFlags) {
        self.raw.dstStageMask = dst_stage_mask.bits();
    }

    pub fn set_src_access_mask<'m>(&mut self, src_access_mask: AccessFlags) {
        self.raw.srcAccessMask = src_access_mask.bits();
    }

    pub fn set_dst_access_mask<'m>(&mut self, dst_access_mask: AccessFlags) {
        self.raw.dstAccessMask = dst_access_mask.bits();
    }

    pub fn set_dependency_flags<'m>(&mut self, dependency_flags: DependencyFlags) {
        self.raw.dependencyFlags = dependency_flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSubpassDependency {
        &self.raw
    }
}

impl From<SubpassDependency> for vks::VkSubpassDependency {
    fn from(f: SubpassDependency) -> vks::VkSubpassDependency {
        f.raw
    }
}


/// A builder for `VkSubpassDependency`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SubpassDependencyBuilder {
    raw: vks::VkSubpassDependency,
}

impl SubpassDependencyBuilder {
    pub fn new() -> SubpassDependencyBuilder {
        SubpassDependencyBuilder {
            raw: vks::VkSubpassDependency::default(),
        }
    }

    pub fn src_subpass<'m>(mut self, src_subpass: u32) -> SubpassDependencyBuilder {
        self.raw.srcSubpass = src_subpass.into();
        self
    }

    pub fn dst_subpass<'m>(mut self, dst_subpass: u32) -> SubpassDependencyBuilder {
        self.raw.dstSubpass = dst_subpass.into();
        self
    }

    pub fn src_stage_mask<'m>(mut self, src_stage_mask: PipelineStageFlags) -> SubpassDependencyBuilder {
        self.raw.srcStageMask = src_stage_mask.bits();
        self
    }

    pub fn dst_stage_mask<'m>(mut self, dst_stage_mask: PipelineStageFlags) -> SubpassDependencyBuilder {
        self.raw.dstStageMask = dst_stage_mask.bits();
        self
    }

    pub fn src_access_mask<'m>(mut self, src_access_mask: AccessFlags) -> SubpassDependencyBuilder {
        self.raw.srcAccessMask = src_access_mask.bits();
        self
    }

    pub fn dst_access_mask<'m>(mut self, dst_access_mask: AccessFlags) -> SubpassDependencyBuilder {
        self.raw.dstAccessMask = dst_access_mask.bits();
        self
    }

    pub fn dependency_flags<'m>(mut self, dependency_flags: DependencyFlags) -> SubpassDependencyBuilder {
        self.raw.dependencyFlags = dependency_flags.bits();
        self
    }

    pub fn get_src_subpass<'a>(&'a self) -> u32 {
        self.raw.srcSubpass.into()
    }

    pub fn get_dst_subpass<'a>(&'a self) -> u32 {
        self.raw.dstSubpass.into()
    }

    pub fn get_src_stage_mask<'a>(&'a self) -> PipelineStageFlags {
        PipelineStageFlags::from_bits(self.raw.srcStageMask)
            .expect("SubpassDependency::src_stage_mask: error converting flags")
    }

    pub fn get_dst_stage_mask<'a>(&'a self) -> PipelineStageFlags {
        PipelineStageFlags::from_bits(self.raw.dstStageMask)
            .expect("SubpassDependency::dst_stage_mask: error converting flags")
    }

    pub fn get_src_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.srcAccessMask)
            .expect("SubpassDependency::src_access_mask: error converting flags")
    }

    pub fn get_dst_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.dstAccessMask)
            .expect("SubpassDependency::dst_access_mask: error converting flags")
    }

    pub fn get_dependency_flags<'a>(&'a self) -> DependencyFlags {
        DependencyFlags::from_bits(self.raw.dependencyFlags)
            .expect("SubpassDependency::dependency_flags: error converting flags")
    }

    pub fn build(self) -> SubpassDependency {
        SubpassDependency {
            raw: self.raw,
        }
    }
}


/// A `VkRenderPassCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct RenderPassCreateInfo<'s> {
    raw: vks::VkRenderPassCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> RenderPassCreateInfo<'s> {
    pub fn builder<'b>() -> RenderPassCreateInfoBuilder<'b> {
        RenderPassCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkRenderPassCreateInfo) -> RenderPassCreateInfo<'s> {
        RenderPassCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> RenderPassCreateFlags {
        RenderPassCreateFlags::from_bits(self.raw.flags)
            .expect("RenderPassCreateInfo::flags: error converting flags")
    }

    pub fn attachments<'a>(&'a self) -> &'a [AttachmentDescription] {
        unsafe { slice::from_raw_parts(self.raw.pAttachments as *const _, self.raw.attachmentCount as usize) }
    }

    pub fn subpasses<'a>(&'a self) -> &'a [SubpassDescription] {
        unsafe { slice::from_raw_parts(self.raw.pSubpasses as *const _, self.raw.subpassCount as usize) }
    }

    pub fn dependencies<'a>(&'a self) -> &'a [SubpassDependency] {
        unsafe { slice::from_raw_parts(self.raw.pDependencies as *const _, self.raw.dependencyCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: RenderPassCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_attachments<'m, 'a>(&mut self, attachments: &'a [AttachmentDescription])
            where 'a: 's {
        assert!(self.raw.attachmentCount == 0 || self.raw.attachmentCount == attachments.len() as _, 
            "count inconsistency found when specifying `RenderPassCreateInfo::attachments`.");
        self.raw.attachmentCount = attachments.len() as _;
        self.raw.pAttachments = attachments.as_ptr() as *const vks::VkAttachmentDescription;
    }

    pub fn set_subpasses<'m, 'a>(&mut self, subpasses: &'a [SubpassDescription])
            where 'a: 's {
        assert!(self.raw.subpassCount == 0 || self.raw.subpassCount == subpasses.len() as _, 
            "count inconsistency found when specifying `RenderPassCreateInfo::subpasses`.");
        self.raw.subpassCount = subpasses.len() as _;
        self.raw.pSubpasses = subpasses.as_ptr() as *const vks::VkSubpassDescription;
    }

    pub fn set_dependencies<'m, 'a>(&mut self, dependencies: &'a [SubpassDependency])
            where 'a: 's {
        assert!(self.raw.dependencyCount == 0 || self.raw.dependencyCount == dependencies.len() as _, 
            "count inconsistency found when specifying `RenderPassCreateInfo::dependencies`.");
        self.raw.dependencyCount = dependencies.len() as _;
        self.raw.pDependencies = dependencies.as_ptr() as *const vks::VkSubpassDependency;
    }

    pub fn as_raw(&self) -> &vks::VkRenderPassCreateInfo {
        &self.raw
    }
}

impl<'s> From<RenderPassCreateInfo<'s>> for vks::VkRenderPassCreateInfo {
    fn from(f: RenderPassCreateInfo<'s>) -> vks::VkRenderPassCreateInfo {
        f.raw
    }
}


/// A builder for `VkRenderPassCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct RenderPassCreateInfoBuilder<'b> {
    raw: vks::VkRenderPassCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> RenderPassCreateInfoBuilder<'b> {
    pub fn new() -> RenderPassCreateInfoBuilder<'b> {
        RenderPassCreateInfoBuilder {
            raw: vks::VkRenderPassCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> RenderPassCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: RenderPassCreateFlags) -> RenderPassCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn attachments<'m, 'a>(mut self, attachments: &'a [AttachmentDescription]) -> RenderPassCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.attachmentCount == 0 || self.raw.attachmentCount == attachments.len() as _, 
            "count inconsistency found when specifying `RenderPassCreateInfo::attachments`.");
        self.raw.attachmentCount = attachments.len() as _;
        self.raw.pAttachments = attachments.as_ptr() as *const vks::VkAttachmentDescription;
        self
    }

    pub fn subpasses<'m, 'a>(mut self, subpasses: &'a [SubpassDescription]) -> RenderPassCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.subpassCount == 0 || self.raw.subpassCount == subpasses.len() as _, 
            "count inconsistency found when specifying `RenderPassCreateInfo::subpasses`.");
        self.raw.subpassCount = subpasses.len() as _;
        self.raw.pSubpasses = subpasses.as_ptr() as *const vks::VkSubpassDescription;
        self
    }

    pub fn dependencies<'m, 'a>(mut self, dependencies: &'a [SubpassDependency]) -> RenderPassCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.dependencyCount == 0 || self.raw.dependencyCount == dependencies.len() as _, 
            "count inconsistency found when specifying `RenderPassCreateInfo::dependencies`.");
        self.raw.dependencyCount = dependencies.len() as _;
        self.raw.pDependencies = dependencies.as_ptr() as *const vks::VkSubpassDependency;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> RenderPassCreateFlags {
        RenderPassCreateFlags::from_bits(self.raw.flags)
            .expect("RenderPassCreateInfo::flags: error converting flags")
    }

    pub fn get_attachments<'a>(&'a self) -> &'a [AttachmentDescription] {
        unsafe { slice::from_raw_parts(self.raw.pAttachments as *const _, self.raw.attachmentCount as usize) }
    }

    pub fn get_subpasses<'a>(&'a self) -> &'a [SubpassDescription] {
        unsafe { slice::from_raw_parts(self.raw.pSubpasses as *const _, self.raw.subpassCount as usize) }
    }

    pub fn get_dependencies<'a>(&'a self) -> &'a [SubpassDependency] {
        unsafe { slice::from_raw_parts(self.raw.pDependencies as *const _, self.raw.dependencyCount as usize) }
    }

    pub fn build(self) -> RenderPassCreateInfo<'b> {
        RenderPassCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkEventCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct EventCreateInfo<'s> {
    raw: vks::VkEventCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> EventCreateInfo<'s> {
    pub fn builder<'b>() -> EventCreateInfoBuilder<'b> {
        EventCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkEventCreateInfo) -> EventCreateInfo<'s> {
        EventCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> EventCreateFlags {
        EventCreateFlags::from_bits(self.raw.flags)
            .expect("EventCreateInfo::flags: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: EventCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkEventCreateInfo {
        &self.raw
    }
}

impl<'s> From<EventCreateInfo<'s>> for vks::VkEventCreateInfo {
    fn from(f: EventCreateInfo<'s>) -> vks::VkEventCreateInfo {
        f.raw
    }
}


/// A builder for `VkEventCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct EventCreateInfoBuilder<'b> {
    raw: vks::VkEventCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> EventCreateInfoBuilder<'b> {
    pub fn new() -> EventCreateInfoBuilder<'b> {
        EventCreateInfoBuilder {
            raw: vks::VkEventCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> EventCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: EventCreateFlags) -> EventCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> EventCreateFlags {
        EventCreateFlags::from_bits(self.raw.flags)
            .expect("EventCreateInfo::flags: error converting flags")
    }

    pub fn build(self) -> EventCreateInfo<'b> {
        EventCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkFenceCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct FenceCreateInfo<'s> {
    raw: vks::VkFenceCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> FenceCreateInfo<'s> {
    pub fn builder<'b>() -> FenceCreateInfoBuilder<'b> {
        FenceCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkFenceCreateInfo) -> FenceCreateInfo<'s> {
        FenceCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> FenceCreateFlags {
        FenceCreateFlags::from_bits(self.raw.flags)
            .expect("FenceCreateInfo::flags: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: FenceCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkFenceCreateInfo {
        &self.raw
    }
}

impl<'s> From<FenceCreateInfo<'s>> for vks::VkFenceCreateInfo {
    fn from(f: FenceCreateInfo<'s>) -> vks::VkFenceCreateInfo {
        f.raw
    }
}


/// A builder for `VkFenceCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct FenceCreateInfoBuilder<'b> {
    raw: vks::VkFenceCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> FenceCreateInfoBuilder<'b> {
    pub fn new() -> FenceCreateInfoBuilder<'b> {
        FenceCreateInfoBuilder {
            raw: vks::VkFenceCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> FenceCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: FenceCreateFlags) -> FenceCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> FenceCreateFlags {
        FenceCreateFlags::from_bits(self.raw.flags)
            .expect("FenceCreateInfo::flags: error converting flags")
    }

    pub fn build(self) -> FenceCreateInfo<'b> {
        FenceCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceFeatures`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceFeatures {
    raw: vks::VkPhysicalDeviceFeatures,
}

impl PhysicalDeviceFeatures {
    pub fn builder() -> PhysicalDeviceFeaturesBuilder {
        PhysicalDeviceFeaturesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceFeatures) -> PhysicalDeviceFeatures {
        PhysicalDeviceFeatures { raw, }
    }

    pub fn robust_buffer_access<'a>(&'a self) -> bool {
        self.raw.robustBufferAccess != 0
    }

    pub fn full_draw_index_uint_32<'a>(&'a self) -> bool {
        self.raw.fullDrawIndexUint32 != 0
    }

    pub fn image_cube_array<'a>(&'a self) -> bool {
        self.raw.imageCubeArray != 0
    }

    pub fn independent_blend<'a>(&'a self) -> bool {
        self.raw.independentBlend != 0
    }

    pub fn geometry_shader<'a>(&'a self) -> bool {
        self.raw.geometryShader != 0
    }

    pub fn tessellation_shader<'a>(&'a self) -> bool {
        self.raw.tessellationShader != 0
    }

    pub fn sample_rate_shading<'a>(&'a self) -> bool {
        self.raw.sampleRateShading != 0
    }

    pub fn dual_src_blend<'a>(&'a self) -> bool {
        self.raw.dualSrcBlend != 0
    }

    pub fn logic_op<'a>(&'a self) -> bool {
        self.raw.logicOp != 0
    }

    pub fn multi_draw_indirect<'a>(&'a self) -> bool {
        self.raw.multiDrawIndirect != 0
    }

    pub fn draw_indirect_first_instance<'a>(&'a self) -> bool {
        self.raw.drawIndirectFirstInstance != 0
    }

    pub fn depth_clamp<'a>(&'a self) -> bool {
        self.raw.depthClamp != 0
    }

    pub fn depth_bias_clamp<'a>(&'a self) -> bool {
        self.raw.depthBiasClamp != 0
    }

    pub fn fill_mode_non_solid<'a>(&'a self) -> bool {
        self.raw.fillModeNonSolid != 0
    }

    pub fn depth_bounds<'a>(&'a self) -> bool {
        self.raw.depthBounds != 0
    }

    pub fn wide_lines<'a>(&'a self) -> bool {
        self.raw.wideLines != 0
    }

    pub fn large_points<'a>(&'a self) -> bool {
        self.raw.largePoints != 0
    }

    pub fn alpha_to_one<'a>(&'a self) -> bool {
        self.raw.alphaToOne != 0
    }

    pub fn multi_viewport<'a>(&'a self) -> bool {
        self.raw.multiViewport != 0
    }

    pub fn sampler_anisotropy<'a>(&'a self) -> bool {
        self.raw.samplerAnisotropy != 0
    }

    pub fn texture_compression_etc2<'a>(&'a self) -> bool {
        self.raw.textureCompressionETC2 != 0
    }

    pub fn texture_compression_astcldr<'a>(&'a self) -> bool {
        self.raw.textureCompressionASTC_LDR != 0
    }

    pub fn texture_compression_bc<'a>(&'a self) -> bool {
        self.raw.textureCompressionBC != 0
    }

    pub fn occlusion_query_precise<'a>(&'a self) -> bool {
        self.raw.occlusionQueryPrecise != 0
    }

    pub fn pipeline_statistics_query<'a>(&'a self) -> bool {
        self.raw.pipelineStatisticsQuery != 0
    }

    pub fn vertex_pipeline_stores_and_atomics<'a>(&'a self) -> bool {
        self.raw.vertexPipelineStoresAndAtomics != 0
    }

    pub fn fragment_stores_and_atomics<'a>(&'a self) -> bool {
        self.raw.fragmentStoresAndAtomics != 0
    }

    pub fn shader_tessellation_and_geometry_point_size<'a>(&'a self) -> bool {
        self.raw.shaderTessellationAndGeometryPointSize != 0
    }

    pub fn shader_image_gather_extended<'a>(&'a self) -> bool {
        self.raw.shaderImageGatherExtended != 0
    }

    pub fn shader_storage_image_extended_formats<'a>(&'a self) -> bool {
        self.raw.shaderStorageImageExtendedFormats != 0
    }

    pub fn shader_storage_image_multisample<'a>(&'a self) -> bool {
        self.raw.shaderStorageImageMultisample != 0
    }

    pub fn shader_storage_image_read_without_format<'a>(&'a self) -> bool {
        self.raw.shaderStorageImageReadWithoutFormat != 0
    }

    pub fn shader_storage_image_write_without_format<'a>(&'a self) -> bool {
        self.raw.shaderStorageImageWriteWithoutFormat != 0
    }

    pub fn shader_uniform_buffer_array_dynamic_indexing<'a>(&'a self) -> bool {
        self.raw.shaderUniformBufferArrayDynamicIndexing != 0
    }

    pub fn shader_sampled_image_array_dynamic_indexing<'a>(&'a self) -> bool {
        self.raw.shaderSampledImageArrayDynamicIndexing != 0
    }

    pub fn shader_storage_buffer_array_dynamic_indexing<'a>(&'a self) -> bool {
        self.raw.shaderStorageBufferArrayDynamicIndexing != 0
    }

    pub fn shader_storage_image_array_dynamic_indexing<'a>(&'a self) -> bool {
        self.raw.shaderStorageImageArrayDynamicIndexing != 0
    }

    pub fn shader_clip_distance<'a>(&'a self) -> bool {
        self.raw.shaderClipDistance != 0
    }

    pub fn shader_cull_distance<'a>(&'a self) -> bool {
        self.raw.shaderCullDistance != 0
    }

    pub fn shader_float_64<'a>(&'a self) -> bool {
        self.raw.shaderFloat64 != 0
    }

    pub fn shader_int_64<'a>(&'a self) -> bool {
        self.raw.shaderInt64 != 0
    }

    pub fn shader_int_16<'a>(&'a self) -> bool {
        self.raw.shaderInt16 != 0
    }

    pub fn shader_resource_residency<'a>(&'a self) -> bool {
        self.raw.shaderResourceResidency != 0
    }

    pub fn shader_resource_min_lod<'a>(&'a self) -> bool {
        self.raw.shaderResourceMinLod != 0
    }

    pub fn sparse_binding<'a>(&'a self) -> bool {
        self.raw.sparseBinding != 0
    }

    pub fn sparse_residency_buffer<'a>(&'a self) -> bool {
        self.raw.sparseResidencyBuffer != 0
    }

    pub fn sparse_residency_image_2d<'a>(&'a self) -> bool {
        self.raw.sparseResidencyImage2D != 0
    }

    pub fn sparse_residency_image_3d<'a>(&'a self) -> bool {
        self.raw.sparseResidencyImage3D != 0
    }

    pub fn sparse_residency_2samples<'a>(&'a self) -> bool {
        self.raw.sparseResidency2Samples != 0
    }

    pub fn sparse_residency_4samples<'a>(&'a self) -> bool {
        self.raw.sparseResidency4Samples != 0
    }

    pub fn sparse_residency_8samples<'a>(&'a self) -> bool {
        self.raw.sparseResidency8Samples != 0
    }

    pub fn sparse_residency_16_samples<'a>(&'a self) -> bool {
        self.raw.sparseResidency16Samples != 0
    }

    pub fn sparse_residency_aliased<'a>(&'a self) -> bool {
        self.raw.sparseResidencyAliased != 0
    }

    pub fn variable_multisample_rate<'a>(&'a self) -> bool {
        self.raw.variableMultisampleRate != 0
    }

    pub fn inherited_queries<'a>(&'a self) -> bool {
        self.raw.inheritedQueries != 0
    }

    pub fn set_robust_buffer_access<'m>(&mut self, robust_buffer_access: bool) {
        self.raw.robustBufferAccess = robust_buffer_access as u32;
    }

    pub fn set_full_draw_index_uint_32<'m>(&mut self, full_draw_index_uint_32: bool) {
        self.raw.fullDrawIndexUint32 = full_draw_index_uint_32 as u32;
    }

    pub fn set_image_cube_array<'m>(&mut self, image_cube_array: bool) {
        self.raw.imageCubeArray = image_cube_array as u32;
    }

    pub fn set_independent_blend<'m>(&mut self, independent_blend: bool) {
        self.raw.independentBlend = independent_blend as u32;
    }

    pub fn set_geometry_shader<'m>(&mut self, geometry_shader: bool) {
        self.raw.geometryShader = geometry_shader as u32;
    }

    pub fn set_tessellation_shader<'m>(&mut self, tessellation_shader: bool) {
        self.raw.tessellationShader = tessellation_shader as u32;
    }

    pub fn set_sample_rate_shading<'m>(&mut self, sample_rate_shading: bool) {
        self.raw.sampleRateShading = sample_rate_shading as u32;
    }

    pub fn set_dual_src_blend<'m>(&mut self, dual_src_blend: bool) {
        self.raw.dualSrcBlend = dual_src_blend as u32;
    }

    pub fn set_logic_op<'m>(&mut self, logic_op: bool) {
        self.raw.logicOp = logic_op as u32;
    }

    pub fn set_multi_draw_indirect<'m>(&mut self, multi_draw_indirect: bool) {
        self.raw.multiDrawIndirect = multi_draw_indirect as u32;
    }

    pub fn set_draw_indirect_first_instance<'m>(&mut self, draw_indirect_first_instance: bool) {
        self.raw.drawIndirectFirstInstance = draw_indirect_first_instance as u32;
    }

    pub fn set_depth_clamp<'m>(&mut self, depth_clamp: bool) {
        self.raw.depthClamp = depth_clamp as u32;
    }

    pub fn set_depth_bias_clamp<'m>(&mut self, depth_bias_clamp: bool) {
        self.raw.depthBiasClamp = depth_bias_clamp as u32;
    }

    pub fn set_fill_mode_non_solid<'m>(&mut self, fill_mode_non_solid: bool) {
        self.raw.fillModeNonSolid = fill_mode_non_solid as u32;
    }

    pub fn set_depth_bounds<'m>(&mut self, depth_bounds: bool) {
        self.raw.depthBounds = depth_bounds as u32;
    }

    pub fn set_wide_lines<'m>(&mut self, wide_lines: bool) {
        self.raw.wideLines = wide_lines as u32;
    }

    pub fn set_large_points<'m>(&mut self, large_points: bool) {
        self.raw.largePoints = large_points as u32;
    }

    pub fn set_alpha_to_one<'m>(&mut self, alpha_to_one: bool) {
        self.raw.alphaToOne = alpha_to_one as u32;
    }

    pub fn set_multi_viewport<'m>(&mut self, multi_viewport: bool) {
        self.raw.multiViewport = multi_viewport as u32;
    }

    pub fn set_sampler_anisotropy<'m>(&mut self, sampler_anisotropy: bool) {
        self.raw.samplerAnisotropy = sampler_anisotropy as u32;
    }

    pub fn set_texture_compression_etc2<'m>(&mut self, texture_compression_etc2: bool) {
        self.raw.textureCompressionETC2 = texture_compression_etc2 as u32;
    }

    pub fn set_texture_compression_astcldr<'m>(&mut self, texture_compression_astcldr: bool) {
        self.raw.textureCompressionASTC_LDR = texture_compression_astcldr as u32;
    }

    pub fn set_texture_compression_bc<'m>(&mut self, texture_compression_bc: bool) {
        self.raw.textureCompressionBC = texture_compression_bc as u32;
    }

    pub fn set_occlusion_query_precise<'m>(&mut self, occlusion_query_precise: bool) {
        self.raw.occlusionQueryPrecise = occlusion_query_precise as u32;
    }

    pub fn set_pipeline_statistics_query<'m>(&mut self, pipeline_statistics_query: bool) {
        self.raw.pipelineStatisticsQuery = pipeline_statistics_query as u32;
    }

    pub fn set_vertex_pipeline_stores_and_atomics<'m>(&mut self, vertex_pipeline_stores_and_atomics: bool) {
        self.raw.vertexPipelineStoresAndAtomics = vertex_pipeline_stores_and_atomics as u32;
    }

    pub fn set_fragment_stores_and_atomics<'m>(&mut self, fragment_stores_and_atomics: bool) {
        self.raw.fragmentStoresAndAtomics = fragment_stores_and_atomics as u32;
    }

    pub fn set_shader_tessellation_and_geometry_point_size<'m>(&mut self, shader_tessellation_and_geometry_point_size: bool) {
        self.raw.shaderTessellationAndGeometryPointSize = shader_tessellation_and_geometry_point_size as u32;
    }

    pub fn set_shader_image_gather_extended<'m>(&mut self, shader_image_gather_extended: bool) {
        self.raw.shaderImageGatherExtended = shader_image_gather_extended as u32;
    }

    pub fn set_shader_storage_image_extended_formats<'m>(&mut self, shader_storage_image_extended_formats: bool) {
        self.raw.shaderStorageImageExtendedFormats = shader_storage_image_extended_formats as u32;
    }

    pub fn set_shader_storage_image_multisample<'m>(&mut self, shader_storage_image_multisample: bool) {
        self.raw.shaderStorageImageMultisample = shader_storage_image_multisample as u32;
    }

    pub fn set_shader_storage_image_read_without_format<'m>(&mut self, shader_storage_image_read_without_format: bool) {
        self.raw.shaderStorageImageReadWithoutFormat = shader_storage_image_read_without_format as u32;
    }

    pub fn set_shader_storage_image_write_without_format<'m>(&mut self, shader_storage_image_write_without_format: bool) {
        self.raw.shaderStorageImageWriteWithoutFormat = shader_storage_image_write_without_format as u32;
    }

    pub fn set_shader_uniform_buffer_array_dynamic_indexing<'m>(&mut self, shader_uniform_buffer_array_dynamic_indexing: bool) {
        self.raw.shaderUniformBufferArrayDynamicIndexing = shader_uniform_buffer_array_dynamic_indexing as u32;
    }

    pub fn set_shader_sampled_image_array_dynamic_indexing<'m>(&mut self, shader_sampled_image_array_dynamic_indexing: bool) {
        self.raw.shaderSampledImageArrayDynamicIndexing = shader_sampled_image_array_dynamic_indexing as u32;
    }

    pub fn set_shader_storage_buffer_array_dynamic_indexing<'m>(&mut self, shader_storage_buffer_array_dynamic_indexing: bool) {
        self.raw.shaderStorageBufferArrayDynamicIndexing = shader_storage_buffer_array_dynamic_indexing as u32;
    }

    pub fn set_shader_storage_image_array_dynamic_indexing<'m>(&mut self, shader_storage_image_array_dynamic_indexing: bool) {
        self.raw.shaderStorageImageArrayDynamicIndexing = shader_storage_image_array_dynamic_indexing as u32;
    }

    pub fn set_shader_clip_distance<'m>(&mut self, shader_clip_distance: bool) {
        self.raw.shaderClipDistance = shader_clip_distance as u32;
    }

    pub fn set_shader_cull_distance<'m>(&mut self, shader_cull_distance: bool) {
        self.raw.shaderCullDistance = shader_cull_distance as u32;
    }

    pub fn set_shader_float_64<'m>(&mut self, shader_float_64: bool) {
        self.raw.shaderFloat64 = shader_float_64 as u32;
    }

    pub fn set_shader_int_64<'m>(&mut self, shader_int_64: bool) {
        self.raw.shaderInt64 = shader_int_64 as u32;
    }

    pub fn set_shader_int_16<'m>(&mut self, shader_int_16: bool) {
        self.raw.shaderInt16 = shader_int_16 as u32;
    }

    pub fn set_shader_resource_residency<'m>(&mut self, shader_resource_residency: bool) {
        self.raw.shaderResourceResidency = shader_resource_residency as u32;
    }

    pub fn set_shader_resource_min_lod<'m>(&mut self, shader_resource_min_lod: bool) {
        self.raw.shaderResourceMinLod = shader_resource_min_lod as u32;
    }

    pub fn set_sparse_binding<'m>(&mut self, sparse_binding: bool) {
        self.raw.sparseBinding = sparse_binding as u32;
    }

    pub fn set_sparse_residency_buffer<'m>(&mut self, sparse_residency_buffer: bool) {
        self.raw.sparseResidencyBuffer = sparse_residency_buffer as u32;
    }

    pub fn set_sparse_residency_image_2d<'m>(&mut self, sparse_residency_image_2d: bool) {
        self.raw.sparseResidencyImage2D = sparse_residency_image_2d as u32;
    }

    pub fn set_sparse_residency_image_3d<'m>(&mut self, sparse_residency_image_3d: bool) {
        self.raw.sparseResidencyImage3D = sparse_residency_image_3d as u32;
    }

    pub fn set_sparse_residency_2samples<'m>(&mut self, sparse_residency_2samples: bool) {
        self.raw.sparseResidency2Samples = sparse_residency_2samples as u32;
    }

    pub fn set_sparse_residency_4samples<'m>(&mut self, sparse_residency_4samples: bool) {
        self.raw.sparseResidency4Samples = sparse_residency_4samples as u32;
    }

    pub fn set_sparse_residency_8samples<'m>(&mut self, sparse_residency_8samples: bool) {
        self.raw.sparseResidency8Samples = sparse_residency_8samples as u32;
    }

    pub fn set_sparse_residency_16_samples<'m>(&mut self, sparse_residency_16_samples: bool) {
        self.raw.sparseResidency16Samples = sparse_residency_16_samples as u32;
    }

    pub fn set_sparse_residency_aliased<'m>(&mut self, sparse_residency_aliased: bool) {
        self.raw.sparseResidencyAliased = sparse_residency_aliased as u32;
    }

    pub fn set_variable_multisample_rate<'m>(&mut self, variable_multisample_rate: bool) {
        self.raw.variableMultisampleRate = variable_multisample_rate as u32;
    }

    pub fn set_inherited_queries<'m>(&mut self, inherited_queries: bool) {
        self.raw.inheritedQueries = inherited_queries as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceFeatures {
        &self.raw
    }
}

impl From<PhysicalDeviceFeatures> for vks::VkPhysicalDeviceFeatures {
    fn from(f: PhysicalDeviceFeatures) -> vks::VkPhysicalDeviceFeatures {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceFeatures`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceFeaturesBuilder {
    raw: vks::VkPhysicalDeviceFeatures,
}

impl PhysicalDeviceFeaturesBuilder {
    pub fn new() -> PhysicalDeviceFeaturesBuilder {
        PhysicalDeviceFeaturesBuilder {
            raw: vks::VkPhysicalDeviceFeatures::default(),
        }
    }

    pub fn robust_buffer_access<'m>(mut self, robust_buffer_access: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.robustBufferAccess = robust_buffer_access as u32;
        self
    }

    pub fn full_draw_index_uint_32<'m>(mut self, full_draw_index_uint_32: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.fullDrawIndexUint32 = full_draw_index_uint_32 as u32;
        self
    }

    pub fn image_cube_array<'m>(mut self, image_cube_array: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.imageCubeArray = image_cube_array as u32;
        self
    }

    pub fn independent_blend<'m>(mut self, independent_blend: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.independentBlend = independent_blend as u32;
        self
    }

    pub fn geometry_shader<'m>(mut self, geometry_shader: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.geometryShader = geometry_shader as u32;
        self
    }

    pub fn tessellation_shader<'m>(mut self, tessellation_shader: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.tessellationShader = tessellation_shader as u32;
        self
    }

    pub fn sample_rate_shading<'m>(mut self, sample_rate_shading: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sampleRateShading = sample_rate_shading as u32;
        self
    }

    pub fn dual_src_blend<'m>(mut self, dual_src_blend: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.dualSrcBlend = dual_src_blend as u32;
        self
    }

    pub fn logic_op<'m>(mut self, logic_op: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.logicOp = logic_op as u32;
        self
    }

    pub fn multi_draw_indirect<'m>(mut self, multi_draw_indirect: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.multiDrawIndirect = multi_draw_indirect as u32;
        self
    }

    pub fn draw_indirect_first_instance<'m>(mut self, draw_indirect_first_instance: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.drawIndirectFirstInstance = draw_indirect_first_instance as u32;
        self
    }

    pub fn depth_clamp<'m>(mut self, depth_clamp: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.depthClamp = depth_clamp as u32;
        self
    }

    pub fn depth_bias_clamp<'m>(mut self, depth_bias_clamp: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.depthBiasClamp = depth_bias_clamp as u32;
        self
    }

    pub fn fill_mode_non_solid<'m>(mut self, fill_mode_non_solid: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.fillModeNonSolid = fill_mode_non_solid as u32;
        self
    }

    pub fn depth_bounds<'m>(mut self, depth_bounds: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.depthBounds = depth_bounds as u32;
        self
    }

    pub fn wide_lines<'m>(mut self, wide_lines: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.wideLines = wide_lines as u32;
        self
    }

    pub fn large_points<'m>(mut self, large_points: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.largePoints = large_points as u32;
        self
    }

    pub fn alpha_to_one<'m>(mut self, alpha_to_one: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.alphaToOne = alpha_to_one as u32;
        self
    }

    pub fn multi_viewport<'m>(mut self, multi_viewport: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.multiViewport = multi_viewport as u32;
        self
    }

    pub fn sampler_anisotropy<'m>(mut self, sampler_anisotropy: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.samplerAnisotropy = sampler_anisotropy as u32;
        self
    }

    pub fn texture_compression_etc2<'m>(mut self, texture_compression_etc2: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.textureCompressionETC2 = texture_compression_etc2 as u32;
        self
    }

    pub fn texture_compression_astcldr<'m>(mut self, texture_compression_astcldr: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.textureCompressionASTC_LDR = texture_compression_astcldr as u32;
        self
    }

    pub fn texture_compression_bc<'m>(mut self, texture_compression_bc: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.textureCompressionBC = texture_compression_bc as u32;
        self
    }

    pub fn occlusion_query_precise<'m>(mut self, occlusion_query_precise: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.occlusionQueryPrecise = occlusion_query_precise as u32;
        self
    }

    pub fn pipeline_statistics_query<'m>(mut self, pipeline_statistics_query: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.pipelineStatisticsQuery = pipeline_statistics_query as u32;
        self
    }

    pub fn vertex_pipeline_stores_and_atomics<'m>(mut self, vertex_pipeline_stores_and_atomics: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.vertexPipelineStoresAndAtomics = vertex_pipeline_stores_and_atomics as u32;
        self
    }

    pub fn fragment_stores_and_atomics<'m>(mut self, fragment_stores_and_atomics: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.fragmentStoresAndAtomics = fragment_stores_and_atomics as u32;
        self
    }

    pub fn shader_tessellation_and_geometry_point_size<'m>(mut self, shader_tessellation_and_geometry_point_size: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderTessellationAndGeometryPointSize = shader_tessellation_and_geometry_point_size as u32;
        self
    }

    pub fn shader_image_gather_extended<'m>(mut self, shader_image_gather_extended: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderImageGatherExtended = shader_image_gather_extended as u32;
        self
    }

    pub fn shader_storage_image_extended_formats<'m>(mut self, shader_storage_image_extended_formats: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderStorageImageExtendedFormats = shader_storage_image_extended_formats as u32;
        self
    }

    pub fn shader_storage_image_multisample<'m>(mut self, shader_storage_image_multisample: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderStorageImageMultisample = shader_storage_image_multisample as u32;
        self
    }

    pub fn shader_storage_image_read_without_format<'m>(mut self, shader_storage_image_read_without_format: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderStorageImageReadWithoutFormat = shader_storage_image_read_without_format as u32;
        self
    }

    pub fn shader_storage_image_write_without_format<'m>(mut self, shader_storage_image_write_without_format: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderStorageImageWriteWithoutFormat = shader_storage_image_write_without_format as u32;
        self
    }

    pub fn shader_uniform_buffer_array_dynamic_indexing<'m>(mut self, shader_uniform_buffer_array_dynamic_indexing: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderUniformBufferArrayDynamicIndexing = shader_uniform_buffer_array_dynamic_indexing as u32;
        self
    }

    pub fn shader_sampled_image_array_dynamic_indexing<'m>(mut self, shader_sampled_image_array_dynamic_indexing: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderSampledImageArrayDynamicIndexing = shader_sampled_image_array_dynamic_indexing as u32;
        self
    }

    pub fn shader_storage_buffer_array_dynamic_indexing<'m>(mut self, shader_storage_buffer_array_dynamic_indexing: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderStorageBufferArrayDynamicIndexing = shader_storage_buffer_array_dynamic_indexing as u32;
        self
    }

    pub fn shader_storage_image_array_dynamic_indexing<'m>(mut self, shader_storage_image_array_dynamic_indexing: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderStorageImageArrayDynamicIndexing = shader_storage_image_array_dynamic_indexing as u32;
        self
    }

    pub fn shader_clip_distance<'m>(mut self, shader_clip_distance: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderClipDistance = shader_clip_distance as u32;
        self
    }

    pub fn shader_cull_distance<'m>(mut self, shader_cull_distance: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderCullDistance = shader_cull_distance as u32;
        self
    }

    pub fn shader_float_64<'m>(mut self, shader_float_64: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderFloat64 = shader_float_64 as u32;
        self
    }

    pub fn shader_int_64<'m>(mut self, shader_int_64: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderInt64 = shader_int_64 as u32;
        self
    }

    pub fn shader_int_16<'m>(mut self, shader_int_16: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderInt16 = shader_int_16 as u32;
        self
    }

    pub fn shader_resource_residency<'m>(mut self, shader_resource_residency: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderResourceResidency = shader_resource_residency as u32;
        self
    }

    pub fn shader_resource_min_lod<'m>(mut self, shader_resource_min_lod: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderResourceMinLod = shader_resource_min_lod as u32;
        self
    }

    pub fn sparse_binding<'m>(mut self, sparse_binding: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sparseBinding = sparse_binding as u32;
        self
    }

    pub fn sparse_residency_buffer<'m>(mut self, sparse_residency_buffer: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sparseResidencyBuffer = sparse_residency_buffer as u32;
        self
    }

    pub fn sparse_residency_image_2d<'m>(mut self, sparse_residency_image_2d: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sparseResidencyImage2D = sparse_residency_image_2d as u32;
        self
    }

    pub fn sparse_residency_image_3d<'m>(mut self, sparse_residency_image_3d: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sparseResidencyImage3D = sparse_residency_image_3d as u32;
        self
    }

    pub fn sparse_residency_2samples<'m>(mut self, sparse_residency_2samples: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sparseResidency2Samples = sparse_residency_2samples as u32;
        self
    }

    pub fn sparse_residency_4samples<'m>(mut self, sparse_residency_4samples: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sparseResidency4Samples = sparse_residency_4samples as u32;
        self
    }

    pub fn sparse_residency_8samples<'m>(mut self, sparse_residency_8samples: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sparseResidency8Samples = sparse_residency_8samples as u32;
        self
    }

    pub fn sparse_residency_16_samples<'m>(mut self, sparse_residency_16_samples: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sparseResidency16Samples = sparse_residency_16_samples as u32;
        self
    }

    pub fn sparse_residency_aliased<'m>(mut self, sparse_residency_aliased: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sparseResidencyAliased = sparse_residency_aliased as u32;
        self
    }

    pub fn variable_multisample_rate<'m>(mut self, variable_multisample_rate: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.variableMultisampleRate = variable_multisample_rate as u32;
        self
    }

    pub fn inherited_queries<'m>(mut self, inherited_queries: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.inheritedQueries = inherited_queries as u32;
        self
    }

    pub fn get_robust_buffer_access<'a>(&'a self) -> bool {
        self.raw.robustBufferAccess != 0
    }

    pub fn get_full_draw_index_uint_32<'a>(&'a self) -> bool {
        self.raw.fullDrawIndexUint32 != 0
    }

    pub fn get_image_cube_array<'a>(&'a self) -> bool {
        self.raw.imageCubeArray != 0
    }

    pub fn get_independent_blend<'a>(&'a self) -> bool {
        self.raw.independentBlend != 0
    }

    pub fn get_geometry_shader<'a>(&'a self) -> bool {
        self.raw.geometryShader != 0
    }

    pub fn get_tessellation_shader<'a>(&'a self) -> bool {
        self.raw.tessellationShader != 0
    }

    pub fn get_sample_rate_shading<'a>(&'a self) -> bool {
        self.raw.sampleRateShading != 0
    }

    pub fn get_dual_src_blend<'a>(&'a self) -> bool {
        self.raw.dualSrcBlend != 0
    }

    pub fn get_logic_op<'a>(&'a self) -> bool {
        self.raw.logicOp != 0
    }

    pub fn get_multi_draw_indirect<'a>(&'a self) -> bool {
        self.raw.multiDrawIndirect != 0
    }

    pub fn get_draw_indirect_first_instance<'a>(&'a self) -> bool {
        self.raw.drawIndirectFirstInstance != 0
    }

    pub fn get_depth_clamp<'a>(&'a self) -> bool {
        self.raw.depthClamp != 0
    }

    pub fn get_depth_bias_clamp<'a>(&'a self) -> bool {
        self.raw.depthBiasClamp != 0
    }

    pub fn get_fill_mode_non_solid<'a>(&'a self) -> bool {
        self.raw.fillModeNonSolid != 0
    }

    pub fn get_depth_bounds<'a>(&'a self) -> bool {
        self.raw.depthBounds != 0
    }

    pub fn get_wide_lines<'a>(&'a self) -> bool {
        self.raw.wideLines != 0
    }

    pub fn get_large_points<'a>(&'a self) -> bool {
        self.raw.largePoints != 0
    }

    pub fn get_alpha_to_one<'a>(&'a self) -> bool {
        self.raw.alphaToOne != 0
    }

    pub fn get_multi_viewport<'a>(&'a self) -> bool {
        self.raw.multiViewport != 0
    }

    pub fn get_sampler_anisotropy<'a>(&'a self) -> bool {
        self.raw.samplerAnisotropy != 0
    }

    pub fn get_texture_compression_etc2<'a>(&'a self) -> bool {
        self.raw.textureCompressionETC2 != 0
    }

    pub fn get_texture_compression_astcldr<'a>(&'a self) -> bool {
        self.raw.textureCompressionASTC_LDR != 0
    }

    pub fn get_texture_compression_bc<'a>(&'a self) -> bool {
        self.raw.textureCompressionBC != 0
    }

    pub fn get_occlusion_query_precise<'a>(&'a self) -> bool {
        self.raw.occlusionQueryPrecise != 0
    }

    pub fn get_pipeline_statistics_query<'a>(&'a self) -> bool {
        self.raw.pipelineStatisticsQuery != 0
    }

    pub fn get_vertex_pipeline_stores_and_atomics<'a>(&'a self) -> bool {
        self.raw.vertexPipelineStoresAndAtomics != 0
    }

    pub fn get_fragment_stores_and_atomics<'a>(&'a self) -> bool {
        self.raw.fragmentStoresAndAtomics != 0
    }

    pub fn get_shader_tessellation_and_geometry_point_size<'a>(&'a self) -> bool {
        self.raw.shaderTessellationAndGeometryPointSize != 0
    }

    pub fn get_shader_image_gather_extended<'a>(&'a self) -> bool {
        self.raw.shaderImageGatherExtended != 0
    }

    pub fn get_shader_storage_image_extended_formats<'a>(&'a self) -> bool {
        self.raw.shaderStorageImageExtendedFormats != 0
    }

    pub fn get_shader_storage_image_multisample<'a>(&'a self) -> bool {
        self.raw.shaderStorageImageMultisample != 0
    }

    pub fn get_shader_storage_image_read_without_format<'a>(&'a self) -> bool {
        self.raw.shaderStorageImageReadWithoutFormat != 0
    }

    pub fn get_shader_storage_image_write_without_format<'a>(&'a self) -> bool {
        self.raw.shaderStorageImageWriteWithoutFormat != 0
    }

    pub fn get_shader_uniform_buffer_array_dynamic_indexing<'a>(&'a self) -> bool {
        self.raw.shaderUniformBufferArrayDynamicIndexing != 0
    }

    pub fn get_shader_sampled_image_array_dynamic_indexing<'a>(&'a self) -> bool {
        self.raw.shaderSampledImageArrayDynamicIndexing != 0
    }

    pub fn get_shader_storage_buffer_array_dynamic_indexing<'a>(&'a self) -> bool {
        self.raw.shaderStorageBufferArrayDynamicIndexing != 0
    }

    pub fn get_shader_storage_image_array_dynamic_indexing<'a>(&'a self) -> bool {
        self.raw.shaderStorageImageArrayDynamicIndexing != 0
    }

    pub fn get_shader_clip_distance<'a>(&'a self) -> bool {
        self.raw.shaderClipDistance != 0
    }

    pub fn get_shader_cull_distance<'a>(&'a self) -> bool {
        self.raw.shaderCullDistance != 0
    }

    pub fn get_shader_float_64<'a>(&'a self) -> bool {
        self.raw.shaderFloat64 != 0
    }

    pub fn get_shader_int_64<'a>(&'a self) -> bool {
        self.raw.shaderInt64 != 0
    }

    pub fn get_shader_int_16<'a>(&'a self) -> bool {
        self.raw.shaderInt16 != 0
    }

    pub fn get_shader_resource_residency<'a>(&'a self) -> bool {
        self.raw.shaderResourceResidency != 0
    }

    pub fn get_shader_resource_min_lod<'a>(&'a self) -> bool {
        self.raw.shaderResourceMinLod != 0
    }

    pub fn get_sparse_binding<'a>(&'a self) -> bool {
        self.raw.sparseBinding != 0
    }

    pub fn get_sparse_residency_buffer<'a>(&'a self) -> bool {
        self.raw.sparseResidencyBuffer != 0
    }

    pub fn get_sparse_residency_image_2d<'a>(&'a self) -> bool {
        self.raw.sparseResidencyImage2D != 0
    }

    pub fn get_sparse_residency_image_3d<'a>(&'a self) -> bool {
        self.raw.sparseResidencyImage3D != 0
    }

    pub fn get_sparse_residency_2samples<'a>(&'a self) -> bool {
        self.raw.sparseResidency2Samples != 0
    }

    pub fn get_sparse_residency_4samples<'a>(&'a self) -> bool {
        self.raw.sparseResidency4Samples != 0
    }

    pub fn get_sparse_residency_8samples<'a>(&'a self) -> bool {
        self.raw.sparseResidency8Samples != 0
    }

    pub fn get_sparse_residency_16_samples<'a>(&'a self) -> bool {
        self.raw.sparseResidency16Samples != 0
    }

    pub fn get_sparse_residency_aliased<'a>(&'a self) -> bool {
        self.raw.sparseResidencyAliased != 0
    }

    pub fn get_variable_multisample_rate<'a>(&'a self) -> bool {
        self.raw.variableMultisampleRate != 0
    }

    pub fn get_inherited_queries<'a>(&'a self) -> bool {
        self.raw.inheritedQueries != 0
    }

    pub fn build(self) -> PhysicalDeviceFeatures {
        PhysicalDeviceFeatures {
            raw: self.raw,
        }
    }
}


/// A `VkPhysicalDeviceSparseProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceSparseProperties {
    raw: vks::VkPhysicalDeviceSparseProperties,
}

impl PhysicalDeviceSparseProperties {
    pub fn builder() -> PhysicalDeviceSparsePropertiesBuilder {
        PhysicalDeviceSparsePropertiesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceSparseProperties) -> PhysicalDeviceSparseProperties {
        PhysicalDeviceSparseProperties { raw, }
    }

    pub fn residency_standard_2d_block_shape<'a>(&'a self) -> bool {
        self.raw.residencyStandard2DBlockShape != 0
    }

    pub fn residency_standard_2d_multisample_block_shape<'a>(&'a self) -> bool {
        self.raw.residencyStandard2DMultisampleBlockShape != 0
    }

    pub fn residency_standard_3d_block_shape<'a>(&'a self) -> bool {
        self.raw.residencyStandard3DBlockShape != 0
    }

    pub fn residency_aligned_mip_size<'a>(&'a self) -> bool {
        self.raw.residencyAlignedMipSize != 0
    }

    pub fn residency_non_resident_strict<'a>(&'a self) -> bool {
        self.raw.residencyNonResidentStrict != 0
    }

    pub fn set_residency_standard_2d_block_shape<'m>(&mut self, residency_standard_2d_block_shape: bool) {
        self.raw.residencyStandard2DBlockShape = residency_standard_2d_block_shape as u32;
    }

    pub fn set_residency_standard_2d_multisample_block_shape<'m>(&mut self, residency_standard_2d_multisample_block_shape: bool) {
        self.raw.residencyStandard2DMultisampleBlockShape = residency_standard_2d_multisample_block_shape as u32;
    }

    pub fn set_residency_standard_3d_block_shape<'m>(&mut self, residency_standard_3d_block_shape: bool) {
        self.raw.residencyStandard3DBlockShape = residency_standard_3d_block_shape as u32;
    }

    pub fn set_residency_aligned_mip_size<'m>(&mut self, residency_aligned_mip_size: bool) {
        self.raw.residencyAlignedMipSize = residency_aligned_mip_size as u32;
    }

    pub fn set_residency_non_resident_strict<'m>(&mut self, residency_non_resident_strict: bool) {
        self.raw.residencyNonResidentStrict = residency_non_resident_strict as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceSparseProperties {
        &self.raw
    }
}

impl From<PhysicalDeviceSparseProperties> for vks::VkPhysicalDeviceSparseProperties {
    fn from(f: PhysicalDeviceSparseProperties) -> vks::VkPhysicalDeviceSparseProperties {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceSparseProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceSparsePropertiesBuilder {
    raw: vks::VkPhysicalDeviceSparseProperties,
}

impl PhysicalDeviceSparsePropertiesBuilder {
    pub fn new() -> PhysicalDeviceSparsePropertiesBuilder {
        PhysicalDeviceSparsePropertiesBuilder {
            raw: vks::VkPhysicalDeviceSparseProperties::default(),
        }
    }

    pub fn residency_standard_2d_block_shape<'m>(mut self, residency_standard_2d_block_shape: bool) -> PhysicalDeviceSparsePropertiesBuilder {
        self.raw.residencyStandard2DBlockShape = residency_standard_2d_block_shape as u32;
        self
    }

    pub fn residency_standard_2d_multisample_block_shape<'m>(mut self, residency_standard_2d_multisample_block_shape: bool) -> PhysicalDeviceSparsePropertiesBuilder {
        self.raw.residencyStandard2DMultisampleBlockShape = residency_standard_2d_multisample_block_shape as u32;
        self
    }

    pub fn residency_standard_3d_block_shape<'m>(mut self, residency_standard_3d_block_shape: bool) -> PhysicalDeviceSparsePropertiesBuilder {
        self.raw.residencyStandard3DBlockShape = residency_standard_3d_block_shape as u32;
        self
    }

    pub fn residency_aligned_mip_size<'m>(mut self, residency_aligned_mip_size: bool) -> PhysicalDeviceSparsePropertiesBuilder {
        self.raw.residencyAlignedMipSize = residency_aligned_mip_size as u32;
        self
    }

    pub fn residency_non_resident_strict<'m>(mut self, residency_non_resident_strict: bool) -> PhysicalDeviceSparsePropertiesBuilder {
        self.raw.residencyNonResidentStrict = residency_non_resident_strict as u32;
        self
    }

    pub fn get_residency_standard_2d_block_shape<'a>(&'a self) -> bool {
        self.raw.residencyStandard2DBlockShape != 0
    }

    pub fn get_residency_standard_2d_multisample_block_shape<'a>(&'a self) -> bool {
        self.raw.residencyStandard2DMultisampleBlockShape != 0
    }

    pub fn get_residency_standard_3d_block_shape<'a>(&'a self) -> bool {
        self.raw.residencyStandard3DBlockShape != 0
    }

    pub fn get_residency_aligned_mip_size<'a>(&'a self) -> bool {
        self.raw.residencyAlignedMipSize != 0
    }

    pub fn get_residency_non_resident_strict<'a>(&'a self) -> bool {
        self.raw.residencyNonResidentStrict != 0
    }

    pub fn build(self) -> PhysicalDeviceSparseProperties {
        PhysicalDeviceSparseProperties {
            raw: self.raw,
        }
    }
}


/// A `VkPhysicalDeviceLimits`.
///
/// compute stage limits
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceLimits {
    raw: vks::VkPhysicalDeviceLimits,
}

impl PhysicalDeviceLimits {
    pub fn builder() -> PhysicalDeviceLimitsBuilder {
        PhysicalDeviceLimitsBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceLimits) -> PhysicalDeviceLimits {
        PhysicalDeviceLimits { raw, }
    }

    pub fn max_image_dimension_1d<'a>(&'a self) -> u32 {
        self.raw.maxImageDimension1D.into()
    }

    pub fn max_image_dimension_2d<'a>(&'a self) -> u32 {
        self.raw.maxImageDimension2D.into()
    }

    pub fn max_image_dimension_3d<'a>(&'a self) -> u32 {
        self.raw.maxImageDimension3D.into()
    }

    pub fn max_image_dimension_cube<'a>(&'a self) -> u32 {
        self.raw.maxImageDimensionCube.into()
    }

    pub fn max_image_array_layers<'a>(&'a self) -> u32 {
        self.raw.maxImageArrayLayers.into()
    }

    pub fn max_texel_buffer_elements<'a>(&'a self) -> u32 {
        self.raw.maxTexelBufferElements.into()
    }

    pub fn max_uniform_buffer_range<'a>(&'a self) -> u32 {
        self.raw.maxUniformBufferRange.into()
    }

    pub fn max_storage_buffer_range<'a>(&'a self) -> u32 {
        self.raw.maxStorageBufferRange.into()
    }

    pub fn max_push_constants_size<'a>(&'a self) -> u32 {
        self.raw.maxPushConstantsSize.into()
    }

    pub fn max_memory_allocation_count<'a>(&'a self) -> u32 {
        self.raw.maxMemoryAllocationCount.into()
    }

    pub fn max_sampler_allocation_count<'a>(&'a self) -> u32 {
        self.raw.maxSamplerAllocationCount.into()
    }

    pub fn buffer_image_granularity<'a>(&'a self) -> u64 {
        self.raw.bufferImageGranularity.into()
    }

    pub fn sparse_address_space_size<'a>(&'a self) -> u64 {
        self.raw.sparseAddressSpaceSize.into()
    }

    pub fn max_bound_descriptor_sets<'a>(&'a self) -> u32 {
        self.raw.maxBoundDescriptorSets.into()
    }

    pub fn max_per_stage_descriptor_samplers<'a>(&'a self) -> u32 {
        self.raw.maxPerStageDescriptorSamplers.into()
    }

    pub fn max_per_stage_descriptor_uniform_buffers<'a>(&'a self) -> u32 {
        self.raw.maxPerStageDescriptorUniformBuffers.into()
    }

    pub fn max_per_stage_descriptor_storage_buffers<'a>(&'a self) -> u32 {
        self.raw.maxPerStageDescriptorStorageBuffers.into()
    }

    pub fn max_per_stage_descriptor_sampled_images<'a>(&'a self) -> u32 {
        self.raw.maxPerStageDescriptorSampledImages.into()
    }

    pub fn max_per_stage_descriptor_storage_images<'a>(&'a self) -> u32 {
        self.raw.maxPerStageDescriptorStorageImages.into()
    }

    pub fn max_per_stage_descriptor_input_attachments<'a>(&'a self) -> u32 {
        self.raw.maxPerStageDescriptorInputAttachments.into()
    }

    pub fn max_per_stage_resources<'a>(&'a self) -> u32 {
        self.raw.maxPerStageResources.into()
    }

    pub fn max_descriptor_set_samplers<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetSamplers.into()
    }

    pub fn max_descriptor_set_uniform_buffers<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetUniformBuffers.into()
    }

    pub fn max_descriptor_set_uniform_buffers_dynamic<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetUniformBuffersDynamic.into()
    }

    pub fn max_descriptor_set_storage_buffers<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetStorageBuffers.into()
    }

    pub fn max_descriptor_set_storage_buffers_dynamic<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetStorageBuffersDynamic.into()
    }

    pub fn max_descriptor_set_sampled_images<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetSampledImages.into()
    }

    pub fn max_descriptor_set_storage_images<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetStorageImages.into()
    }

    pub fn max_descriptor_set_input_attachments<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetInputAttachments.into()
    }

    pub fn max_vertex_input_attributes<'a>(&'a self) -> u32 {
        self.raw.maxVertexInputAttributes.into()
    }

    pub fn max_vertex_input_bindings<'a>(&'a self) -> u32 {
        self.raw.maxVertexInputBindings.into()
    }

    pub fn max_vertex_input_attribute_offset<'a>(&'a self) -> u32 {
        self.raw.maxVertexInputAttributeOffset.into()
    }

    pub fn max_vertex_input_binding_stride<'a>(&'a self) -> u32 {
        self.raw.maxVertexInputBindingStride.into()
    }

    pub fn max_vertex_output_components<'a>(&'a self) -> u32 {
        self.raw.maxVertexOutputComponents.into()
    }

    pub fn max_tessellation_generation_level<'a>(&'a self) -> u32 {
        self.raw.maxTessellationGenerationLevel.into()
    }

    pub fn max_tessellation_patch_size<'a>(&'a self) -> u32 {
        self.raw.maxTessellationPatchSize.into()
    }

    pub fn max_tessellation_control_per_vertex_input_components<'a>(&'a self) -> u32 {
        self.raw.maxTessellationControlPerVertexInputComponents.into()
    }

    pub fn max_tessellation_control_per_vertex_output_components<'a>(&'a self) -> u32 {
        self.raw.maxTessellationControlPerVertexOutputComponents.into()
    }

    pub fn max_tessellation_control_per_patch_output_components<'a>(&'a self) -> u32 {
        self.raw.maxTessellationControlPerPatchOutputComponents.into()
    }

    pub fn max_tessellation_control_total_output_components<'a>(&'a self) -> u32 {
        self.raw.maxTessellationControlTotalOutputComponents.into()
    }

    pub fn max_tessellation_evaluation_input_components<'a>(&'a self) -> u32 {
        self.raw.maxTessellationEvaluationInputComponents.into()
    }

    pub fn max_tessellation_evaluation_output_components<'a>(&'a self) -> u32 {
        self.raw.maxTessellationEvaluationOutputComponents.into()
    }

    pub fn max_geometry_shader_invocations<'a>(&'a self) -> u32 {
        self.raw.maxGeometryShaderInvocations.into()
    }

    pub fn max_geometry_input_components<'a>(&'a self) -> u32 {
        self.raw.maxGeometryInputComponents.into()
    }

    pub fn max_geometry_output_components<'a>(&'a self) -> u32 {
        self.raw.maxGeometryOutputComponents.into()
    }

    pub fn max_geometry_output_vertices<'a>(&'a self) -> u32 {
        self.raw.maxGeometryOutputVertices.into()
    }

    pub fn max_geometry_total_output_components<'a>(&'a self) -> u32 {
        self.raw.maxGeometryTotalOutputComponents.into()
    }

    pub fn max_fragment_input_components<'a>(&'a self) -> u32 {
        self.raw.maxFragmentInputComponents.into()
    }

    pub fn max_fragment_output_attachments<'a>(&'a self) -> u32 {
        self.raw.maxFragmentOutputAttachments.into()
    }

    pub fn max_fragment_dual_src_attachments<'a>(&'a self) -> u32 {
        self.raw.maxFragmentDualSrcAttachments.into()
    }

    pub fn max_fragment_combined_output_resources<'a>(&'a self) -> u32 {
        self.raw.maxFragmentCombinedOutputResources.into()
    }

    pub fn max_compute_shared_memory_size<'a>(&'a self) -> u32 {
        self.raw.maxComputeSharedMemorySize.into()
    }

    pub fn max_compute_work_group_count<'a>(&'a self) -> &[u32] {
        unsafe { slice::from_raw_parts(&self.raw.maxComputeWorkGroupCount as *const _, 3 as usize) }
    }

    pub fn max_compute_work_group_invocations<'a>(&'a self) -> u32 {
        self.raw.maxComputeWorkGroupInvocations.into()
    }

    pub fn max_compute_work_group_size<'a>(&'a self) -> &[u32] {
        unsafe { slice::from_raw_parts(&self.raw.maxComputeWorkGroupSize as *const _, 3 as usize) }
    }

    pub fn sub_pixel_precision_bits<'a>(&'a self) -> u32 {
        self.raw.subPixelPrecisionBits.into()
    }

    pub fn sub_texel_precision_bits<'a>(&'a self) -> u32 {
        self.raw.subTexelPrecisionBits.into()
    }

    pub fn mipmap_precision_bits<'a>(&'a self) -> u32 {
        self.raw.mipmapPrecisionBits.into()
    }

    pub fn max_draw_indexed_index_value<'a>(&'a self) -> u32 {
        self.raw.maxDrawIndexedIndexValue.into()
    }

    pub fn max_draw_indirect_count<'a>(&'a self) -> u32 {
        self.raw.maxDrawIndirectCount.into()
    }

    pub fn max_sampler_lod_bias<'a>(&'a self) -> f32 {
        self.raw.maxSamplerLodBias.into()
    }

    pub fn max_sampler_anisotropy<'a>(&'a self) -> f32 {
        self.raw.maxSamplerAnisotropy.into()
    }

    pub fn max_viewports<'a>(&'a self) -> u32 {
        self.raw.maxViewports.into()
    }

    pub fn max_viewport_dimensions<'a>(&'a self) -> &[u32] {
        unsafe { slice::from_raw_parts(&self.raw.maxViewportDimensions as *const _, 2 as usize) }
    }

    pub fn viewport_bounds_range<'a>(&'a self) -> &[f32] {
        unsafe { slice::from_raw_parts(&self.raw.viewportBoundsRange as *const _, 2 as usize) }
    }

    pub fn viewport_sub_pixel_bits<'a>(&'a self) -> u32 {
        self.raw.viewportSubPixelBits.into()
    }

    pub fn min_memory_map_alignment<'a>(&'a self) -> usize {
        self.raw.minMemoryMapAlignment.into()
    }

    pub fn min_texel_buffer_offset_alignment<'a>(&'a self) -> u64 {
        self.raw.minTexelBufferOffsetAlignment.into()
    }

    pub fn min_uniform_buffer_offset_alignment<'a>(&'a self) -> u64 {
        self.raw.minUniformBufferOffsetAlignment.into()
    }

    pub fn min_storage_buffer_offset_alignment<'a>(&'a self) -> u64 {
        self.raw.minStorageBufferOffsetAlignment.into()
    }

    pub fn min_texel_offset<'a>(&'a self) -> i32 {
        self.raw.minTexelOffset.into()
    }

    pub fn max_texel_offset<'a>(&'a self) -> u32 {
        self.raw.maxTexelOffset.into()
    }

    pub fn min_texel_gather_offset<'a>(&'a self) -> i32 {
        self.raw.minTexelGatherOffset.into()
    }

    pub fn max_texel_gather_offset<'a>(&'a self) -> u32 {
        self.raw.maxTexelGatherOffset.into()
    }

    pub fn min_interpolation_offset<'a>(&'a self) -> f32 {
        self.raw.minInterpolationOffset.into()
    }

    pub fn max_interpolation_offset<'a>(&'a self) -> f32 {
        self.raw.maxInterpolationOffset.into()
    }

    pub fn sub_pixel_interpolation_offset_bits<'a>(&'a self) -> u32 {
        self.raw.subPixelInterpolationOffsetBits.into()
    }

    pub fn max_framebuffer_width<'a>(&'a self) -> u32 {
        self.raw.maxFramebufferWidth.into()
    }

    pub fn max_framebuffer_height<'a>(&'a self) -> u32 {
        self.raw.maxFramebufferHeight.into()
    }

    pub fn max_framebuffer_layers<'a>(&'a self) -> u32 {
        self.raw.maxFramebufferLayers.into()
    }

    pub fn framebuffer_color_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.framebufferColorSampleCounts)
            .expect("PhysicalDeviceLimits::framebuffer_color_sample_counts: error converting flags")
    }

    pub fn framebuffer_depth_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.framebufferDepthSampleCounts)
            .expect("PhysicalDeviceLimits::framebuffer_depth_sample_counts: error converting flags")
    }

    pub fn framebuffer_stencil_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.framebufferStencilSampleCounts)
            .expect("PhysicalDeviceLimits::framebuffer_stencil_sample_counts: error converting flags")
    }

    pub fn framebuffer_no_attachments_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.framebufferNoAttachmentsSampleCounts)
            .expect("PhysicalDeviceLimits::framebuffer_no_attachments_sample_counts: error converting flags")
    }

    pub fn max_color_attachments<'a>(&'a self) -> u32 {
        self.raw.maxColorAttachments.into()
    }

    pub fn sampled_image_color_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.sampledImageColorSampleCounts)
            .expect("PhysicalDeviceLimits::sampled_image_color_sample_counts: error converting flags")
    }

    pub fn sampled_image_integer_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.sampledImageIntegerSampleCounts)
            .expect("PhysicalDeviceLimits::sampled_image_integer_sample_counts: error converting flags")
    }

    pub fn sampled_image_depth_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.sampledImageDepthSampleCounts)
            .expect("PhysicalDeviceLimits::sampled_image_depth_sample_counts: error converting flags")
    }

    pub fn sampled_image_stencil_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.sampledImageStencilSampleCounts)
            .expect("PhysicalDeviceLimits::sampled_image_stencil_sample_counts: error converting flags")
    }

    pub fn storage_image_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.storageImageSampleCounts)
            .expect("PhysicalDeviceLimits::storage_image_sample_counts: error converting flags")
    }

    pub fn max_sample_mask_words<'a>(&'a self) -> u32 {
        self.raw.maxSampleMaskWords.into()
    }

    pub fn timestamp_compute_and_graphics<'a>(&'a self) -> bool {
        self.raw.timestampComputeAndGraphics != 0
    }

    pub fn timestamp_period<'a>(&'a self) -> f32 {
        self.raw.timestampPeriod.into()
    }

    pub fn max_clip_distances<'a>(&'a self) -> u32 {
        self.raw.maxClipDistances.into()
    }

    pub fn max_cull_distances<'a>(&'a self) -> u32 {
        self.raw.maxCullDistances.into()
    }

    pub fn max_combined_clip_and_cull_distances<'a>(&'a self) -> u32 {
        self.raw.maxCombinedClipAndCullDistances.into()
    }

    pub fn discrete_queue_priorities<'a>(&'a self) -> u32 {
        self.raw.discreteQueuePriorities.into()
    }

    pub fn point_size_range<'a>(&'a self) -> &[f32] {
        unsafe { slice::from_raw_parts(&self.raw.pointSizeRange as *const _, 2 as usize) }
    }

    pub fn line_width_range<'a>(&'a self) -> &[f32] {
        unsafe { slice::from_raw_parts(&self.raw.lineWidthRange as *const _, 2 as usize) }
    }

    pub fn point_size_granularity<'a>(&'a self) -> f32 {
        self.raw.pointSizeGranularity.into()
    }

    pub fn line_width_granularity<'a>(&'a self) -> f32 {
        self.raw.lineWidthGranularity.into()
    }

    pub fn strict_lines<'a>(&'a self) -> bool {
        self.raw.strictLines != 0
    }

    pub fn standard_sample_locations<'a>(&'a self) -> bool {
        self.raw.standardSampleLocations != 0
    }

    pub fn optimal_buffer_copy_offset_alignment<'a>(&'a self) -> u64 {
        self.raw.optimalBufferCopyOffsetAlignment.into()
    }

    pub fn optimal_buffer_copy_row_pitch_alignment<'a>(&'a self) -> u64 {
        self.raw.optimalBufferCopyRowPitchAlignment.into()
    }

    pub fn non_coherent_atom_size<'a>(&'a self) -> u64 {
        self.raw.nonCoherentAtomSize.into()
    }

    pub fn set_max_image_dimension_1d<'m>(&mut self, max_image_dimension_1d: u32) {
        self.raw.maxImageDimension1D = max_image_dimension_1d.into();
    }

    pub fn set_max_image_dimension_2d<'m>(&mut self, max_image_dimension_2d: u32) {
        self.raw.maxImageDimension2D = max_image_dimension_2d.into();
    }

    pub fn set_max_image_dimension_3d<'m>(&mut self, max_image_dimension_3d: u32) {
        self.raw.maxImageDimension3D = max_image_dimension_3d.into();
    }

    pub fn set_max_image_dimension_cube<'m>(&mut self, max_image_dimension_cube: u32) {
        self.raw.maxImageDimensionCube = max_image_dimension_cube.into();
    }

    pub fn set_max_image_array_layers<'m>(&mut self, max_image_array_layers: u32) {
        self.raw.maxImageArrayLayers = max_image_array_layers.into();
    }

    pub fn set_max_texel_buffer_elements<'m>(&mut self, max_texel_buffer_elements: u32) {
        self.raw.maxTexelBufferElements = max_texel_buffer_elements.into();
    }

    pub fn set_max_uniform_buffer_range<'m>(&mut self, max_uniform_buffer_range: u32) {
        self.raw.maxUniformBufferRange = max_uniform_buffer_range.into();
    }

    pub fn set_max_storage_buffer_range<'m>(&mut self, max_storage_buffer_range: u32) {
        self.raw.maxStorageBufferRange = max_storage_buffer_range.into();
    }

    pub fn set_max_push_constants_size<'m>(&mut self, max_push_constants_size: u32) {
        self.raw.maxPushConstantsSize = max_push_constants_size.into();
    }

    pub fn set_max_memory_allocation_count<'m>(&mut self, max_memory_allocation_count: u32) {
        self.raw.maxMemoryAllocationCount = max_memory_allocation_count.into();
    }

    pub fn set_max_sampler_allocation_count<'m>(&mut self, max_sampler_allocation_count: u32) {
        self.raw.maxSamplerAllocationCount = max_sampler_allocation_count.into();
    }

    pub fn set_buffer_image_granularity<'m>(&mut self, buffer_image_granularity: u64) {
        self.raw.bufferImageGranularity = buffer_image_granularity.into();
    }

    pub fn set_sparse_address_space_size<'m>(&mut self, sparse_address_space_size: u64) {
        self.raw.sparseAddressSpaceSize = sparse_address_space_size.into();
    }

    pub fn set_max_bound_descriptor_sets<'m>(&mut self, max_bound_descriptor_sets: u32) {
        self.raw.maxBoundDescriptorSets = max_bound_descriptor_sets.into();
    }

    pub fn set_max_per_stage_descriptor_samplers<'m>(&mut self, max_per_stage_descriptor_samplers: u32) {
        self.raw.maxPerStageDescriptorSamplers = max_per_stage_descriptor_samplers.into();
    }

    pub fn set_max_per_stage_descriptor_uniform_buffers<'m>(&mut self, max_per_stage_descriptor_uniform_buffers: u32) {
        self.raw.maxPerStageDescriptorUniformBuffers = max_per_stage_descriptor_uniform_buffers.into();
    }

    pub fn set_max_per_stage_descriptor_storage_buffers<'m>(&mut self, max_per_stage_descriptor_storage_buffers: u32) {
        self.raw.maxPerStageDescriptorStorageBuffers = max_per_stage_descriptor_storage_buffers.into();
    }

    pub fn set_max_per_stage_descriptor_sampled_images<'m>(&mut self, max_per_stage_descriptor_sampled_images: u32) {
        self.raw.maxPerStageDescriptorSampledImages = max_per_stage_descriptor_sampled_images.into();
    }

    pub fn set_max_per_stage_descriptor_storage_images<'m>(&mut self, max_per_stage_descriptor_storage_images: u32) {
        self.raw.maxPerStageDescriptorStorageImages = max_per_stage_descriptor_storage_images.into();
    }

    pub fn set_max_per_stage_descriptor_input_attachments<'m>(&mut self, max_per_stage_descriptor_input_attachments: u32) {
        self.raw.maxPerStageDescriptorInputAttachments = max_per_stage_descriptor_input_attachments.into();
    }

    pub fn set_max_per_stage_resources<'m>(&mut self, max_per_stage_resources: u32) {
        self.raw.maxPerStageResources = max_per_stage_resources.into();
    }

    pub fn set_max_descriptor_set_samplers<'m>(&mut self, max_descriptor_set_samplers: u32) {
        self.raw.maxDescriptorSetSamplers = max_descriptor_set_samplers.into();
    }

    pub fn set_max_descriptor_set_uniform_buffers<'m>(&mut self, max_descriptor_set_uniform_buffers: u32) {
        self.raw.maxDescriptorSetUniformBuffers = max_descriptor_set_uniform_buffers.into();
    }

    pub fn set_max_descriptor_set_uniform_buffers_dynamic<'m>(&mut self, max_descriptor_set_uniform_buffers_dynamic: u32) {
        self.raw.maxDescriptorSetUniformBuffersDynamic = max_descriptor_set_uniform_buffers_dynamic.into();
    }

    pub fn set_max_descriptor_set_storage_buffers<'m>(&mut self, max_descriptor_set_storage_buffers: u32) {
        self.raw.maxDescriptorSetStorageBuffers = max_descriptor_set_storage_buffers.into();
    }

    pub fn set_max_descriptor_set_storage_buffers_dynamic<'m>(&mut self, max_descriptor_set_storage_buffers_dynamic: u32) {
        self.raw.maxDescriptorSetStorageBuffersDynamic = max_descriptor_set_storage_buffers_dynamic.into();
    }

    pub fn set_max_descriptor_set_sampled_images<'m>(&mut self, max_descriptor_set_sampled_images: u32) {
        self.raw.maxDescriptorSetSampledImages = max_descriptor_set_sampled_images.into();
    }

    pub fn set_max_descriptor_set_storage_images<'m>(&mut self, max_descriptor_set_storage_images: u32) {
        self.raw.maxDescriptorSetStorageImages = max_descriptor_set_storage_images.into();
    }

    pub fn set_max_descriptor_set_input_attachments<'m>(&mut self, max_descriptor_set_input_attachments: u32) {
        self.raw.maxDescriptorSetInputAttachments = max_descriptor_set_input_attachments.into();
    }

    pub fn set_max_vertex_input_attributes<'m>(&mut self, max_vertex_input_attributes: u32) {
        self.raw.maxVertexInputAttributes = max_vertex_input_attributes.into();
    }

    pub fn set_max_vertex_input_bindings<'m>(&mut self, max_vertex_input_bindings: u32) {
        self.raw.maxVertexInputBindings = max_vertex_input_bindings.into();
    }

    pub fn set_max_vertex_input_attribute_offset<'m>(&mut self, max_vertex_input_attribute_offset: u32) {
        self.raw.maxVertexInputAttributeOffset = max_vertex_input_attribute_offset.into();
    }

    pub fn set_max_vertex_input_binding_stride<'m>(&mut self, max_vertex_input_binding_stride: u32) {
        self.raw.maxVertexInputBindingStride = max_vertex_input_binding_stride.into();
    }

    pub fn set_max_vertex_output_components<'m>(&mut self, max_vertex_output_components: u32) {
        self.raw.maxVertexOutputComponents = max_vertex_output_components.into();
    }

    pub fn set_max_tessellation_generation_level<'m>(&mut self, max_tessellation_generation_level: u32) {
        self.raw.maxTessellationGenerationLevel = max_tessellation_generation_level.into();
    }

    pub fn set_max_tessellation_patch_size<'m>(&mut self, max_tessellation_patch_size: u32) {
        self.raw.maxTessellationPatchSize = max_tessellation_patch_size.into();
    }

    pub fn set_max_tessellation_control_per_vertex_input_components<'m>(&mut self, max_tessellation_control_per_vertex_input_components: u32) {
        self.raw.maxTessellationControlPerVertexInputComponents = max_tessellation_control_per_vertex_input_components.into();
    }

    pub fn set_max_tessellation_control_per_vertex_output_components<'m>(&mut self, max_tessellation_control_per_vertex_output_components: u32) {
        self.raw.maxTessellationControlPerVertexOutputComponents = max_tessellation_control_per_vertex_output_components.into();
    }

    pub fn set_max_tessellation_control_per_patch_output_components<'m>(&mut self, max_tessellation_control_per_patch_output_components: u32) {
        self.raw.maxTessellationControlPerPatchOutputComponents = max_tessellation_control_per_patch_output_components.into();
    }

    pub fn set_max_tessellation_control_total_output_components<'m>(&mut self, max_tessellation_control_total_output_components: u32) {
        self.raw.maxTessellationControlTotalOutputComponents = max_tessellation_control_total_output_components.into();
    }

    pub fn set_max_tessellation_evaluation_input_components<'m>(&mut self, max_tessellation_evaluation_input_components: u32) {
        self.raw.maxTessellationEvaluationInputComponents = max_tessellation_evaluation_input_components.into();
    }

    pub fn set_max_tessellation_evaluation_output_components<'m>(&mut self, max_tessellation_evaluation_output_components: u32) {
        self.raw.maxTessellationEvaluationOutputComponents = max_tessellation_evaluation_output_components.into();
    }

    pub fn set_max_geometry_shader_invocations<'m>(&mut self, max_geometry_shader_invocations: u32) {
        self.raw.maxGeometryShaderInvocations = max_geometry_shader_invocations.into();
    }

    pub fn set_max_geometry_input_components<'m>(&mut self, max_geometry_input_components: u32) {
        self.raw.maxGeometryInputComponents = max_geometry_input_components.into();
    }

    pub fn set_max_geometry_output_components<'m>(&mut self, max_geometry_output_components: u32) {
        self.raw.maxGeometryOutputComponents = max_geometry_output_components.into();
    }

    pub fn set_max_geometry_output_vertices<'m>(&mut self, max_geometry_output_vertices: u32) {
        self.raw.maxGeometryOutputVertices = max_geometry_output_vertices.into();
    }

    pub fn set_max_geometry_total_output_components<'m>(&mut self, max_geometry_total_output_components: u32) {
        self.raw.maxGeometryTotalOutputComponents = max_geometry_total_output_components.into();
    }

    pub fn set_max_fragment_input_components<'m>(&mut self, max_fragment_input_components: u32) {
        self.raw.maxFragmentInputComponents = max_fragment_input_components.into();
    }

    pub fn set_max_fragment_output_attachments<'m>(&mut self, max_fragment_output_attachments: u32) {
        self.raw.maxFragmentOutputAttachments = max_fragment_output_attachments.into();
    }

    pub fn set_max_fragment_dual_src_attachments<'m>(&mut self, max_fragment_dual_src_attachments: u32) {
        self.raw.maxFragmentDualSrcAttachments = max_fragment_dual_src_attachments.into();
    }

    pub fn set_max_fragment_combined_output_resources<'m>(&mut self, max_fragment_combined_output_resources: u32) {
        self.raw.maxFragmentCombinedOutputResources = max_fragment_combined_output_resources.into();
    }

    pub fn set_max_compute_shared_memory_size<'m>(&mut self, max_compute_shared_memory_size: u32) {
        self.raw.maxComputeSharedMemorySize = max_compute_shared_memory_size.into();
    }

    pub fn set_max_compute_work_group_count<'m>(&mut self, max_compute_work_group_count: [u32; 3]) {
        self.raw.maxComputeWorkGroupCount = max_compute_work_group_count;
    }

    pub fn set_max_compute_work_group_invocations<'m>(&mut self, max_compute_work_group_invocations: u32) {
        self.raw.maxComputeWorkGroupInvocations = max_compute_work_group_invocations.into();
    }

    pub fn set_max_compute_work_group_size<'m>(&mut self, max_compute_work_group_size: [u32; 3]) {
        self.raw.maxComputeWorkGroupSize = max_compute_work_group_size;
    }

    pub fn set_sub_pixel_precision_bits<'m>(&mut self, sub_pixel_precision_bits: u32) {
        self.raw.subPixelPrecisionBits = sub_pixel_precision_bits.into();
    }

    pub fn set_sub_texel_precision_bits<'m>(&mut self, sub_texel_precision_bits: u32) {
        self.raw.subTexelPrecisionBits = sub_texel_precision_bits.into();
    }

    pub fn set_mipmap_precision_bits<'m>(&mut self, mipmap_precision_bits: u32) {
        self.raw.mipmapPrecisionBits = mipmap_precision_bits.into();
    }

    pub fn set_max_draw_indexed_index_value<'m>(&mut self, max_draw_indexed_index_value: u32) {
        self.raw.maxDrawIndexedIndexValue = max_draw_indexed_index_value.into();
    }

    pub fn set_max_draw_indirect_count<'m>(&mut self, max_draw_indirect_count: u32) {
        self.raw.maxDrawIndirectCount = max_draw_indirect_count.into();
    }

    pub fn set_max_sampler_lod_bias<'m>(&mut self, max_sampler_lod_bias: f32) {
        self.raw.maxSamplerLodBias = max_sampler_lod_bias.into();
    }

    pub fn set_max_sampler_anisotropy<'m>(&mut self, max_sampler_anisotropy: f32) {
        self.raw.maxSamplerAnisotropy = max_sampler_anisotropy.into();
    }

    pub fn set_max_viewports<'m>(&mut self, max_viewports: u32) {
        self.raw.maxViewports = max_viewports.into();
    }

    pub fn set_max_viewport_dimensions<'m>(&mut self, max_viewport_dimensions: [u32; 2]) {
        self.raw.maxViewportDimensions = max_viewport_dimensions;
    }

    pub fn set_viewport_bounds_range<'m>(&mut self, viewport_bounds_range: [f32; 2]) {
        self.raw.viewportBoundsRange = viewport_bounds_range;
    }

    pub fn set_viewport_sub_pixel_bits<'m>(&mut self, viewport_sub_pixel_bits: u32) {
        self.raw.viewportSubPixelBits = viewport_sub_pixel_bits.into();
    }

    pub fn set_min_memory_map_alignment<'m>(&mut self, min_memory_map_alignment: usize) {
        self.raw.minMemoryMapAlignment = min_memory_map_alignment.into();
    }

    pub fn set_min_texel_buffer_offset_alignment<'m>(&mut self, min_texel_buffer_offset_alignment: u64) {
        self.raw.minTexelBufferOffsetAlignment = min_texel_buffer_offset_alignment.into();
    }

    pub fn set_min_uniform_buffer_offset_alignment<'m>(&mut self, min_uniform_buffer_offset_alignment: u64) {
        self.raw.minUniformBufferOffsetAlignment = min_uniform_buffer_offset_alignment.into();
    }

    pub fn set_min_storage_buffer_offset_alignment<'m>(&mut self, min_storage_buffer_offset_alignment: u64) {
        self.raw.minStorageBufferOffsetAlignment = min_storage_buffer_offset_alignment.into();
    }

    pub fn set_min_texel_offset<'m>(&mut self, min_texel_offset: i32) {
        self.raw.minTexelOffset = min_texel_offset.into();
    }

    pub fn set_max_texel_offset<'m>(&mut self, max_texel_offset: u32) {
        self.raw.maxTexelOffset = max_texel_offset.into();
    }

    pub fn set_min_texel_gather_offset<'m>(&mut self, min_texel_gather_offset: i32) {
        self.raw.minTexelGatherOffset = min_texel_gather_offset.into();
    }

    pub fn set_max_texel_gather_offset<'m>(&mut self, max_texel_gather_offset: u32) {
        self.raw.maxTexelGatherOffset = max_texel_gather_offset.into();
    }

    pub fn set_min_interpolation_offset<'m>(&mut self, min_interpolation_offset: f32) {
        self.raw.minInterpolationOffset = min_interpolation_offset.into();
    }

    pub fn set_max_interpolation_offset<'m>(&mut self, max_interpolation_offset: f32) {
        self.raw.maxInterpolationOffset = max_interpolation_offset.into();
    }

    pub fn set_sub_pixel_interpolation_offset_bits<'m>(&mut self, sub_pixel_interpolation_offset_bits: u32) {
        self.raw.subPixelInterpolationOffsetBits = sub_pixel_interpolation_offset_bits.into();
    }

    pub fn set_max_framebuffer_width<'m>(&mut self, max_framebuffer_width: u32) {
        self.raw.maxFramebufferWidth = max_framebuffer_width.into();
    }

    pub fn set_max_framebuffer_height<'m>(&mut self, max_framebuffer_height: u32) {
        self.raw.maxFramebufferHeight = max_framebuffer_height.into();
    }

    pub fn set_max_framebuffer_layers<'m>(&mut self, max_framebuffer_layers: u32) {
        self.raw.maxFramebufferLayers = max_framebuffer_layers.into();
    }

    pub fn set_framebuffer_color_sample_counts<'m>(&mut self, framebuffer_color_sample_counts: SampleCountFlags) {
        self.raw.framebufferColorSampleCounts = framebuffer_color_sample_counts.bits();
    }

    pub fn set_framebuffer_depth_sample_counts<'m>(&mut self, framebuffer_depth_sample_counts: SampleCountFlags) {
        self.raw.framebufferDepthSampleCounts = framebuffer_depth_sample_counts.bits();
    }

    pub fn set_framebuffer_stencil_sample_counts<'m>(&mut self, framebuffer_stencil_sample_counts: SampleCountFlags) {
        self.raw.framebufferStencilSampleCounts = framebuffer_stencil_sample_counts.bits();
    }

    pub fn set_framebuffer_no_attachments_sample_counts<'m>(&mut self, framebuffer_no_attachments_sample_counts: SampleCountFlags) {
        self.raw.framebufferNoAttachmentsSampleCounts = framebuffer_no_attachments_sample_counts.bits();
    }

    pub fn set_max_color_attachments<'m>(&mut self, max_color_attachments: u32) {
        self.raw.maxColorAttachments = max_color_attachments.into();
    }

    pub fn set_sampled_image_color_sample_counts<'m>(&mut self, sampled_image_color_sample_counts: SampleCountFlags) {
        self.raw.sampledImageColorSampleCounts = sampled_image_color_sample_counts.bits();
    }

    pub fn set_sampled_image_integer_sample_counts<'m>(&mut self, sampled_image_integer_sample_counts: SampleCountFlags) {
        self.raw.sampledImageIntegerSampleCounts = sampled_image_integer_sample_counts.bits();
    }

    pub fn set_sampled_image_depth_sample_counts<'m>(&mut self, sampled_image_depth_sample_counts: SampleCountFlags) {
        self.raw.sampledImageDepthSampleCounts = sampled_image_depth_sample_counts.bits();
    }

    pub fn set_sampled_image_stencil_sample_counts<'m>(&mut self, sampled_image_stencil_sample_counts: SampleCountFlags) {
        self.raw.sampledImageStencilSampleCounts = sampled_image_stencil_sample_counts.bits();
    }

    pub fn set_storage_image_sample_counts<'m>(&mut self, storage_image_sample_counts: SampleCountFlags) {
        self.raw.storageImageSampleCounts = storage_image_sample_counts.bits();
    }

    pub fn set_max_sample_mask_words<'m>(&mut self, max_sample_mask_words: u32) {
        self.raw.maxSampleMaskWords = max_sample_mask_words.into();
    }

    pub fn set_timestamp_compute_and_graphics<'m>(&mut self, timestamp_compute_and_graphics: bool) {
        self.raw.timestampComputeAndGraphics = timestamp_compute_and_graphics as u32;
    }

    pub fn set_timestamp_period<'m>(&mut self, timestamp_period: f32) {
        self.raw.timestampPeriod = timestamp_period.into();
    }

    pub fn set_max_clip_distances<'m>(&mut self, max_clip_distances: u32) {
        self.raw.maxClipDistances = max_clip_distances.into();
    }

    pub fn set_max_cull_distances<'m>(&mut self, max_cull_distances: u32) {
        self.raw.maxCullDistances = max_cull_distances.into();
    }

    pub fn set_max_combined_clip_and_cull_distances<'m>(&mut self, max_combined_clip_and_cull_distances: u32) {
        self.raw.maxCombinedClipAndCullDistances = max_combined_clip_and_cull_distances.into();
    }

    pub fn set_discrete_queue_priorities<'m>(&mut self, discrete_queue_priorities: u32) {
        self.raw.discreteQueuePriorities = discrete_queue_priorities.into();
    }

    pub fn set_point_size_range<'m>(&mut self, point_size_range: [f32; 2]) {
        self.raw.pointSizeRange = point_size_range;
    }

    pub fn set_line_width_range<'m>(&mut self, line_width_range: [f32; 2]) {
        self.raw.lineWidthRange = line_width_range;
    }

    pub fn set_point_size_granularity<'m>(&mut self, point_size_granularity: f32) {
        self.raw.pointSizeGranularity = point_size_granularity.into();
    }

    pub fn set_line_width_granularity<'m>(&mut self, line_width_granularity: f32) {
        self.raw.lineWidthGranularity = line_width_granularity.into();
    }

    pub fn set_strict_lines<'m>(&mut self, strict_lines: bool) {
        self.raw.strictLines = strict_lines as u32;
    }

    pub fn set_standard_sample_locations<'m>(&mut self, standard_sample_locations: bool) {
        self.raw.standardSampleLocations = standard_sample_locations as u32;
    }

    pub fn set_optimal_buffer_copy_offset_alignment<'m>(&mut self, optimal_buffer_copy_offset_alignment: u64) {
        self.raw.optimalBufferCopyOffsetAlignment = optimal_buffer_copy_offset_alignment.into();
    }

    pub fn set_optimal_buffer_copy_row_pitch_alignment<'m>(&mut self, optimal_buffer_copy_row_pitch_alignment: u64) {
        self.raw.optimalBufferCopyRowPitchAlignment = optimal_buffer_copy_row_pitch_alignment.into();
    }

    pub fn set_non_coherent_atom_size<'m>(&mut self, non_coherent_atom_size: u64) {
        self.raw.nonCoherentAtomSize = non_coherent_atom_size.into();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceLimits {
        &self.raw
    }
}

impl From<PhysicalDeviceLimits> for vks::VkPhysicalDeviceLimits {
    fn from(f: PhysicalDeviceLimits) -> vks::VkPhysicalDeviceLimits {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceLimits`.
///
/// compute stage limits
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceLimitsBuilder {
    raw: vks::VkPhysicalDeviceLimits,
}

impl PhysicalDeviceLimitsBuilder {
    pub fn new() -> PhysicalDeviceLimitsBuilder {
        PhysicalDeviceLimitsBuilder {
            raw: vks::VkPhysicalDeviceLimits::default(),
        }
    }

    pub fn max_image_dimension_1d<'m>(mut self, max_image_dimension_1d: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxImageDimension1D = max_image_dimension_1d.into();
        self
    }

    pub fn max_image_dimension_2d<'m>(mut self, max_image_dimension_2d: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxImageDimension2D = max_image_dimension_2d.into();
        self
    }

    pub fn max_image_dimension_3d<'m>(mut self, max_image_dimension_3d: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxImageDimension3D = max_image_dimension_3d.into();
        self
    }

    pub fn max_image_dimension_cube<'m>(mut self, max_image_dimension_cube: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxImageDimensionCube = max_image_dimension_cube.into();
        self
    }

    pub fn max_image_array_layers<'m>(mut self, max_image_array_layers: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxImageArrayLayers = max_image_array_layers.into();
        self
    }

    pub fn max_texel_buffer_elements<'m>(mut self, max_texel_buffer_elements: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTexelBufferElements = max_texel_buffer_elements.into();
        self
    }

    pub fn max_uniform_buffer_range<'m>(mut self, max_uniform_buffer_range: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxUniformBufferRange = max_uniform_buffer_range.into();
        self
    }

    pub fn max_storage_buffer_range<'m>(mut self, max_storage_buffer_range: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxStorageBufferRange = max_storage_buffer_range.into();
        self
    }

    pub fn max_push_constants_size<'m>(mut self, max_push_constants_size: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxPushConstantsSize = max_push_constants_size.into();
        self
    }

    pub fn max_memory_allocation_count<'m>(mut self, max_memory_allocation_count: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxMemoryAllocationCount = max_memory_allocation_count.into();
        self
    }

    pub fn max_sampler_allocation_count<'m>(mut self, max_sampler_allocation_count: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxSamplerAllocationCount = max_sampler_allocation_count.into();
        self
    }

    pub fn buffer_image_granularity<'m>(mut self, buffer_image_granularity: u64) -> PhysicalDeviceLimitsBuilder {
        self.raw.bufferImageGranularity = buffer_image_granularity.into();
        self
    }

    pub fn sparse_address_space_size<'m>(mut self, sparse_address_space_size: u64) -> PhysicalDeviceLimitsBuilder {
        self.raw.sparseAddressSpaceSize = sparse_address_space_size.into();
        self
    }

    pub fn max_bound_descriptor_sets<'m>(mut self, max_bound_descriptor_sets: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxBoundDescriptorSets = max_bound_descriptor_sets.into();
        self
    }

    pub fn max_per_stage_descriptor_samplers<'m>(mut self, max_per_stage_descriptor_samplers: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxPerStageDescriptorSamplers = max_per_stage_descriptor_samplers.into();
        self
    }

    pub fn max_per_stage_descriptor_uniform_buffers<'m>(mut self, max_per_stage_descriptor_uniform_buffers: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxPerStageDescriptorUniformBuffers = max_per_stage_descriptor_uniform_buffers.into();
        self
    }

    pub fn max_per_stage_descriptor_storage_buffers<'m>(mut self, max_per_stage_descriptor_storage_buffers: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxPerStageDescriptorStorageBuffers = max_per_stage_descriptor_storage_buffers.into();
        self
    }

    pub fn max_per_stage_descriptor_sampled_images<'m>(mut self, max_per_stage_descriptor_sampled_images: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxPerStageDescriptorSampledImages = max_per_stage_descriptor_sampled_images.into();
        self
    }

    pub fn max_per_stage_descriptor_storage_images<'m>(mut self, max_per_stage_descriptor_storage_images: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxPerStageDescriptorStorageImages = max_per_stage_descriptor_storage_images.into();
        self
    }

    pub fn max_per_stage_descriptor_input_attachments<'m>(mut self, max_per_stage_descriptor_input_attachments: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxPerStageDescriptorInputAttachments = max_per_stage_descriptor_input_attachments.into();
        self
    }

    pub fn max_per_stage_resources<'m>(mut self, max_per_stage_resources: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxPerStageResources = max_per_stage_resources.into();
        self
    }

    pub fn max_descriptor_set_samplers<'m>(mut self, max_descriptor_set_samplers: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDescriptorSetSamplers = max_descriptor_set_samplers.into();
        self
    }

    pub fn max_descriptor_set_uniform_buffers<'m>(mut self, max_descriptor_set_uniform_buffers: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDescriptorSetUniformBuffers = max_descriptor_set_uniform_buffers.into();
        self
    }

    pub fn max_descriptor_set_uniform_buffers_dynamic<'m>(mut self, max_descriptor_set_uniform_buffers_dynamic: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDescriptorSetUniformBuffersDynamic = max_descriptor_set_uniform_buffers_dynamic.into();
        self
    }

    pub fn max_descriptor_set_storage_buffers<'m>(mut self, max_descriptor_set_storage_buffers: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDescriptorSetStorageBuffers = max_descriptor_set_storage_buffers.into();
        self
    }

    pub fn max_descriptor_set_storage_buffers_dynamic<'m>(mut self, max_descriptor_set_storage_buffers_dynamic: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDescriptorSetStorageBuffersDynamic = max_descriptor_set_storage_buffers_dynamic.into();
        self
    }

    pub fn max_descriptor_set_sampled_images<'m>(mut self, max_descriptor_set_sampled_images: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDescriptorSetSampledImages = max_descriptor_set_sampled_images.into();
        self
    }

    pub fn max_descriptor_set_storage_images<'m>(mut self, max_descriptor_set_storage_images: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDescriptorSetStorageImages = max_descriptor_set_storage_images.into();
        self
    }

    pub fn max_descriptor_set_input_attachments<'m>(mut self, max_descriptor_set_input_attachments: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDescriptorSetInputAttachments = max_descriptor_set_input_attachments.into();
        self
    }

    pub fn max_vertex_input_attributes<'m>(mut self, max_vertex_input_attributes: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxVertexInputAttributes = max_vertex_input_attributes.into();
        self
    }

    pub fn max_vertex_input_bindings<'m>(mut self, max_vertex_input_bindings: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxVertexInputBindings = max_vertex_input_bindings.into();
        self
    }

    pub fn max_vertex_input_attribute_offset<'m>(mut self, max_vertex_input_attribute_offset: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxVertexInputAttributeOffset = max_vertex_input_attribute_offset.into();
        self
    }

    pub fn max_vertex_input_binding_stride<'m>(mut self, max_vertex_input_binding_stride: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxVertexInputBindingStride = max_vertex_input_binding_stride.into();
        self
    }

    pub fn max_vertex_output_components<'m>(mut self, max_vertex_output_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxVertexOutputComponents = max_vertex_output_components.into();
        self
    }

    pub fn max_tessellation_generation_level<'m>(mut self, max_tessellation_generation_level: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTessellationGenerationLevel = max_tessellation_generation_level.into();
        self
    }

    pub fn max_tessellation_patch_size<'m>(mut self, max_tessellation_patch_size: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTessellationPatchSize = max_tessellation_patch_size.into();
        self
    }

    pub fn max_tessellation_control_per_vertex_input_components<'m>(mut self, max_tessellation_control_per_vertex_input_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTessellationControlPerVertexInputComponents = max_tessellation_control_per_vertex_input_components.into();
        self
    }

    pub fn max_tessellation_control_per_vertex_output_components<'m>(mut self, max_tessellation_control_per_vertex_output_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTessellationControlPerVertexOutputComponents = max_tessellation_control_per_vertex_output_components.into();
        self
    }

    pub fn max_tessellation_control_per_patch_output_components<'m>(mut self, max_tessellation_control_per_patch_output_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTessellationControlPerPatchOutputComponents = max_tessellation_control_per_patch_output_components.into();
        self
    }

    pub fn max_tessellation_control_total_output_components<'m>(mut self, max_tessellation_control_total_output_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTessellationControlTotalOutputComponents = max_tessellation_control_total_output_components.into();
        self
    }

    pub fn max_tessellation_evaluation_input_components<'m>(mut self, max_tessellation_evaluation_input_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTessellationEvaluationInputComponents = max_tessellation_evaluation_input_components.into();
        self
    }

    pub fn max_tessellation_evaluation_output_components<'m>(mut self, max_tessellation_evaluation_output_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTessellationEvaluationOutputComponents = max_tessellation_evaluation_output_components.into();
        self
    }

    pub fn max_geometry_shader_invocations<'m>(mut self, max_geometry_shader_invocations: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxGeometryShaderInvocations = max_geometry_shader_invocations.into();
        self
    }

    pub fn max_geometry_input_components<'m>(mut self, max_geometry_input_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxGeometryInputComponents = max_geometry_input_components.into();
        self
    }

    pub fn max_geometry_output_components<'m>(mut self, max_geometry_output_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxGeometryOutputComponents = max_geometry_output_components.into();
        self
    }

    pub fn max_geometry_output_vertices<'m>(mut self, max_geometry_output_vertices: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxGeometryOutputVertices = max_geometry_output_vertices.into();
        self
    }

    pub fn max_geometry_total_output_components<'m>(mut self, max_geometry_total_output_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxGeometryTotalOutputComponents = max_geometry_total_output_components.into();
        self
    }

    pub fn max_fragment_input_components<'m>(mut self, max_fragment_input_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxFragmentInputComponents = max_fragment_input_components.into();
        self
    }

    pub fn max_fragment_output_attachments<'m>(mut self, max_fragment_output_attachments: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxFragmentOutputAttachments = max_fragment_output_attachments.into();
        self
    }

    pub fn max_fragment_dual_src_attachments<'m>(mut self, max_fragment_dual_src_attachments: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxFragmentDualSrcAttachments = max_fragment_dual_src_attachments.into();
        self
    }

    pub fn max_fragment_combined_output_resources<'m>(mut self, max_fragment_combined_output_resources: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxFragmentCombinedOutputResources = max_fragment_combined_output_resources.into();
        self
    }

    pub fn max_compute_shared_memory_size<'m>(mut self, max_compute_shared_memory_size: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxComputeSharedMemorySize = max_compute_shared_memory_size.into();
        self
    }

    pub fn max_compute_work_group_count<'m>(mut self, max_compute_work_group_count: [u32; 3]) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxComputeWorkGroupCount = max_compute_work_group_count;
        self
    }

    pub fn max_compute_work_group_invocations<'m>(mut self, max_compute_work_group_invocations: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxComputeWorkGroupInvocations = max_compute_work_group_invocations.into();
        self
    }

    pub fn max_compute_work_group_size<'m>(mut self, max_compute_work_group_size: [u32; 3]) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxComputeWorkGroupSize = max_compute_work_group_size;
        self
    }

    pub fn sub_pixel_precision_bits<'m>(mut self, sub_pixel_precision_bits: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.subPixelPrecisionBits = sub_pixel_precision_bits.into();
        self
    }

    pub fn sub_texel_precision_bits<'m>(mut self, sub_texel_precision_bits: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.subTexelPrecisionBits = sub_texel_precision_bits.into();
        self
    }

    pub fn mipmap_precision_bits<'m>(mut self, mipmap_precision_bits: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.mipmapPrecisionBits = mipmap_precision_bits.into();
        self
    }

    pub fn max_draw_indexed_index_value<'m>(mut self, max_draw_indexed_index_value: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDrawIndexedIndexValue = max_draw_indexed_index_value.into();
        self
    }

    pub fn max_draw_indirect_count<'m>(mut self, max_draw_indirect_count: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDrawIndirectCount = max_draw_indirect_count.into();
        self
    }

    pub fn max_sampler_lod_bias<'m>(mut self, max_sampler_lod_bias: f32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxSamplerLodBias = max_sampler_lod_bias.into();
        self
    }

    pub fn max_sampler_anisotropy<'m>(mut self, max_sampler_anisotropy: f32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxSamplerAnisotropy = max_sampler_anisotropy.into();
        self
    }

    pub fn max_viewports<'m>(mut self, max_viewports: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxViewports = max_viewports.into();
        self
    }

    pub fn max_viewport_dimensions<'m>(mut self, max_viewport_dimensions: [u32; 2]) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxViewportDimensions = max_viewport_dimensions;
        self
    }

    pub fn viewport_bounds_range<'m>(mut self, viewport_bounds_range: [f32; 2]) -> PhysicalDeviceLimitsBuilder {
        self.raw.viewportBoundsRange = viewport_bounds_range;
        self
    }

    pub fn viewport_sub_pixel_bits<'m>(mut self, viewport_sub_pixel_bits: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.viewportSubPixelBits = viewport_sub_pixel_bits.into();
        self
    }

    pub fn min_memory_map_alignment<'m>(mut self, min_memory_map_alignment: usize) -> PhysicalDeviceLimitsBuilder {
        self.raw.minMemoryMapAlignment = min_memory_map_alignment.into();
        self
    }

    pub fn min_texel_buffer_offset_alignment<'m>(mut self, min_texel_buffer_offset_alignment: u64) -> PhysicalDeviceLimitsBuilder {
        self.raw.minTexelBufferOffsetAlignment = min_texel_buffer_offset_alignment.into();
        self
    }

    pub fn min_uniform_buffer_offset_alignment<'m>(mut self, min_uniform_buffer_offset_alignment: u64) -> PhysicalDeviceLimitsBuilder {
        self.raw.minUniformBufferOffsetAlignment = min_uniform_buffer_offset_alignment.into();
        self
    }

    pub fn min_storage_buffer_offset_alignment<'m>(mut self, min_storage_buffer_offset_alignment: u64) -> PhysicalDeviceLimitsBuilder {
        self.raw.minStorageBufferOffsetAlignment = min_storage_buffer_offset_alignment.into();
        self
    }

    pub fn min_texel_offset<'m>(mut self, min_texel_offset: i32) -> PhysicalDeviceLimitsBuilder {
        self.raw.minTexelOffset = min_texel_offset.into();
        self
    }

    pub fn max_texel_offset<'m>(mut self, max_texel_offset: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTexelOffset = max_texel_offset.into();
        self
    }

    pub fn min_texel_gather_offset<'m>(mut self, min_texel_gather_offset: i32) -> PhysicalDeviceLimitsBuilder {
        self.raw.minTexelGatherOffset = min_texel_gather_offset.into();
        self
    }

    pub fn max_texel_gather_offset<'m>(mut self, max_texel_gather_offset: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTexelGatherOffset = max_texel_gather_offset.into();
        self
    }

    pub fn min_interpolation_offset<'m>(mut self, min_interpolation_offset: f32) -> PhysicalDeviceLimitsBuilder {
        self.raw.minInterpolationOffset = min_interpolation_offset.into();
        self
    }

    pub fn max_interpolation_offset<'m>(mut self, max_interpolation_offset: f32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxInterpolationOffset = max_interpolation_offset.into();
        self
    }

    pub fn sub_pixel_interpolation_offset_bits<'m>(mut self, sub_pixel_interpolation_offset_bits: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.subPixelInterpolationOffsetBits = sub_pixel_interpolation_offset_bits.into();
        self
    }

    pub fn max_framebuffer_width<'m>(mut self, max_framebuffer_width: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxFramebufferWidth = max_framebuffer_width.into();
        self
    }

    pub fn max_framebuffer_height<'m>(mut self, max_framebuffer_height: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxFramebufferHeight = max_framebuffer_height.into();
        self
    }

    pub fn max_framebuffer_layers<'m>(mut self, max_framebuffer_layers: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxFramebufferLayers = max_framebuffer_layers.into();
        self
    }

    pub fn framebuffer_color_sample_counts<'m>(mut self, framebuffer_color_sample_counts: SampleCountFlags) -> PhysicalDeviceLimitsBuilder {
        self.raw.framebufferColorSampleCounts = framebuffer_color_sample_counts.bits();
        self
    }

    pub fn framebuffer_depth_sample_counts<'m>(mut self, framebuffer_depth_sample_counts: SampleCountFlags) -> PhysicalDeviceLimitsBuilder {
        self.raw.framebufferDepthSampleCounts = framebuffer_depth_sample_counts.bits();
        self
    }

    pub fn framebuffer_stencil_sample_counts<'m>(mut self, framebuffer_stencil_sample_counts: SampleCountFlags) -> PhysicalDeviceLimitsBuilder {
        self.raw.framebufferStencilSampleCounts = framebuffer_stencil_sample_counts.bits();
        self
    }

    pub fn framebuffer_no_attachments_sample_counts<'m>(mut self, framebuffer_no_attachments_sample_counts: SampleCountFlags) -> PhysicalDeviceLimitsBuilder {
        self.raw.framebufferNoAttachmentsSampleCounts = framebuffer_no_attachments_sample_counts.bits();
        self
    }

    pub fn max_color_attachments<'m>(mut self, max_color_attachments: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxColorAttachments = max_color_attachments.into();
        self
    }

    pub fn sampled_image_color_sample_counts<'m>(mut self, sampled_image_color_sample_counts: SampleCountFlags) -> PhysicalDeviceLimitsBuilder {
        self.raw.sampledImageColorSampleCounts = sampled_image_color_sample_counts.bits();
        self
    }

    pub fn sampled_image_integer_sample_counts<'m>(mut self, sampled_image_integer_sample_counts: SampleCountFlags) -> PhysicalDeviceLimitsBuilder {
        self.raw.sampledImageIntegerSampleCounts = sampled_image_integer_sample_counts.bits();
        self
    }

    pub fn sampled_image_depth_sample_counts<'m>(mut self, sampled_image_depth_sample_counts: SampleCountFlags) -> PhysicalDeviceLimitsBuilder {
        self.raw.sampledImageDepthSampleCounts = sampled_image_depth_sample_counts.bits();
        self
    }

    pub fn sampled_image_stencil_sample_counts<'m>(mut self, sampled_image_stencil_sample_counts: SampleCountFlags) -> PhysicalDeviceLimitsBuilder {
        self.raw.sampledImageStencilSampleCounts = sampled_image_stencil_sample_counts.bits();
        self
    }

    pub fn storage_image_sample_counts<'m>(mut self, storage_image_sample_counts: SampleCountFlags) -> PhysicalDeviceLimitsBuilder {
        self.raw.storageImageSampleCounts = storage_image_sample_counts.bits();
        self
    }

    pub fn max_sample_mask_words<'m>(mut self, max_sample_mask_words: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxSampleMaskWords = max_sample_mask_words.into();
        self
    }

    pub fn timestamp_compute_and_graphics<'m>(mut self, timestamp_compute_and_graphics: bool) -> PhysicalDeviceLimitsBuilder {
        self.raw.timestampComputeAndGraphics = timestamp_compute_and_graphics as u32;
        self
    }

    pub fn timestamp_period<'m>(mut self, timestamp_period: f32) -> PhysicalDeviceLimitsBuilder {
        self.raw.timestampPeriod = timestamp_period.into();
        self
    }

    pub fn max_clip_distances<'m>(mut self, max_clip_distances: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxClipDistances = max_clip_distances.into();
        self
    }

    pub fn max_cull_distances<'m>(mut self, max_cull_distances: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxCullDistances = max_cull_distances.into();
        self
    }

    pub fn max_combined_clip_and_cull_distances<'m>(mut self, max_combined_clip_and_cull_distances: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxCombinedClipAndCullDistances = max_combined_clip_and_cull_distances.into();
        self
    }

    pub fn discrete_queue_priorities<'m>(mut self, discrete_queue_priorities: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.discreteQueuePriorities = discrete_queue_priorities.into();
        self
    }

    pub fn point_size_range<'m>(mut self, point_size_range: [f32; 2]) -> PhysicalDeviceLimitsBuilder {
        self.raw.pointSizeRange = point_size_range;
        self
    }

    pub fn line_width_range<'m>(mut self, line_width_range: [f32; 2]) -> PhysicalDeviceLimitsBuilder {
        self.raw.lineWidthRange = line_width_range;
        self
    }

    pub fn point_size_granularity<'m>(mut self, point_size_granularity: f32) -> PhysicalDeviceLimitsBuilder {
        self.raw.pointSizeGranularity = point_size_granularity.into();
        self
    }

    pub fn line_width_granularity<'m>(mut self, line_width_granularity: f32) -> PhysicalDeviceLimitsBuilder {
        self.raw.lineWidthGranularity = line_width_granularity.into();
        self
    }

    pub fn strict_lines<'m>(mut self, strict_lines: bool) -> PhysicalDeviceLimitsBuilder {
        self.raw.strictLines = strict_lines as u32;
        self
    }

    pub fn standard_sample_locations<'m>(mut self, standard_sample_locations: bool) -> PhysicalDeviceLimitsBuilder {
        self.raw.standardSampleLocations = standard_sample_locations as u32;
        self
    }

    pub fn optimal_buffer_copy_offset_alignment<'m>(mut self, optimal_buffer_copy_offset_alignment: u64) -> PhysicalDeviceLimitsBuilder {
        self.raw.optimalBufferCopyOffsetAlignment = optimal_buffer_copy_offset_alignment.into();
        self
    }

    pub fn optimal_buffer_copy_row_pitch_alignment<'m>(mut self, optimal_buffer_copy_row_pitch_alignment: u64) -> PhysicalDeviceLimitsBuilder {
        self.raw.optimalBufferCopyRowPitchAlignment = optimal_buffer_copy_row_pitch_alignment.into();
        self
    }

    pub fn non_coherent_atom_size<'m>(mut self, non_coherent_atom_size: u64) -> PhysicalDeviceLimitsBuilder {
        self.raw.nonCoherentAtomSize = non_coherent_atom_size.into();
        self
    }

    pub fn get_max_image_dimension_1d<'a>(&'a self) -> u32 {
        self.raw.maxImageDimension1D.into()
    }

    pub fn get_max_image_dimension_2d<'a>(&'a self) -> u32 {
        self.raw.maxImageDimension2D.into()
    }

    pub fn get_max_image_dimension_3d<'a>(&'a self) -> u32 {
        self.raw.maxImageDimension3D.into()
    }

    pub fn get_max_image_dimension_cube<'a>(&'a self) -> u32 {
        self.raw.maxImageDimensionCube.into()
    }

    pub fn get_max_image_array_layers<'a>(&'a self) -> u32 {
        self.raw.maxImageArrayLayers.into()
    }

    pub fn get_max_texel_buffer_elements<'a>(&'a self) -> u32 {
        self.raw.maxTexelBufferElements.into()
    }

    pub fn get_max_uniform_buffer_range<'a>(&'a self) -> u32 {
        self.raw.maxUniformBufferRange.into()
    }

    pub fn get_max_storage_buffer_range<'a>(&'a self) -> u32 {
        self.raw.maxStorageBufferRange.into()
    }

    pub fn get_max_push_constants_size<'a>(&'a self) -> u32 {
        self.raw.maxPushConstantsSize.into()
    }

    pub fn get_max_memory_allocation_count<'a>(&'a self) -> u32 {
        self.raw.maxMemoryAllocationCount.into()
    }

    pub fn get_max_sampler_allocation_count<'a>(&'a self) -> u32 {
        self.raw.maxSamplerAllocationCount.into()
    }

    pub fn get_buffer_image_granularity<'a>(&'a self) -> u64 {
        self.raw.bufferImageGranularity.into()
    }

    pub fn get_sparse_address_space_size<'a>(&'a self) -> u64 {
        self.raw.sparseAddressSpaceSize.into()
    }

    pub fn get_max_bound_descriptor_sets<'a>(&'a self) -> u32 {
        self.raw.maxBoundDescriptorSets.into()
    }

    pub fn get_max_per_stage_descriptor_samplers<'a>(&'a self) -> u32 {
        self.raw.maxPerStageDescriptorSamplers.into()
    }

    pub fn get_max_per_stage_descriptor_uniform_buffers<'a>(&'a self) -> u32 {
        self.raw.maxPerStageDescriptorUniformBuffers.into()
    }

    pub fn get_max_per_stage_descriptor_storage_buffers<'a>(&'a self) -> u32 {
        self.raw.maxPerStageDescriptorStorageBuffers.into()
    }

    pub fn get_max_per_stage_descriptor_sampled_images<'a>(&'a self) -> u32 {
        self.raw.maxPerStageDescriptorSampledImages.into()
    }

    pub fn get_max_per_stage_descriptor_storage_images<'a>(&'a self) -> u32 {
        self.raw.maxPerStageDescriptorStorageImages.into()
    }

    pub fn get_max_per_stage_descriptor_input_attachments<'a>(&'a self) -> u32 {
        self.raw.maxPerStageDescriptorInputAttachments.into()
    }

    pub fn get_max_per_stage_resources<'a>(&'a self) -> u32 {
        self.raw.maxPerStageResources.into()
    }

    pub fn get_max_descriptor_set_samplers<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetSamplers.into()
    }

    pub fn get_max_descriptor_set_uniform_buffers<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetUniformBuffers.into()
    }

    pub fn get_max_descriptor_set_uniform_buffers_dynamic<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetUniformBuffersDynamic.into()
    }

    pub fn get_max_descriptor_set_storage_buffers<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetStorageBuffers.into()
    }

    pub fn get_max_descriptor_set_storage_buffers_dynamic<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetStorageBuffersDynamic.into()
    }

    pub fn get_max_descriptor_set_sampled_images<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetSampledImages.into()
    }

    pub fn get_max_descriptor_set_storage_images<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetStorageImages.into()
    }

    pub fn get_max_descriptor_set_input_attachments<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetInputAttachments.into()
    }

    pub fn get_max_vertex_input_attributes<'a>(&'a self) -> u32 {
        self.raw.maxVertexInputAttributes.into()
    }

    pub fn get_max_vertex_input_bindings<'a>(&'a self) -> u32 {
        self.raw.maxVertexInputBindings.into()
    }

    pub fn get_max_vertex_input_attribute_offset<'a>(&'a self) -> u32 {
        self.raw.maxVertexInputAttributeOffset.into()
    }

    pub fn get_max_vertex_input_binding_stride<'a>(&'a self) -> u32 {
        self.raw.maxVertexInputBindingStride.into()
    }

    pub fn get_max_vertex_output_components<'a>(&'a self) -> u32 {
        self.raw.maxVertexOutputComponents.into()
    }

    pub fn get_max_tessellation_generation_level<'a>(&'a self) -> u32 {
        self.raw.maxTessellationGenerationLevel.into()
    }

    pub fn get_max_tessellation_patch_size<'a>(&'a self) -> u32 {
        self.raw.maxTessellationPatchSize.into()
    }

    pub fn get_max_tessellation_control_per_vertex_input_components<'a>(&'a self) -> u32 {
        self.raw.maxTessellationControlPerVertexInputComponents.into()
    }

    pub fn get_max_tessellation_control_per_vertex_output_components<'a>(&'a self) -> u32 {
        self.raw.maxTessellationControlPerVertexOutputComponents.into()
    }

    pub fn get_max_tessellation_control_per_patch_output_components<'a>(&'a self) -> u32 {
        self.raw.maxTessellationControlPerPatchOutputComponents.into()
    }

    pub fn get_max_tessellation_control_total_output_components<'a>(&'a self) -> u32 {
        self.raw.maxTessellationControlTotalOutputComponents.into()
    }

    pub fn get_max_tessellation_evaluation_input_components<'a>(&'a self) -> u32 {
        self.raw.maxTessellationEvaluationInputComponents.into()
    }

    pub fn get_max_tessellation_evaluation_output_components<'a>(&'a self) -> u32 {
        self.raw.maxTessellationEvaluationOutputComponents.into()
    }

    pub fn get_max_geometry_shader_invocations<'a>(&'a self) -> u32 {
        self.raw.maxGeometryShaderInvocations.into()
    }

    pub fn get_max_geometry_input_components<'a>(&'a self) -> u32 {
        self.raw.maxGeometryInputComponents.into()
    }

    pub fn get_max_geometry_output_components<'a>(&'a self) -> u32 {
        self.raw.maxGeometryOutputComponents.into()
    }

    pub fn get_max_geometry_output_vertices<'a>(&'a self) -> u32 {
        self.raw.maxGeometryOutputVertices.into()
    }

    pub fn get_max_geometry_total_output_components<'a>(&'a self) -> u32 {
        self.raw.maxGeometryTotalOutputComponents.into()
    }

    pub fn get_max_fragment_input_components<'a>(&'a self) -> u32 {
        self.raw.maxFragmentInputComponents.into()
    }

    pub fn get_max_fragment_output_attachments<'a>(&'a self) -> u32 {
        self.raw.maxFragmentOutputAttachments.into()
    }

    pub fn get_max_fragment_dual_src_attachments<'a>(&'a self) -> u32 {
        self.raw.maxFragmentDualSrcAttachments.into()
    }

    pub fn get_max_fragment_combined_output_resources<'a>(&'a self) -> u32 {
        self.raw.maxFragmentCombinedOutputResources.into()
    }

    pub fn get_max_compute_shared_memory_size<'a>(&'a self) -> u32 {
        self.raw.maxComputeSharedMemorySize.into()
    }

    pub fn get_max_compute_work_group_count<'a>(&'a self) -> &[u32] {
        unsafe { slice::from_raw_parts(&self.raw.maxComputeWorkGroupCount as *const _, 3 as usize) }
    }

    pub fn get_max_compute_work_group_invocations<'a>(&'a self) -> u32 {
        self.raw.maxComputeWorkGroupInvocations.into()
    }

    pub fn get_max_compute_work_group_size<'a>(&'a self) -> &[u32] {
        unsafe { slice::from_raw_parts(&self.raw.maxComputeWorkGroupSize as *const _, 3 as usize) }
    }

    pub fn get_sub_pixel_precision_bits<'a>(&'a self) -> u32 {
        self.raw.subPixelPrecisionBits.into()
    }

    pub fn get_sub_texel_precision_bits<'a>(&'a self) -> u32 {
        self.raw.subTexelPrecisionBits.into()
    }

    pub fn get_mipmap_precision_bits<'a>(&'a self) -> u32 {
        self.raw.mipmapPrecisionBits.into()
    }

    pub fn get_max_draw_indexed_index_value<'a>(&'a self) -> u32 {
        self.raw.maxDrawIndexedIndexValue.into()
    }

    pub fn get_max_draw_indirect_count<'a>(&'a self) -> u32 {
        self.raw.maxDrawIndirectCount.into()
    }

    pub fn get_max_sampler_lod_bias<'a>(&'a self) -> f32 {
        self.raw.maxSamplerLodBias.into()
    }

    pub fn get_max_sampler_anisotropy<'a>(&'a self) -> f32 {
        self.raw.maxSamplerAnisotropy.into()
    }

    pub fn get_max_viewports<'a>(&'a self) -> u32 {
        self.raw.maxViewports.into()
    }

    pub fn get_max_viewport_dimensions<'a>(&'a self) -> &[u32] {
        unsafe { slice::from_raw_parts(&self.raw.maxViewportDimensions as *const _, 2 as usize) }
    }

    pub fn get_viewport_bounds_range<'a>(&'a self) -> &[f32] {
        unsafe { slice::from_raw_parts(&self.raw.viewportBoundsRange as *const _, 2 as usize) }
    }

    pub fn get_viewport_sub_pixel_bits<'a>(&'a self) -> u32 {
        self.raw.viewportSubPixelBits.into()
    }

    pub fn get_min_memory_map_alignment<'a>(&'a self) -> usize {
        self.raw.minMemoryMapAlignment.into()
    }

    pub fn get_min_texel_buffer_offset_alignment<'a>(&'a self) -> u64 {
        self.raw.minTexelBufferOffsetAlignment.into()
    }

    pub fn get_min_uniform_buffer_offset_alignment<'a>(&'a self) -> u64 {
        self.raw.minUniformBufferOffsetAlignment.into()
    }

    pub fn get_min_storage_buffer_offset_alignment<'a>(&'a self) -> u64 {
        self.raw.minStorageBufferOffsetAlignment.into()
    }

    pub fn get_min_texel_offset<'a>(&'a self) -> i32 {
        self.raw.minTexelOffset.into()
    }

    pub fn get_max_texel_offset<'a>(&'a self) -> u32 {
        self.raw.maxTexelOffset.into()
    }

    pub fn get_min_texel_gather_offset<'a>(&'a self) -> i32 {
        self.raw.minTexelGatherOffset.into()
    }

    pub fn get_max_texel_gather_offset<'a>(&'a self) -> u32 {
        self.raw.maxTexelGatherOffset.into()
    }

    pub fn get_min_interpolation_offset<'a>(&'a self) -> f32 {
        self.raw.minInterpolationOffset.into()
    }

    pub fn get_max_interpolation_offset<'a>(&'a self) -> f32 {
        self.raw.maxInterpolationOffset.into()
    }

    pub fn get_sub_pixel_interpolation_offset_bits<'a>(&'a self) -> u32 {
        self.raw.subPixelInterpolationOffsetBits.into()
    }

    pub fn get_max_framebuffer_width<'a>(&'a self) -> u32 {
        self.raw.maxFramebufferWidth.into()
    }

    pub fn get_max_framebuffer_height<'a>(&'a self) -> u32 {
        self.raw.maxFramebufferHeight.into()
    }

    pub fn get_max_framebuffer_layers<'a>(&'a self) -> u32 {
        self.raw.maxFramebufferLayers.into()
    }

    pub fn get_framebuffer_color_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.framebufferColorSampleCounts)
            .expect("PhysicalDeviceLimits::framebuffer_color_sample_counts: error converting flags")
    }

    pub fn get_framebuffer_depth_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.framebufferDepthSampleCounts)
            .expect("PhysicalDeviceLimits::framebuffer_depth_sample_counts: error converting flags")
    }

    pub fn get_framebuffer_stencil_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.framebufferStencilSampleCounts)
            .expect("PhysicalDeviceLimits::framebuffer_stencil_sample_counts: error converting flags")
    }

    pub fn get_framebuffer_no_attachments_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.framebufferNoAttachmentsSampleCounts)
            .expect("PhysicalDeviceLimits::framebuffer_no_attachments_sample_counts: error converting flags")
    }

    pub fn get_max_color_attachments<'a>(&'a self) -> u32 {
        self.raw.maxColorAttachments.into()
    }

    pub fn get_sampled_image_color_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.sampledImageColorSampleCounts)
            .expect("PhysicalDeviceLimits::sampled_image_color_sample_counts: error converting flags")
    }

    pub fn get_sampled_image_integer_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.sampledImageIntegerSampleCounts)
            .expect("PhysicalDeviceLimits::sampled_image_integer_sample_counts: error converting flags")
    }

    pub fn get_sampled_image_depth_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.sampledImageDepthSampleCounts)
            .expect("PhysicalDeviceLimits::sampled_image_depth_sample_counts: error converting flags")
    }

    pub fn get_sampled_image_stencil_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.sampledImageStencilSampleCounts)
            .expect("PhysicalDeviceLimits::sampled_image_stencil_sample_counts: error converting flags")
    }

    pub fn get_storage_image_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.storageImageSampleCounts)
            .expect("PhysicalDeviceLimits::storage_image_sample_counts: error converting flags")
    }

    pub fn get_max_sample_mask_words<'a>(&'a self) -> u32 {
        self.raw.maxSampleMaskWords.into()
    }

    pub fn get_timestamp_compute_and_graphics<'a>(&'a self) -> bool {
        self.raw.timestampComputeAndGraphics != 0
    }

    pub fn get_timestamp_period<'a>(&'a self) -> f32 {
        self.raw.timestampPeriod.into()
    }

    pub fn get_max_clip_distances<'a>(&'a self) -> u32 {
        self.raw.maxClipDistances.into()
    }

    pub fn get_max_cull_distances<'a>(&'a self) -> u32 {
        self.raw.maxCullDistances.into()
    }

    pub fn get_max_combined_clip_and_cull_distances<'a>(&'a self) -> u32 {
        self.raw.maxCombinedClipAndCullDistances.into()
    }

    pub fn get_discrete_queue_priorities<'a>(&'a self) -> u32 {
        self.raw.discreteQueuePriorities.into()
    }

    pub fn get_point_size_range<'a>(&'a self) -> &[f32] {
        unsafe { slice::from_raw_parts(&self.raw.pointSizeRange as *const _, 2 as usize) }
    }

    pub fn get_line_width_range<'a>(&'a self) -> &[f32] {
        unsafe { slice::from_raw_parts(&self.raw.lineWidthRange as *const _, 2 as usize) }
    }

    pub fn get_point_size_granularity<'a>(&'a self) -> f32 {
        self.raw.pointSizeGranularity.into()
    }

    pub fn get_line_width_granularity<'a>(&'a self) -> f32 {
        self.raw.lineWidthGranularity.into()
    }

    pub fn get_strict_lines<'a>(&'a self) -> bool {
        self.raw.strictLines != 0
    }

    pub fn get_standard_sample_locations<'a>(&'a self) -> bool {
        self.raw.standardSampleLocations != 0
    }

    pub fn get_optimal_buffer_copy_offset_alignment<'a>(&'a self) -> u64 {
        self.raw.optimalBufferCopyOffsetAlignment.into()
    }

    pub fn get_optimal_buffer_copy_row_pitch_alignment<'a>(&'a self) -> u64 {
        self.raw.optimalBufferCopyRowPitchAlignment.into()
    }

    pub fn get_non_coherent_atom_size<'a>(&'a self) -> u64 {
        self.raw.nonCoherentAtomSize.into()
    }

    pub fn build(self) -> PhysicalDeviceLimits {
        PhysicalDeviceLimits {
            raw: self.raw,
        }
    }
}


/// A `VkSemaphoreCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SemaphoreCreateInfo<'s> {
    raw: vks::VkSemaphoreCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> SemaphoreCreateInfo<'s> {
    pub fn builder<'b>() -> SemaphoreCreateInfoBuilder<'b> {
        SemaphoreCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSemaphoreCreateInfo) -> SemaphoreCreateInfo<'s> {
        SemaphoreCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> SemaphoreCreateFlags {
        SemaphoreCreateFlags::from_bits(self.raw.flags)
            .expect("SemaphoreCreateInfo::flags: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: SemaphoreCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSemaphoreCreateInfo {
        &self.raw
    }
}

impl<'s> From<SemaphoreCreateInfo<'s>> for vks::VkSemaphoreCreateInfo {
    fn from(f: SemaphoreCreateInfo<'s>) -> vks::VkSemaphoreCreateInfo {
        f.raw
    }
}


/// A builder for `VkSemaphoreCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SemaphoreCreateInfoBuilder<'b> {
    raw: vks::VkSemaphoreCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SemaphoreCreateInfoBuilder<'b> {
    pub fn new() -> SemaphoreCreateInfoBuilder<'b> {
        SemaphoreCreateInfoBuilder {
            raw: vks::VkSemaphoreCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> SemaphoreCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: SemaphoreCreateFlags) -> SemaphoreCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> SemaphoreCreateFlags {
        SemaphoreCreateFlags::from_bits(self.raw.flags)
            .expect("SemaphoreCreateInfo::flags: error converting flags")
    }

    pub fn build(self) -> SemaphoreCreateInfo<'b> {
        SemaphoreCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkQueryPoolCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct QueryPoolCreateInfo<'s> {
    raw: vks::VkQueryPoolCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> QueryPoolCreateInfo<'s> {
    pub fn builder<'b>() -> QueryPoolCreateInfoBuilder<'b> {
        QueryPoolCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkQueryPoolCreateInfo) -> QueryPoolCreateInfo<'s> {
        QueryPoolCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> QueryPoolCreateFlags {
        QueryPoolCreateFlags::from_bits(self.raw.flags)
            .expect("QueryPoolCreateInfo::flags: error converting flags")
    }

    pub fn query_type<'a>(&'a self) -> QueryType {
        self.raw.queryType.into()
    }

    pub fn query_count<'a>(&'a self) -> u32 {
        self.raw.queryCount.into()
    }

    pub fn pipeline_statistics<'a>(&'a self) -> QueryPipelineStatisticFlags {
        QueryPipelineStatisticFlags::from_bits(self.raw.pipelineStatistics)
            .expect("QueryPoolCreateInfo::pipeline_statistics: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: QueryPoolCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_query_type<'m>(&mut self, query_type: QueryType) {
        self.raw.queryType = query_type.into();
    }

    pub fn set_query_count<'m>(&mut self, query_count: u32) {
        self.raw.queryCount = query_count.into();
    }

    pub fn set_pipeline_statistics<'m>(&mut self, pipeline_statistics: QueryPipelineStatisticFlags) {
        self.raw.pipelineStatistics = pipeline_statistics.bits();
    }

    pub fn as_raw(&self) -> &vks::VkQueryPoolCreateInfo {
        &self.raw
    }
}

impl<'s> From<QueryPoolCreateInfo<'s>> for vks::VkQueryPoolCreateInfo {
    fn from(f: QueryPoolCreateInfo<'s>) -> vks::VkQueryPoolCreateInfo {
        f.raw
    }
}


/// A builder for `VkQueryPoolCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct QueryPoolCreateInfoBuilder<'b> {
    raw: vks::VkQueryPoolCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> QueryPoolCreateInfoBuilder<'b> {
    pub fn new() -> QueryPoolCreateInfoBuilder<'b> {
        QueryPoolCreateInfoBuilder {
            raw: vks::VkQueryPoolCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> QueryPoolCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: QueryPoolCreateFlags) -> QueryPoolCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn query_type<'m>(mut self, query_type: QueryType) -> QueryPoolCreateInfoBuilder<'b> {
        self.raw.queryType = query_type.into();
        self
    }

    pub fn query_count<'m>(mut self, query_count: u32) -> QueryPoolCreateInfoBuilder<'b> {
        self.raw.queryCount = query_count.into();
        self
    }

    pub fn pipeline_statistics<'m>(mut self, pipeline_statistics: QueryPipelineStatisticFlags) -> QueryPoolCreateInfoBuilder<'b> {
        self.raw.pipelineStatistics = pipeline_statistics.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> QueryPoolCreateFlags {
        QueryPoolCreateFlags::from_bits(self.raw.flags)
            .expect("QueryPoolCreateInfo::flags: error converting flags")
    }

    pub fn get_query_type<'a>(&'a self) -> QueryType {
        self.raw.queryType.into()
    }

    pub fn get_query_count<'a>(&'a self) -> u32 {
        self.raw.queryCount.into()
    }

    pub fn get_pipeline_statistics<'a>(&'a self) -> QueryPipelineStatisticFlags {
        QueryPipelineStatisticFlags::from_bits(self.raw.pipelineStatistics)
            .expect("QueryPoolCreateInfo::pipeline_statistics: error converting flags")
    }

    pub fn build(self) -> QueryPoolCreateInfo<'b> {
        QueryPoolCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkFramebufferCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct FramebufferCreateInfo<'s> {
    raw: vks::VkFramebufferCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> FramebufferCreateInfo<'s> {
    pub fn builder<'b>() -> FramebufferCreateInfoBuilder<'b> {
        FramebufferCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkFramebufferCreateInfo) -> FramebufferCreateInfo<'s> {
        FramebufferCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> FramebufferCreateFlags {
        FramebufferCreateFlags::from_bits(self.raw.flags)
            .expect("FramebufferCreateInfo::flags: error converting flags")
    }

    pub fn render_pass<'a>(&'a self) -> vks::VkRenderPass {
        self.raw.renderPass
    }

    pub fn attachments<'a>(&'a self) -> &'a [vks::VkImageView] {
        unsafe { slice::from_raw_parts(self.raw.pAttachments as *const _, self.raw.attachmentCount as usize) }
    }

    pub fn width<'a>(&'a self) -> u32 {
        self.raw.width.into()
    }

    pub fn height<'a>(&'a self) -> u32 {
        self.raw.height.into()
    }

    pub fn layers<'a>(&'a self) -> u32 {
        self.raw.layers.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: FramebufferCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_render_pass<'m, H>(&mut self, render_pass: H)
            where H: Handle<Target=RenderPassHandle> {
        self.raw.renderPass = render_pass.handle().0;
    }

    pub fn set_attachments<'m, 'a>(&mut self, attachments: &'a [ImageViewHandle])
            where 'a: 's {
        assert!(self.raw.attachmentCount == 0 || self.raw.attachmentCount == attachments.len() as _, 
            "count inconsistency found when specifying `FramebufferCreateInfo::attachments`.");
        self.raw.attachmentCount = attachments.len() as _;
        self.raw.pAttachments = attachments.as_ptr() as *const vks::VkImageView;
    }

    pub fn set_width<'m>(&mut self, width: u32) {
        self.raw.width = width.into();
    }

    pub fn set_height<'m>(&mut self, height: u32) {
        self.raw.height = height.into();
    }

    pub fn set_layers<'m>(&mut self, layers: u32) {
        self.raw.layers = layers.into();
    }

    pub fn as_raw(&self) -> &vks::VkFramebufferCreateInfo {
        &self.raw
    }
}

impl<'s> From<FramebufferCreateInfo<'s>> for vks::VkFramebufferCreateInfo {
    fn from(f: FramebufferCreateInfo<'s>) -> vks::VkFramebufferCreateInfo {
        f.raw
    }
}


/// A builder for `VkFramebufferCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct FramebufferCreateInfoBuilder<'b> {
    raw: vks::VkFramebufferCreateInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> FramebufferCreateInfoBuilder<'b> {
    pub fn new() -> FramebufferCreateInfoBuilder<'b> {
        FramebufferCreateInfoBuilder {
            raw: vks::VkFramebufferCreateInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> FramebufferCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: FramebufferCreateFlags) -> FramebufferCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn render_pass<'m, H>(mut self, render_pass: H) -> FramebufferCreateInfoBuilder<'b>
            where H: Handle<Target=RenderPassHandle> {
        self.raw.renderPass = render_pass.handle().0;
        self
    }

    pub fn attachments<'m, 'a>(mut self, attachments: &'a [ImageViewHandle]) -> FramebufferCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.attachmentCount == 0 || self.raw.attachmentCount == attachments.len() as _, 
            "count inconsistency found when specifying `FramebufferCreateInfo::attachments`.");
        self.raw.attachmentCount = attachments.len() as _;
        self.raw.pAttachments = attachments.as_ptr() as *const vks::VkImageView;
        self
    }

    pub fn width<'m>(mut self, width: u32) -> FramebufferCreateInfoBuilder<'b> {
        self.raw.width = width.into();
        self
    }

    pub fn height<'m>(mut self, height: u32) -> FramebufferCreateInfoBuilder<'b> {
        self.raw.height = height.into();
        self
    }

    pub fn layers<'m>(mut self, layers: u32) -> FramebufferCreateInfoBuilder<'b> {
        self.raw.layers = layers.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> FramebufferCreateFlags {
        FramebufferCreateFlags::from_bits(self.raw.flags)
            .expect("FramebufferCreateInfo::flags: error converting flags")
    }

    pub fn get_render_pass<'a>(&'a self) -> vks::VkRenderPass {
        self.raw.renderPass
    }

    pub fn get_attachments<'a>(&'a self) -> &'a [vks::VkImageView] {
        unsafe { slice::from_raw_parts(self.raw.pAttachments as *const _, self.raw.attachmentCount as usize) }
    }

    pub fn get_width<'a>(&'a self) -> u32 {
        self.raw.width.into()
    }

    pub fn get_height<'a>(&'a self) -> u32 {
        self.raw.height.into()
    }

    pub fn get_layers<'a>(&'a self) -> u32 {
        self.raw.layers.into()
    }

    pub fn build(self) -> FramebufferCreateInfo<'b> {
        FramebufferCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDrawIndirectCommand`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DrawIndirectCommand {
    raw: vks::VkDrawIndirectCommand,
}

impl DrawIndirectCommand {
    pub fn builder() -> DrawIndirectCommandBuilder {
        DrawIndirectCommandBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDrawIndirectCommand) -> DrawIndirectCommand {
        DrawIndirectCommand { raw, }
    }

    pub fn vertex_count<'a>(&'a self) -> u32 {
        self.raw.vertexCount.into()
    }

    pub fn instance_count<'a>(&'a self) -> u32 {
        self.raw.instanceCount.into()
    }

    pub fn first_vertex<'a>(&'a self) -> u32 {
        self.raw.firstVertex.into()
    }

    pub fn first_instance<'a>(&'a self) -> u32 {
        self.raw.firstInstance.into()
    }

    pub fn set_vertex_count<'m>(&mut self, vertex_count: u32) {
        self.raw.vertexCount = vertex_count.into();
    }

    pub fn set_instance_count<'m>(&mut self, instance_count: u32) {
        self.raw.instanceCount = instance_count.into();
    }

    pub fn set_first_vertex<'m>(&mut self, first_vertex: u32) {
        self.raw.firstVertex = first_vertex.into();
    }

    pub fn set_first_instance<'m>(&mut self, first_instance: u32) {
        self.raw.firstInstance = first_instance.into();
    }

    pub fn as_raw(&self) -> &vks::VkDrawIndirectCommand {
        &self.raw
    }
}

impl From<DrawIndirectCommand> for vks::VkDrawIndirectCommand {
    fn from(f: DrawIndirectCommand) -> vks::VkDrawIndirectCommand {
        f.raw
    }
}


/// A builder for `VkDrawIndirectCommand`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DrawIndirectCommandBuilder {
    raw: vks::VkDrawIndirectCommand,
}

impl DrawIndirectCommandBuilder {
    pub fn new() -> DrawIndirectCommandBuilder {
        DrawIndirectCommandBuilder {
            raw: vks::VkDrawIndirectCommand::default(),
        }
    }

    pub fn vertex_count<'m>(mut self, vertex_count: u32) -> DrawIndirectCommandBuilder {
        self.raw.vertexCount = vertex_count.into();
        self
    }

    pub fn instance_count<'m>(mut self, instance_count: u32) -> DrawIndirectCommandBuilder {
        self.raw.instanceCount = instance_count.into();
        self
    }

    pub fn first_vertex<'m>(mut self, first_vertex: u32) -> DrawIndirectCommandBuilder {
        self.raw.firstVertex = first_vertex.into();
        self
    }

    pub fn first_instance<'m>(mut self, first_instance: u32) -> DrawIndirectCommandBuilder {
        self.raw.firstInstance = first_instance.into();
        self
    }

    pub fn get_vertex_count<'a>(&'a self) -> u32 {
        self.raw.vertexCount.into()
    }

    pub fn get_instance_count<'a>(&'a self) -> u32 {
        self.raw.instanceCount.into()
    }

    pub fn get_first_vertex<'a>(&'a self) -> u32 {
        self.raw.firstVertex.into()
    }

    pub fn get_first_instance<'a>(&'a self) -> u32 {
        self.raw.firstInstance.into()
    }

    pub fn build(self) -> DrawIndirectCommand {
        DrawIndirectCommand {
            raw: self.raw,
        }
    }
}


/// A `VkDrawIndexedIndirectCommand`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DrawIndexedIndirectCommand {
    raw: vks::VkDrawIndexedIndirectCommand,
}

impl DrawIndexedIndirectCommand {
    pub fn builder() -> DrawIndexedIndirectCommandBuilder {
        DrawIndexedIndirectCommandBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDrawIndexedIndirectCommand) -> DrawIndexedIndirectCommand {
        DrawIndexedIndirectCommand { raw, }
    }

    pub fn index_count<'a>(&'a self) -> u32 {
        self.raw.indexCount.into()
    }

    pub fn instance_count<'a>(&'a self) -> u32 {
        self.raw.instanceCount.into()
    }

    pub fn first_index<'a>(&'a self) -> u32 {
        self.raw.firstIndex.into()
    }

    pub fn vertex_offset<'a>(&'a self) -> i32 {
        self.raw.vertexOffset.into()
    }

    pub fn first_instance<'a>(&'a self) -> u32 {
        self.raw.firstInstance.into()
    }

    pub fn set_index_count<'m>(&mut self, index_count: u32) {
        self.raw.indexCount = index_count.into();
    }

    pub fn set_instance_count<'m>(&mut self, instance_count: u32) {
        self.raw.instanceCount = instance_count.into();
    }

    pub fn set_first_index<'m>(&mut self, first_index: u32) {
        self.raw.firstIndex = first_index.into();
    }

    pub fn set_vertex_offset<'m>(&mut self, vertex_offset: i32) {
        self.raw.vertexOffset = vertex_offset.into();
    }

    pub fn set_first_instance<'m>(&mut self, first_instance: u32) {
        self.raw.firstInstance = first_instance.into();
    }

    pub fn as_raw(&self) -> &vks::VkDrawIndexedIndirectCommand {
        &self.raw
    }
}

impl From<DrawIndexedIndirectCommand> for vks::VkDrawIndexedIndirectCommand {
    fn from(f: DrawIndexedIndirectCommand) -> vks::VkDrawIndexedIndirectCommand {
        f.raw
    }
}


/// A builder for `VkDrawIndexedIndirectCommand`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DrawIndexedIndirectCommandBuilder {
    raw: vks::VkDrawIndexedIndirectCommand,
}

impl DrawIndexedIndirectCommandBuilder {
    pub fn new() -> DrawIndexedIndirectCommandBuilder {
        DrawIndexedIndirectCommandBuilder {
            raw: vks::VkDrawIndexedIndirectCommand::default(),
        }
    }

    pub fn index_count<'m>(mut self, index_count: u32) -> DrawIndexedIndirectCommandBuilder {
        self.raw.indexCount = index_count.into();
        self
    }

    pub fn instance_count<'m>(mut self, instance_count: u32) -> DrawIndexedIndirectCommandBuilder {
        self.raw.instanceCount = instance_count.into();
        self
    }

    pub fn first_index<'m>(mut self, first_index: u32) -> DrawIndexedIndirectCommandBuilder {
        self.raw.firstIndex = first_index.into();
        self
    }

    pub fn vertex_offset<'m>(mut self, vertex_offset: i32) -> DrawIndexedIndirectCommandBuilder {
        self.raw.vertexOffset = vertex_offset.into();
        self
    }

    pub fn first_instance<'m>(mut self, first_instance: u32) -> DrawIndexedIndirectCommandBuilder {
        self.raw.firstInstance = first_instance.into();
        self
    }

    pub fn get_index_count<'a>(&'a self) -> u32 {
        self.raw.indexCount.into()
    }

    pub fn get_instance_count<'a>(&'a self) -> u32 {
        self.raw.instanceCount.into()
    }

    pub fn get_first_index<'a>(&'a self) -> u32 {
        self.raw.firstIndex.into()
    }

    pub fn get_vertex_offset<'a>(&'a self) -> i32 {
        self.raw.vertexOffset.into()
    }

    pub fn get_first_instance<'a>(&'a self) -> u32 {
        self.raw.firstInstance.into()
    }

    pub fn build(self) -> DrawIndexedIndirectCommand {
        DrawIndexedIndirectCommand {
            raw: self.raw,
        }
    }
}


/// A `VkDispatchIndirectCommand`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DispatchIndirectCommand {
    raw: vks::VkDispatchIndirectCommand,
}

impl DispatchIndirectCommand {
    pub fn builder() -> DispatchIndirectCommandBuilder {
        DispatchIndirectCommandBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDispatchIndirectCommand) -> DispatchIndirectCommand {
        DispatchIndirectCommand { raw, }
    }

    pub fn x<'a>(&'a self) -> u32 {
        self.raw.x.into()
    }

    pub fn y<'a>(&'a self) -> u32 {
        self.raw.y.into()
    }

    pub fn z<'a>(&'a self) -> u32 {
        self.raw.z.into()
    }

    pub fn set_x<'m>(&mut self, x: u32) {
        self.raw.x = x.into();
    }

    pub fn set_y<'m>(&mut self, y: u32) {
        self.raw.y = y.into();
    }

    pub fn set_z<'m>(&mut self, z: u32) {
        self.raw.z = z.into();
    }

    pub fn as_raw(&self) -> &vks::VkDispatchIndirectCommand {
        &self.raw
    }
}

impl From<DispatchIndirectCommand> for vks::VkDispatchIndirectCommand {
    fn from(f: DispatchIndirectCommand) -> vks::VkDispatchIndirectCommand {
        f.raw
    }
}


/// A builder for `VkDispatchIndirectCommand`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DispatchIndirectCommandBuilder {
    raw: vks::VkDispatchIndirectCommand,
}

impl DispatchIndirectCommandBuilder {
    pub fn new() -> DispatchIndirectCommandBuilder {
        DispatchIndirectCommandBuilder {
            raw: vks::VkDispatchIndirectCommand::default(),
        }
    }

    pub fn x<'m>(mut self, x: u32) -> DispatchIndirectCommandBuilder {
        self.raw.x = x.into();
        self
    }

    pub fn y<'m>(mut self, y: u32) -> DispatchIndirectCommandBuilder {
        self.raw.y = y.into();
        self
    }

    pub fn z<'m>(mut self, z: u32) -> DispatchIndirectCommandBuilder {
        self.raw.z = z.into();
        self
    }

    pub fn get_x<'a>(&'a self) -> u32 {
        self.raw.x.into()
    }

    pub fn get_y<'a>(&'a self) -> u32 {
        self.raw.y.into()
    }

    pub fn get_z<'a>(&'a self) -> u32 {
        self.raw.z.into()
    }

    pub fn build(self) -> DispatchIndirectCommand {
        DispatchIndirectCommand {
            raw: self.raw,
        }
    }
}


/// A `VkSubmitInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SubmitInfo<'s> {
    raw: vks::VkSubmitInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> SubmitInfo<'s> {
    pub fn builder<'b>() -> SubmitInfoBuilder<'b> {
        SubmitInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSubmitInfo) -> SubmitInfo<'s> {
        SubmitInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn wait_semaphores<'a>(&'a self) -> &'a [vks::VkSemaphore] {
        unsafe { slice::from_raw_parts(self.raw.pWaitSemaphores as *const _, self.raw.waitSemaphoreCount as usize) }
    }

    pub fn wait_dst_stage_mask<'a>(&'a self) -> &'a PipelineStageFlags {
        unsafe { &*(self.raw.pWaitDstStageMask as *const _) }
    }

    pub fn command_buffers<'a>(&'a self) -> &'a [vks::VkCommandBuffer] {
        unsafe { slice::from_raw_parts(self.raw.pCommandBuffers as *const _, self.raw.commandBufferCount as usize) }
    }

    pub fn signal_semaphores<'a>(&'a self) -> &'a [vks::VkSemaphore] {
        unsafe { slice::from_raw_parts(self.raw.pSignalSemaphores as *const _, self.raw.signalSemaphoreCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_wait_semaphores<'m, 'a>(&mut self, wait_semaphores: &'a [SemaphoreHandle])
            where 'a: 's {
        assert!(self.raw.waitSemaphoreCount == 0 || self.raw.waitSemaphoreCount == wait_semaphores.len() as _, 
            "count inconsistency found when specifying `SubmitInfo::wait_semaphores`.");
        self.raw.waitSemaphoreCount = wait_semaphores.len() as _;
        self.raw.pWaitSemaphores = wait_semaphores.as_ptr() as *const vks::VkSemaphore;
    }

    pub fn set_wait_dst_stage_mask<'m, 'a>(&mut self, wait_dst_stage_mask: &'a PipelineStageFlags) {
        self.raw.pWaitDstStageMask = wait_dst_stage_mask as *const PipelineStageFlags as *const _;
    }

    pub fn set_command_buffers<'m, 'a>(&mut self, command_buffers: &'a [CommandBufferHandle])
            where 'a: 's {
        assert!(self.raw.commandBufferCount == 0 || self.raw.commandBufferCount == command_buffers.len() as _, 
            "count inconsistency found when specifying `SubmitInfo::command_buffers`.");
        self.raw.commandBufferCount = command_buffers.len() as _;
        self.raw.pCommandBuffers = command_buffers.as_ptr() as *const vks::VkCommandBuffer;
    }

    pub fn set_signal_semaphores<'m, 'a>(&mut self, signal_semaphores: &'a [SemaphoreHandle])
            where 'a: 's {
        assert!(self.raw.signalSemaphoreCount == 0 || self.raw.signalSemaphoreCount == signal_semaphores.len() as _, 
            "count inconsistency found when specifying `SubmitInfo::signal_semaphores`.");
        self.raw.signalSemaphoreCount = signal_semaphores.len() as _;
        self.raw.pSignalSemaphores = signal_semaphores.as_ptr() as *const vks::VkSemaphore;
    }

    pub fn as_raw(&self) -> &vks::VkSubmitInfo {
        &self.raw
    }
}

impl<'s> From<SubmitInfo<'s>> for vks::VkSubmitInfo {
    fn from(f: SubmitInfo<'s>) -> vks::VkSubmitInfo {
        f.raw
    }
}


/// A builder for `VkSubmitInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SubmitInfoBuilder<'b> {
    raw: vks::VkSubmitInfo,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SubmitInfoBuilder<'b> {
    pub fn new() -> SubmitInfoBuilder<'b> {
        SubmitInfoBuilder {
            raw: vks::VkSubmitInfo::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> SubmitInfoBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn wait_semaphores<'m, 'a>(mut self, wait_semaphores: &'a [SemaphoreHandle]) -> SubmitInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.waitSemaphoreCount == 0 || self.raw.waitSemaphoreCount == wait_semaphores.len() as _, 
            "count inconsistency found when specifying `SubmitInfo::wait_semaphores`.");
        self.raw.waitSemaphoreCount = wait_semaphores.len() as _;
        self.raw.pWaitSemaphores = wait_semaphores.as_ptr() as *const vks::VkSemaphore;
        self
    }

    pub fn wait_dst_stage_mask<'m, 'a>(mut self, wait_dst_stage_mask: &'a PipelineStageFlags) -> SubmitInfoBuilder<'b> {
        self.raw.pWaitDstStageMask = wait_dst_stage_mask as *const PipelineStageFlags as *const _;
        self
    }

    pub fn command_buffers<'m, 'a>(mut self, command_buffers: &'a [CommandBufferHandle]) -> SubmitInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.commandBufferCount == 0 || self.raw.commandBufferCount == command_buffers.len() as _, 
            "count inconsistency found when specifying `SubmitInfo::command_buffers`.");
        self.raw.commandBufferCount = command_buffers.len() as _;
        self.raw.pCommandBuffers = command_buffers.as_ptr() as *const vks::VkCommandBuffer;
        self
    }

    pub fn signal_semaphores<'m, 'a>(mut self, signal_semaphores: &'a [SemaphoreHandle]) -> SubmitInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.signalSemaphoreCount == 0 || self.raw.signalSemaphoreCount == signal_semaphores.len() as _, 
            "count inconsistency found when specifying `SubmitInfo::signal_semaphores`.");
        self.raw.signalSemaphoreCount = signal_semaphores.len() as _;
        self.raw.pSignalSemaphores = signal_semaphores.as_ptr() as *const vks::VkSemaphore;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_wait_semaphores<'a>(&'a self) -> &'a [vks::VkSemaphore] {
        unsafe { slice::from_raw_parts(self.raw.pWaitSemaphores as *const _, self.raw.waitSemaphoreCount as usize) }
    }

    pub fn get_wait_dst_stage_mask<'a>(&'a self) -> &'a PipelineStageFlags {
        unsafe { &*(self.raw.pWaitDstStageMask as *const _) }
    }

    pub fn get_command_buffers<'a>(&'a self) -> &'a [vks::VkCommandBuffer] {
        unsafe { slice::from_raw_parts(self.raw.pCommandBuffers as *const _, self.raw.commandBufferCount as usize) }
    }

    pub fn get_signal_semaphores<'a>(&'a self) -> &'a [vks::VkSemaphore] {
        unsafe { slice::from_raw_parts(self.raw.pSignalSemaphores as *const _, self.raw.signalSemaphoreCount as usize) }
    }

    pub fn build(self) -> SubmitInfo<'b> {
        SubmitInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDisplayPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplayPropertiesKhr<'s> {
    raw: vks::VkDisplayPropertiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> DisplayPropertiesKhr<'s> {
    pub fn builder<'b>() -> DisplayPropertiesKhrBuilder<'b> {
        DisplayPropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplayPropertiesKHR) -> DisplayPropertiesKhr<'s> {
        DisplayPropertiesKhr { raw, _p: PhantomData }
    }

    pub fn display<'a>(&'a self) -> vks::VkDisplayKHR {
        self.raw.display
    }

    pub fn display_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(self.raw.displayName) }
    }

    pub fn physical_dimensions<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.physicalDimensions as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn physical_dimensions_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.physicalDimensions as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn physical_resolution<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.physicalResolution as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn physical_resolution_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.physicalResolution as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn supported_transforms<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.supportedTransforms)
            .expect("DisplayPropertiesKhr::supported_transforms: error converting flags")
    }

    pub fn plane_reorder_possible<'a>(&'a self) -> bool {
        self.raw.planeReorderPossible != 0
    }

    pub fn persistent_content<'a>(&'a self) -> bool {
        self.raw.persistentContent != 0
    }

    pub fn set_display<'m, H>(&mut self, display: H)
            where H: Handle<Target=DisplayKhrHandle> {
        self.raw.display = display.handle().0;
    }

    pub fn set_display_name<'m, 'a>(&mut self, display_name: &'a CStr)
            where 'a: 's {
        self.raw.displayName = display_name.as_ptr();
    }

    pub fn set_physical_dimensions<'m>(&mut self, physical_dimensions: Extent2d) {
        self.raw.physicalDimensions = physical_dimensions.raw;
    }

    pub fn set_physical_resolution<'m>(&mut self, physical_resolution: Extent2d) {
        self.raw.physicalResolution = physical_resolution.raw;
    }

    pub fn set_supported_transforms<'m>(&mut self, supported_transforms: SurfaceTransformFlagsKhr) {
        self.raw.supportedTransforms = supported_transforms.bits();
    }

    pub fn set_plane_reorder_possible<'m>(&mut self, plane_reorder_possible: bool) {
        self.raw.planeReorderPossible = plane_reorder_possible as u32;
    }

    pub fn set_persistent_content<'m>(&mut self, persistent_content: bool) {
        self.raw.persistentContent = persistent_content as u32;
    }

    pub fn as_raw(&self) -> &vks::VkDisplayPropertiesKHR {
        &self.raw
    }
}

impl<'s> From<DisplayPropertiesKhr<'s>> for vks::VkDisplayPropertiesKHR {
    fn from(f: DisplayPropertiesKhr<'s>) -> vks::VkDisplayPropertiesKHR {
        f.raw
    }
}


/// A builder for `VkDisplayPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplayPropertiesKhrBuilder<'b> {
    raw: vks::VkDisplayPropertiesKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DisplayPropertiesKhrBuilder<'b> {
    pub fn new() -> DisplayPropertiesKhrBuilder<'b> {
        DisplayPropertiesKhrBuilder {
            raw: vks::VkDisplayPropertiesKHR::default(),
            _p: PhantomData,
        }
    }

    pub fn display<'m, H>(mut self, display: H) -> DisplayPropertiesKhrBuilder<'b>
            where H: Handle<Target=DisplayKhrHandle> {
        self.raw.display = display.handle().0;
        self
    }

    pub fn display_name<'m, 'a>(mut self, display_name: &'a CStr) -> DisplayPropertiesKhrBuilder<'b>
            where 'a: 'b {
        self.raw.displayName = display_name.as_ptr();
        self
    }

    pub fn physical_dimensions<'m>(mut self, physical_dimensions: Extent2d) -> DisplayPropertiesKhrBuilder<'b> {
        self.raw.physicalDimensions = physical_dimensions.raw;
        self
    }

    pub fn physical_resolution<'m>(mut self, physical_resolution: Extent2d) -> DisplayPropertiesKhrBuilder<'b> {
        self.raw.physicalResolution = physical_resolution.raw;
        self
    }

    pub fn supported_transforms<'m>(mut self, supported_transforms: SurfaceTransformFlagsKhr) -> DisplayPropertiesKhrBuilder<'b> {
        self.raw.supportedTransforms = supported_transforms.bits();
        self
    }

    pub fn plane_reorder_possible<'m>(mut self, plane_reorder_possible: bool) -> DisplayPropertiesKhrBuilder<'b> {
        self.raw.planeReorderPossible = plane_reorder_possible as u32;
        self
    }

    pub fn persistent_content<'m>(mut self, persistent_content: bool) -> DisplayPropertiesKhrBuilder<'b> {
        self.raw.persistentContent = persistent_content as u32;
        self
    }

    pub fn get_display<'a>(&'a self) -> vks::VkDisplayKHR {
        self.raw.display
    }

    pub fn get_display_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(self.raw.displayName) }
    }

    pub fn get_physical_dimensions<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.physicalDimensions as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn get_physical_dimensions_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.physicalDimensions as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn get_physical_resolution<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.physicalResolution as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn get_physical_resolution_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.physicalResolution as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn get_supported_transforms<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.supportedTransforms)
            .expect("DisplayPropertiesKhr::supported_transforms: error converting flags")
    }

    pub fn get_plane_reorder_possible<'a>(&'a self) -> bool {
        self.raw.planeReorderPossible != 0
    }

    pub fn get_persistent_content<'a>(&'a self) -> bool {
        self.raw.persistentContent != 0
    }

    pub fn build(self) -> DisplayPropertiesKhr<'b> {
        DisplayPropertiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDisplayPlanePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplayPlanePropertiesKhr {
    raw: vks::VkDisplayPlanePropertiesKHR,
}

impl DisplayPlanePropertiesKhr {
    pub fn builder() -> DisplayPlanePropertiesKhrBuilder {
        DisplayPlanePropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplayPlanePropertiesKHR) -> DisplayPlanePropertiesKhr {
        DisplayPlanePropertiesKhr { raw, }
    }

    pub fn current_display<'a>(&'a self) -> vks::VkDisplayKHR {
        self.raw.currentDisplay
    }

    pub fn current_stack_index<'a>(&'a self) -> u32 {
        self.raw.currentStackIndex.into()
    }

    pub fn set_current_display<'m, H>(&mut self, current_display: H)
            where H: Handle<Target=DisplayKhrHandle> {
        self.raw.currentDisplay = current_display.handle().0;
    }

    pub fn set_current_stack_index<'m>(&mut self, current_stack_index: u32) {
        self.raw.currentStackIndex = current_stack_index.into();
    }

    pub fn as_raw(&self) -> &vks::VkDisplayPlanePropertiesKHR {
        &self.raw
    }
}

impl From<DisplayPlanePropertiesKhr> for vks::VkDisplayPlanePropertiesKHR {
    fn from(f: DisplayPlanePropertiesKhr) -> vks::VkDisplayPlanePropertiesKHR {
        f.raw
    }
}


/// A builder for `VkDisplayPlanePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplayPlanePropertiesKhrBuilder {
    raw: vks::VkDisplayPlanePropertiesKHR,
}

impl DisplayPlanePropertiesKhrBuilder {
    pub fn new() -> DisplayPlanePropertiesKhrBuilder {
        DisplayPlanePropertiesKhrBuilder {
            raw: vks::VkDisplayPlanePropertiesKHR::default(),
        }
    }

    pub fn current_display<'m, H>(mut self, current_display: H) -> DisplayPlanePropertiesKhrBuilder
            where H: Handle<Target=DisplayKhrHandle> {
        self.raw.currentDisplay = current_display.handle().0;
        self
    }

    pub fn current_stack_index<'m>(mut self, current_stack_index: u32) -> DisplayPlanePropertiesKhrBuilder {
        self.raw.currentStackIndex = current_stack_index.into();
        self
    }

    pub fn get_current_display<'a>(&'a self) -> vks::VkDisplayKHR {
        self.raw.currentDisplay
    }

    pub fn get_current_stack_index<'a>(&'a self) -> u32 {
        self.raw.currentStackIndex.into()
    }

    pub fn build(self) -> DisplayPlanePropertiesKhr {
        DisplayPlanePropertiesKhr {
            raw: self.raw,
        }
    }
}


/// A `VkDisplayModeParametersKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplayModeParametersKhr {
    raw: vks::VkDisplayModeParametersKHR,
}

impl DisplayModeParametersKhr {
    pub fn builder() -> DisplayModeParametersKhrBuilder {
        DisplayModeParametersKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplayModeParametersKHR) -> DisplayModeParametersKhr {
        DisplayModeParametersKhr { raw, }
    }

    pub fn visible_region<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.visibleRegion as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn visible_region_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.visibleRegion as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn refresh_rate<'a>(&'a self) -> u32 {
        self.raw.refreshRate.into()
    }

    pub fn set_visible_region<'m>(&mut self, visible_region: Extent2d) {
        self.raw.visibleRegion = visible_region.raw;
    }

    pub fn set_refresh_rate<'m>(&mut self, refresh_rate: u32) {
        self.raw.refreshRate = refresh_rate.into();
    }

    pub fn as_raw(&self) -> &vks::VkDisplayModeParametersKHR {
        &self.raw
    }
}

impl From<DisplayModeParametersKhr> for vks::VkDisplayModeParametersKHR {
    fn from(f: DisplayModeParametersKhr) -> vks::VkDisplayModeParametersKHR {
        f.raw
    }
}


/// A builder for `VkDisplayModeParametersKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplayModeParametersKhrBuilder {
    raw: vks::VkDisplayModeParametersKHR,
}

impl DisplayModeParametersKhrBuilder {
    pub fn new() -> DisplayModeParametersKhrBuilder {
        DisplayModeParametersKhrBuilder {
            raw: vks::VkDisplayModeParametersKHR::default(),
        }
    }

    pub fn visible_region<'m>(mut self, visible_region: Extent2d) -> DisplayModeParametersKhrBuilder {
        self.raw.visibleRegion = visible_region.raw;
        self
    }

    pub fn refresh_rate<'m>(mut self, refresh_rate: u32) -> DisplayModeParametersKhrBuilder {
        self.raw.refreshRate = refresh_rate.into();
        self
    }

    pub fn get_visible_region<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.visibleRegion as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn get_visible_region_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.visibleRegion as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn get_refresh_rate<'a>(&'a self) -> u32 {
        self.raw.refreshRate.into()
    }

    pub fn build(self) -> DisplayModeParametersKhr {
        DisplayModeParametersKhr {
            raw: self.raw,
        }
    }
}


/// A `VkDisplayModePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplayModePropertiesKhr {
    raw: vks::VkDisplayModePropertiesKHR,
}

impl DisplayModePropertiesKhr {
    pub fn builder() -> DisplayModePropertiesKhrBuilder {
        DisplayModePropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplayModePropertiesKHR) -> DisplayModePropertiesKhr {
        DisplayModePropertiesKhr { raw, }
    }

    pub fn display_mode<'a>(&'a self) -> vks::VkDisplayModeKHR {
        self.raw.displayMode
    }

    pub fn parameters<'a>(&'a self) -> &'a DisplayModeParametersKhr {
        unsafe { &*(&self.raw.parameters as *const vks::VkDisplayModeParametersKHR as *const DisplayModeParametersKhr) }
    }

    pub fn parameters_mut<'a>(&'a mut self) -> &'a mut DisplayModeParametersKhr {
        unsafe { &mut *(&mut self.raw.parameters as *mut  vks::VkDisplayModeParametersKHR as *mut DisplayModeParametersKhr) }
    }

    pub fn set_display_mode<'m, H>(&mut self, display_mode: H)
            where H: Handle<Target=DisplayModeKhrHandle> {
        self.raw.displayMode = display_mode.handle().0;
    }

    pub fn set_parameters<'m>(&mut self, parameters: DisplayModeParametersKhr) {
        self.raw.parameters = parameters.raw;
    }

    pub fn as_raw(&self) -> &vks::VkDisplayModePropertiesKHR {
        &self.raw
    }
}

impl From<DisplayModePropertiesKhr> for vks::VkDisplayModePropertiesKHR {
    fn from(f: DisplayModePropertiesKhr) -> vks::VkDisplayModePropertiesKHR {
        f.raw
    }
}


/// A builder for `VkDisplayModePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplayModePropertiesKhrBuilder {
    raw: vks::VkDisplayModePropertiesKHR,
}

impl DisplayModePropertiesKhrBuilder {
    pub fn new() -> DisplayModePropertiesKhrBuilder {
        DisplayModePropertiesKhrBuilder {
            raw: vks::VkDisplayModePropertiesKHR::default(),
        }
    }

    pub fn display_mode<'m, H>(mut self, display_mode: H) -> DisplayModePropertiesKhrBuilder
            where H: Handle<Target=DisplayModeKhrHandle> {
        self.raw.displayMode = display_mode.handle().0;
        self
    }

    pub fn parameters<'m>(mut self, parameters: DisplayModeParametersKhr) -> DisplayModePropertiesKhrBuilder {
        self.raw.parameters = parameters.raw;
        self
    }

    pub fn get_display_mode<'a>(&'a self) -> vks::VkDisplayModeKHR {
        self.raw.displayMode
    }

    pub fn get_parameters<'a>(&'a self) -> &'a DisplayModeParametersKhr {
        unsafe { &*(&self.raw.parameters as *const vks::VkDisplayModeParametersKHR as *const DisplayModeParametersKhr) }
    }

    pub fn get_parameters_mut<'a>(&'a mut self) -> &'a mut DisplayModeParametersKhr {
        unsafe { &mut *(&mut self.raw.parameters as *mut  vks::VkDisplayModeParametersKHR as *mut DisplayModeParametersKhr) }
    }

    pub fn build(self) -> DisplayModePropertiesKhr {
        DisplayModePropertiesKhr {
            raw: self.raw,
        }
    }
}


/// A `VkDisplayModeCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplayModeCreateInfoKhr<'s> {
    raw: vks::VkDisplayModeCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> DisplayModeCreateInfoKhr<'s> {
    pub fn builder<'b>() -> DisplayModeCreateInfoKhrBuilder<'b> {
        DisplayModeCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplayModeCreateInfoKHR) -> DisplayModeCreateInfoKhr<'s> {
        DisplayModeCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> DisplayModeCreateFlagsKhr {
        DisplayModeCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("DisplayModeCreateInfoKhr::flags: error converting flags")
    }

    pub fn parameters<'a>(&'a self) -> &'a DisplayModeParametersKhr {
        unsafe { &*(&self.raw.parameters as *const vks::VkDisplayModeParametersKHR as *const DisplayModeParametersKhr) }
    }

    pub fn parameters_mut<'a>(&'a mut self) -> &'a mut DisplayModeParametersKhr {
        unsafe { &mut *(&mut self.raw.parameters as *mut  vks::VkDisplayModeParametersKHR as *mut DisplayModeParametersKhr) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: DisplayModeCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub fn set_parameters<'m>(&mut self, parameters: DisplayModeParametersKhr) {
        self.raw.parameters = parameters.raw;
    }

    pub fn as_raw(&self) -> &vks::VkDisplayModeCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<DisplayModeCreateInfoKhr<'s>> for vks::VkDisplayModeCreateInfoKHR {
    fn from(f: DisplayModeCreateInfoKhr<'s>) -> vks::VkDisplayModeCreateInfoKHR {
        f.raw
    }
}


/// A builder for `VkDisplayModeCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplayModeCreateInfoKhrBuilder<'b> {
    raw: vks::VkDisplayModeCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DisplayModeCreateInfoKhrBuilder<'b> {
    pub fn new() -> DisplayModeCreateInfoKhrBuilder<'b> {
        DisplayModeCreateInfoKhrBuilder {
            raw: vks::VkDisplayModeCreateInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DisplayModeCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: DisplayModeCreateFlagsKhr) -> DisplayModeCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn parameters<'m>(mut self, parameters: DisplayModeParametersKhr) -> DisplayModeCreateInfoKhrBuilder<'b> {
        self.raw.parameters = parameters.raw;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> DisplayModeCreateFlagsKhr {
        DisplayModeCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("DisplayModeCreateInfoKhr::flags: error converting flags")
    }

    pub fn get_parameters<'a>(&'a self) -> &'a DisplayModeParametersKhr {
        unsafe { &*(&self.raw.parameters as *const vks::VkDisplayModeParametersKHR as *const DisplayModeParametersKhr) }
    }

    pub fn get_parameters_mut<'a>(&'a mut self) -> &'a mut DisplayModeParametersKhr {
        unsafe { &mut *(&mut self.raw.parameters as *mut  vks::VkDisplayModeParametersKHR as *mut DisplayModeParametersKhr) }
    }

    pub fn build(self) -> DisplayModeCreateInfoKhr<'b> {
        DisplayModeCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDisplayPlaneCapabilitiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplayPlaneCapabilitiesKhr {
    raw: vks::VkDisplayPlaneCapabilitiesKHR,
}

impl DisplayPlaneCapabilitiesKhr {
    pub fn builder() -> DisplayPlaneCapabilitiesKhrBuilder {
        DisplayPlaneCapabilitiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplayPlaneCapabilitiesKHR) -> DisplayPlaneCapabilitiesKhr {
        DisplayPlaneCapabilitiesKhr { raw, }
    }

    pub fn supported_alpha<'a>(&'a self) -> DisplayPlaneAlphaFlagsKhr {
        DisplayPlaneAlphaFlagsKhr::from_bits(self.raw.supportedAlpha)
            .expect("DisplayPlaneCapabilitiesKhr::supported_alpha: error converting flags")
    }

    pub fn min_src_position<'a>(&'a self) -> &'a Offset2d {
        unsafe { &*(&self.raw.minSrcPosition as *const vks::VkOffset2D as *const Offset2d) }
    }

    pub fn min_src_position_mut<'a>(&'a mut self) -> &'a mut Offset2d {
        unsafe { &mut *(&mut self.raw.minSrcPosition as *mut  vks::VkOffset2D as *mut Offset2d) }
    }

    pub fn max_src_position<'a>(&'a self) -> &'a Offset2d {
        unsafe { &*(&self.raw.maxSrcPosition as *const vks::VkOffset2D as *const Offset2d) }
    }

    pub fn max_src_position_mut<'a>(&'a mut self) -> &'a mut Offset2d {
        unsafe { &mut *(&mut self.raw.maxSrcPosition as *mut  vks::VkOffset2D as *mut Offset2d) }
    }

    pub fn min_src_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.minSrcExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn min_src_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.minSrcExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn max_src_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.maxSrcExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn max_src_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.maxSrcExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn min_dst_position<'a>(&'a self) -> &'a Offset2d {
        unsafe { &*(&self.raw.minDstPosition as *const vks::VkOffset2D as *const Offset2d) }
    }

    pub fn min_dst_position_mut<'a>(&'a mut self) -> &'a mut Offset2d {
        unsafe { &mut *(&mut self.raw.minDstPosition as *mut  vks::VkOffset2D as *mut Offset2d) }
    }

    pub fn max_dst_position<'a>(&'a self) -> &'a Offset2d {
        unsafe { &*(&self.raw.maxDstPosition as *const vks::VkOffset2D as *const Offset2d) }
    }

    pub fn max_dst_position_mut<'a>(&'a mut self) -> &'a mut Offset2d {
        unsafe { &mut *(&mut self.raw.maxDstPosition as *mut  vks::VkOffset2D as *mut Offset2d) }
    }

    pub fn min_dst_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.minDstExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn min_dst_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.minDstExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn max_dst_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.maxDstExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn max_dst_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.maxDstExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn set_supported_alpha<'m>(&mut self, supported_alpha: DisplayPlaneAlphaFlagsKhr) {
        self.raw.supportedAlpha = supported_alpha.bits();
    }

    pub fn set_min_src_position<'m>(&mut self, min_src_position: Offset2d) {
        self.raw.minSrcPosition = min_src_position.raw;
    }

    pub fn set_max_src_position<'m>(&mut self, max_src_position: Offset2d) {
        self.raw.maxSrcPosition = max_src_position.raw;
    }

    pub fn set_min_src_extent<'m>(&mut self, min_src_extent: Extent2d) {
        self.raw.minSrcExtent = min_src_extent.raw;
    }

    pub fn set_max_src_extent<'m>(&mut self, max_src_extent: Extent2d) {
        self.raw.maxSrcExtent = max_src_extent.raw;
    }

    pub fn set_min_dst_position<'m>(&mut self, min_dst_position: Offset2d) {
        self.raw.minDstPosition = min_dst_position.raw;
    }

    pub fn set_max_dst_position<'m>(&mut self, max_dst_position: Offset2d) {
        self.raw.maxDstPosition = max_dst_position.raw;
    }

    pub fn set_min_dst_extent<'m>(&mut self, min_dst_extent: Extent2d) {
        self.raw.minDstExtent = min_dst_extent.raw;
    }

    pub fn set_max_dst_extent<'m>(&mut self, max_dst_extent: Extent2d) {
        self.raw.maxDstExtent = max_dst_extent.raw;
    }

    pub fn as_raw(&self) -> &vks::VkDisplayPlaneCapabilitiesKHR {
        &self.raw
    }
}

impl From<DisplayPlaneCapabilitiesKhr> for vks::VkDisplayPlaneCapabilitiesKHR {
    fn from(f: DisplayPlaneCapabilitiesKhr) -> vks::VkDisplayPlaneCapabilitiesKHR {
        f.raw
    }
}


/// A builder for `VkDisplayPlaneCapabilitiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplayPlaneCapabilitiesKhrBuilder {
    raw: vks::VkDisplayPlaneCapabilitiesKHR,
}

impl DisplayPlaneCapabilitiesKhrBuilder {
    pub fn new() -> DisplayPlaneCapabilitiesKhrBuilder {
        DisplayPlaneCapabilitiesKhrBuilder {
            raw: vks::VkDisplayPlaneCapabilitiesKHR::default(),
        }
    }

    pub fn supported_alpha<'m>(mut self, supported_alpha: DisplayPlaneAlphaFlagsKhr) -> DisplayPlaneCapabilitiesKhrBuilder {
        self.raw.supportedAlpha = supported_alpha.bits();
        self
    }

    pub fn min_src_position<'m>(mut self, min_src_position: Offset2d) -> DisplayPlaneCapabilitiesKhrBuilder {
        self.raw.minSrcPosition = min_src_position.raw;
        self
    }

    pub fn max_src_position<'m>(mut self, max_src_position: Offset2d) -> DisplayPlaneCapabilitiesKhrBuilder {
        self.raw.maxSrcPosition = max_src_position.raw;
        self
    }

    pub fn min_src_extent<'m>(mut self, min_src_extent: Extent2d) -> DisplayPlaneCapabilitiesKhrBuilder {
        self.raw.minSrcExtent = min_src_extent.raw;
        self
    }

    pub fn max_src_extent<'m>(mut self, max_src_extent: Extent2d) -> DisplayPlaneCapabilitiesKhrBuilder {
        self.raw.maxSrcExtent = max_src_extent.raw;
        self
    }

    pub fn min_dst_position<'m>(mut self, min_dst_position: Offset2d) -> DisplayPlaneCapabilitiesKhrBuilder {
        self.raw.minDstPosition = min_dst_position.raw;
        self
    }

    pub fn max_dst_position<'m>(mut self, max_dst_position: Offset2d) -> DisplayPlaneCapabilitiesKhrBuilder {
        self.raw.maxDstPosition = max_dst_position.raw;
        self
    }

    pub fn min_dst_extent<'m>(mut self, min_dst_extent: Extent2d) -> DisplayPlaneCapabilitiesKhrBuilder {
        self.raw.minDstExtent = min_dst_extent.raw;
        self
    }

    pub fn max_dst_extent<'m>(mut self, max_dst_extent: Extent2d) -> DisplayPlaneCapabilitiesKhrBuilder {
        self.raw.maxDstExtent = max_dst_extent.raw;
        self
    }

    pub fn get_supported_alpha<'a>(&'a self) -> DisplayPlaneAlphaFlagsKhr {
        DisplayPlaneAlphaFlagsKhr::from_bits(self.raw.supportedAlpha)
            .expect("DisplayPlaneCapabilitiesKhr::supported_alpha: error converting flags")
    }

    pub fn get_min_src_position<'a>(&'a self) -> &'a Offset2d {
        unsafe { &*(&self.raw.minSrcPosition as *const vks::VkOffset2D as *const Offset2d) }
    }

    pub fn get_min_src_position_mut<'a>(&'a mut self) -> &'a mut Offset2d {
        unsafe { &mut *(&mut self.raw.minSrcPosition as *mut  vks::VkOffset2D as *mut Offset2d) }
    }

    pub fn get_max_src_position<'a>(&'a self) -> &'a Offset2d {
        unsafe { &*(&self.raw.maxSrcPosition as *const vks::VkOffset2D as *const Offset2d) }
    }

    pub fn get_max_src_position_mut<'a>(&'a mut self) -> &'a mut Offset2d {
        unsafe { &mut *(&mut self.raw.maxSrcPosition as *mut  vks::VkOffset2D as *mut Offset2d) }
    }

    pub fn get_min_src_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.minSrcExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn get_min_src_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.minSrcExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn get_max_src_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.maxSrcExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn get_max_src_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.maxSrcExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn get_min_dst_position<'a>(&'a self) -> &'a Offset2d {
        unsafe { &*(&self.raw.minDstPosition as *const vks::VkOffset2D as *const Offset2d) }
    }

    pub fn get_min_dst_position_mut<'a>(&'a mut self) -> &'a mut Offset2d {
        unsafe { &mut *(&mut self.raw.minDstPosition as *mut  vks::VkOffset2D as *mut Offset2d) }
    }

    pub fn get_max_dst_position<'a>(&'a self) -> &'a Offset2d {
        unsafe { &*(&self.raw.maxDstPosition as *const vks::VkOffset2D as *const Offset2d) }
    }

    pub fn get_max_dst_position_mut<'a>(&'a mut self) -> &'a mut Offset2d {
        unsafe { &mut *(&mut self.raw.maxDstPosition as *mut  vks::VkOffset2D as *mut Offset2d) }
    }

    pub fn get_min_dst_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.minDstExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn get_min_dst_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.minDstExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn get_max_dst_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.maxDstExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn get_max_dst_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.maxDstExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn build(self) -> DisplayPlaneCapabilitiesKhr {
        DisplayPlaneCapabilitiesKhr {
            raw: self.raw,
        }
    }
}


/// A `VkDisplaySurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplaySurfaceCreateInfoKhr<'s> {
    raw: vks::VkDisplaySurfaceCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> DisplaySurfaceCreateInfoKhr<'s> {
    pub fn builder<'b>() -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        DisplaySurfaceCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplaySurfaceCreateInfoKHR) -> DisplaySurfaceCreateInfoKhr<'s> {
        DisplaySurfaceCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> DisplaySurfaceCreateFlagsKhr {
        DisplaySurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("DisplaySurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn display_mode<'a>(&'a self) -> vks::VkDisplayModeKHR {
        self.raw.displayMode
    }

    pub fn plane_index<'a>(&'a self) -> u32 {
        self.raw.planeIndex.into()
    }

    pub fn plane_stack_index<'a>(&'a self) -> u32 {
        self.raw.planeStackIndex.into()
    }

    pub fn transform<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.transform)
            .expect("DisplaySurfaceCreateInfoKhr::transform: error converting flags")
    }

    pub fn global_alpha<'a>(&'a self) -> f32 {
        self.raw.globalAlpha.into()
    }

    pub fn alpha_mode<'a>(&'a self) -> DisplayPlaneAlphaFlagsKhr {
        DisplayPlaneAlphaFlagsKhr::from_bits(self.raw.alphaMode)
            .expect("DisplaySurfaceCreateInfoKhr::alpha_mode: error converting flags")
    }

    pub fn image_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.imageExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn image_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.imageExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: DisplaySurfaceCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub fn set_display_mode<'m, H>(&mut self, display_mode: H)
            where H: Handle<Target=DisplayModeKhrHandle> {
        self.raw.displayMode = display_mode.handle().0;
    }

    pub fn set_plane_index<'m>(&mut self, plane_index: u32) {
        self.raw.planeIndex = plane_index.into();
    }

    pub fn set_plane_stack_index<'m>(&mut self, plane_stack_index: u32) {
        self.raw.planeStackIndex = plane_stack_index.into();
    }

    pub fn set_transform<'m>(&mut self, transform: SurfaceTransformFlagsKhr) {
        self.raw.transform = transform.bits();
    }

    pub fn set_global_alpha<'m>(&mut self, global_alpha: f32) {
        self.raw.globalAlpha = global_alpha.into();
    }

    pub fn set_alpha_mode<'m>(&mut self, alpha_mode: DisplayPlaneAlphaFlagsKhr) {
        self.raw.alphaMode = alpha_mode.bits();
    }

    pub fn set_image_extent<'m>(&mut self, image_extent: Extent2d) {
        self.raw.imageExtent = image_extent.raw;
    }

    pub fn as_raw(&self) -> &vks::VkDisplaySurfaceCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<DisplaySurfaceCreateInfoKhr<'s>> for vks::VkDisplaySurfaceCreateInfoKHR {
    fn from(f: DisplaySurfaceCreateInfoKhr<'s>) -> vks::VkDisplaySurfaceCreateInfoKHR {
        f.raw
    }
}


/// A builder for `VkDisplaySurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplaySurfaceCreateInfoKhrBuilder<'b> {
    raw: vks::VkDisplaySurfaceCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DisplaySurfaceCreateInfoKhrBuilder<'b> {
    pub fn new() -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        DisplaySurfaceCreateInfoKhrBuilder {
            raw: vks::VkDisplaySurfaceCreateInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: DisplaySurfaceCreateFlagsKhr) -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn display_mode<'m, H>(mut self, display_mode: H) -> DisplaySurfaceCreateInfoKhrBuilder<'b>
            where H: Handle<Target=DisplayModeKhrHandle> {
        self.raw.displayMode = display_mode.handle().0;
        self
    }

    pub fn plane_index<'m>(mut self, plane_index: u32) -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        self.raw.planeIndex = plane_index.into();
        self
    }

    pub fn plane_stack_index<'m>(mut self, plane_stack_index: u32) -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        self.raw.planeStackIndex = plane_stack_index.into();
        self
    }

    pub fn transform<'m>(mut self, transform: SurfaceTransformFlagsKhr) -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        self.raw.transform = transform.bits();
        self
    }

    pub fn global_alpha<'m>(mut self, global_alpha: f32) -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        self.raw.globalAlpha = global_alpha.into();
        self
    }

    pub fn alpha_mode<'m>(mut self, alpha_mode: DisplayPlaneAlphaFlagsKhr) -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        self.raw.alphaMode = alpha_mode.bits();
        self
    }

    pub fn image_extent<'m>(mut self, image_extent: Extent2d) -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        self.raw.imageExtent = image_extent.raw;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> DisplaySurfaceCreateFlagsKhr {
        DisplaySurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("DisplaySurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn get_display_mode<'a>(&'a self) -> vks::VkDisplayModeKHR {
        self.raw.displayMode
    }

    pub fn get_plane_index<'a>(&'a self) -> u32 {
        self.raw.planeIndex.into()
    }

    pub fn get_plane_stack_index<'a>(&'a self) -> u32 {
        self.raw.planeStackIndex.into()
    }

    pub fn get_transform<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.transform)
            .expect("DisplaySurfaceCreateInfoKhr::transform: error converting flags")
    }

    pub fn get_global_alpha<'a>(&'a self) -> f32 {
        self.raw.globalAlpha.into()
    }

    pub fn get_alpha_mode<'a>(&'a self) -> DisplayPlaneAlphaFlagsKhr {
        DisplayPlaneAlphaFlagsKhr::from_bits(self.raw.alphaMode)
            .expect("DisplaySurfaceCreateInfoKhr::alpha_mode: error converting flags")
    }

    pub fn get_image_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.imageExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn get_image_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.imageExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn build(self) -> DisplaySurfaceCreateInfoKhr<'b> {
        DisplaySurfaceCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDisplayPresentInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplayPresentInfoKhr<'s> {
    raw: vks::VkDisplayPresentInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> DisplayPresentInfoKhr<'s> {
    pub fn builder<'b>() -> DisplayPresentInfoKhrBuilder<'b> {
        DisplayPresentInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplayPresentInfoKHR) -> DisplayPresentInfoKhr<'s> {
        DisplayPresentInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn src_rect<'a>(&'a self) -> &'a Rect2d {
        unsafe { &*(&self.raw.srcRect as *const vks::VkRect2D as *const Rect2d) }
    }

    pub fn src_rect_mut<'a>(&'a mut self) -> &'a mut Rect2d {
        unsafe { &mut *(&mut self.raw.srcRect as *mut  vks::VkRect2D as *mut Rect2d) }
    }

    pub fn dst_rect<'a>(&'a self) -> &'a Rect2d {
        unsafe { &*(&self.raw.dstRect as *const vks::VkRect2D as *const Rect2d) }
    }

    pub fn dst_rect_mut<'a>(&'a mut self) -> &'a mut Rect2d {
        unsafe { &mut *(&mut self.raw.dstRect as *mut  vks::VkRect2D as *mut Rect2d) }
    }

    pub fn persistent<'a>(&'a self) -> bool {
        self.raw.persistent != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_src_rect<'m>(&mut self, src_rect: Rect2d) {
        self.raw.srcRect = src_rect.raw;
    }

    pub fn set_dst_rect<'m>(&mut self, dst_rect: Rect2d) {
        self.raw.dstRect = dst_rect.raw;
    }

    pub fn set_persistent<'m>(&mut self, persistent: bool) {
        self.raw.persistent = persistent as u32;
    }

    pub fn as_raw(&self) -> &vks::VkDisplayPresentInfoKHR {
        &self.raw
    }
}

impl<'s> From<DisplayPresentInfoKhr<'s>> for vks::VkDisplayPresentInfoKHR {
    fn from(f: DisplayPresentInfoKhr<'s>) -> vks::VkDisplayPresentInfoKHR {
        f.raw
    }
}


/// A builder for `VkDisplayPresentInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplayPresentInfoKhrBuilder<'b> {
    raw: vks::VkDisplayPresentInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DisplayPresentInfoKhrBuilder<'b> {
    pub fn new() -> DisplayPresentInfoKhrBuilder<'b> {
        DisplayPresentInfoKhrBuilder {
            raw: vks::VkDisplayPresentInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DisplayPresentInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn src_rect<'m>(mut self, src_rect: Rect2d) -> DisplayPresentInfoKhrBuilder<'b> {
        self.raw.srcRect = src_rect.raw;
        self
    }

    pub fn dst_rect<'m>(mut self, dst_rect: Rect2d) -> DisplayPresentInfoKhrBuilder<'b> {
        self.raw.dstRect = dst_rect.raw;
        self
    }

    pub fn persistent<'m>(mut self, persistent: bool) -> DisplayPresentInfoKhrBuilder<'b> {
        self.raw.persistent = persistent as u32;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_src_rect<'a>(&'a self) -> &'a Rect2d {
        unsafe { &*(&self.raw.srcRect as *const vks::VkRect2D as *const Rect2d) }
    }

    pub fn get_src_rect_mut<'a>(&'a mut self) -> &'a mut Rect2d {
        unsafe { &mut *(&mut self.raw.srcRect as *mut  vks::VkRect2D as *mut Rect2d) }
    }

    pub fn get_dst_rect<'a>(&'a self) -> &'a Rect2d {
        unsafe { &*(&self.raw.dstRect as *const vks::VkRect2D as *const Rect2d) }
    }

    pub fn get_dst_rect_mut<'a>(&'a mut self) -> &'a mut Rect2d {
        unsafe { &mut *(&mut self.raw.dstRect as *mut  vks::VkRect2D as *mut Rect2d) }
    }

    pub fn get_persistent<'a>(&'a self) -> bool {
        self.raw.persistent != 0
    }

    pub fn build(self) -> DisplayPresentInfoKhr<'b> {
        DisplayPresentInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSurfaceCapabilitiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SurfaceCapabilitiesKhr {
    raw: vks::VkSurfaceCapabilitiesKHR,
}

impl SurfaceCapabilitiesKhr {
    pub fn builder() -> SurfaceCapabilitiesKhrBuilder {
        SurfaceCapabilitiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSurfaceCapabilitiesKHR) -> SurfaceCapabilitiesKhr {
        SurfaceCapabilitiesKhr { raw, }
    }

    pub fn min_image_count<'a>(&'a self) -> u32 {
        self.raw.minImageCount.into()
    }

    pub fn max_image_count<'a>(&'a self) -> u32 {
        self.raw.maxImageCount.into()
    }

    pub fn current_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.currentExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn current_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.currentExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn min_image_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.minImageExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn min_image_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.minImageExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn max_image_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.maxImageExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn max_image_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.maxImageExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn max_image_array_layers<'a>(&'a self) -> u32 {
        self.raw.maxImageArrayLayers.into()
    }

    pub fn supported_transforms<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.supportedTransforms)
            .expect("SurfaceCapabilitiesKhr::supported_transforms: error converting flags")
    }

    pub fn current_transform<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.currentTransform)
            .expect("SurfaceCapabilitiesKhr::current_transform: error converting flags")
    }

    pub fn supported_composite_alpha<'a>(&'a self) -> CompositeAlphaFlagsKhr {
        CompositeAlphaFlagsKhr::from_bits(self.raw.supportedCompositeAlpha)
            .expect("SurfaceCapabilitiesKhr::supported_composite_alpha: error converting flags")
    }

    pub fn supported_usage_flags<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.supportedUsageFlags)
            .expect("SurfaceCapabilitiesKhr::supported_usage_flags: error converting flags")
    }

    pub fn set_min_image_count<'m>(&mut self, min_image_count: u32) {
        self.raw.minImageCount = min_image_count.into();
    }

    pub fn set_max_image_count<'m>(&mut self, max_image_count: u32) {
        self.raw.maxImageCount = max_image_count.into();
    }

    pub fn set_current_extent<'m>(&mut self, current_extent: Extent2d) {
        self.raw.currentExtent = current_extent.raw;
    }

    pub fn set_min_image_extent<'m>(&mut self, min_image_extent: Extent2d) {
        self.raw.minImageExtent = min_image_extent.raw;
    }

    pub fn set_max_image_extent<'m>(&mut self, max_image_extent: Extent2d) {
        self.raw.maxImageExtent = max_image_extent.raw;
    }

    pub fn set_max_image_array_layers<'m>(&mut self, max_image_array_layers: u32) {
        self.raw.maxImageArrayLayers = max_image_array_layers.into();
    }

    pub fn set_supported_transforms<'m>(&mut self, supported_transforms: SurfaceTransformFlagsKhr) {
        self.raw.supportedTransforms = supported_transforms.bits();
    }

    pub fn set_current_transform<'m>(&mut self, current_transform: SurfaceTransformFlagsKhr) {
        self.raw.currentTransform = current_transform.bits();
    }

    pub fn set_supported_composite_alpha<'m>(&mut self, supported_composite_alpha: CompositeAlphaFlagsKhr) {
        self.raw.supportedCompositeAlpha = supported_composite_alpha.bits();
    }

    pub fn set_supported_usage_flags<'m>(&mut self, supported_usage_flags: ImageUsageFlags) {
        self.raw.supportedUsageFlags = supported_usage_flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSurfaceCapabilitiesKHR {
        &self.raw
    }
}

impl From<SurfaceCapabilitiesKhr> for vks::VkSurfaceCapabilitiesKHR {
    fn from(f: SurfaceCapabilitiesKhr) -> vks::VkSurfaceCapabilitiesKHR {
        f.raw
    }
}


/// A builder for `VkSurfaceCapabilitiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SurfaceCapabilitiesKhrBuilder {
    raw: vks::VkSurfaceCapabilitiesKHR,
}

impl SurfaceCapabilitiesKhrBuilder {
    pub fn new() -> SurfaceCapabilitiesKhrBuilder {
        SurfaceCapabilitiesKhrBuilder {
            raw: vks::VkSurfaceCapabilitiesKHR::default(),
        }
    }

    pub fn min_image_count<'m>(mut self, min_image_count: u32) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.minImageCount = min_image_count.into();
        self
    }

    pub fn max_image_count<'m>(mut self, max_image_count: u32) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.maxImageCount = max_image_count.into();
        self
    }

    pub fn current_extent<'m>(mut self, current_extent: Extent2d) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.currentExtent = current_extent.raw;
        self
    }

    pub fn min_image_extent<'m>(mut self, min_image_extent: Extent2d) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.minImageExtent = min_image_extent.raw;
        self
    }

    pub fn max_image_extent<'m>(mut self, max_image_extent: Extent2d) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.maxImageExtent = max_image_extent.raw;
        self
    }

    pub fn max_image_array_layers<'m>(mut self, max_image_array_layers: u32) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.maxImageArrayLayers = max_image_array_layers.into();
        self
    }

    pub fn supported_transforms<'m>(mut self, supported_transforms: SurfaceTransformFlagsKhr) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.supportedTransforms = supported_transforms.bits();
        self
    }

    pub fn current_transform<'m>(mut self, current_transform: SurfaceTransformFlagsKhr) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.currentTransform = current_transform.bits();
        self
    }

    pub fn supported_composite_alpha<'m>(mut self, supported_composite_alpha: CompositeAlphaFlagsKhr) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.supportedCompositeAlpha = supported_composite_alpha.bits();
        self
    }

    pub fn supported_usage_flags<'m>(mut self, supported_usage_flags: ImageUsageFlags) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.supportedUsageFlags = supported_usage_flags.bits();
        self
    }

    pub fn get_min_image_count<'a>(&'a self) -> u32 {
        self.raw.minImageCount.into()
    }

    pub fn get_max_image_count<'a>(&'a self) -> u32 {
        self.raw.maxImageCount.into()
    }

    pub fn get_current_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.currentExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn get_current_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.currentExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn get_min_image_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.minImageExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn get_min_image_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.minImageExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn get_max_image_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.maxImageExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn get_max_image_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.maxImageExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn get_max_image_array_layers<'a>(&'a self) -> u32 {
        self.raw.maxImageArrayLayers.into()
    }

    pub fn get_supported_transforms<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.supportedTransforms)
            .expect("SurfaceCapabilitiesKhr::supported_transforms: error converting flags")
    }

    pub fn get_current_transform<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.currentTransform)
            .expect("SurfaceCapabilitiesKhr::current_transform: error converting flags")
    }

    pub fn get_supported_composite_alpha<'a>(&'a self) -> CompositeAlphaFlagsKhr {
        CompositeAlphaFlagsKhr::from_bits(self.raw.supportedCompositeAlpha)
            .expect("SurfaceCapabilitiesKhr::supported_composite_alpha: error converting flags")
    }

    pub fn get_supported_usage_flags<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.supportedUsageFlags)
            .expect("SurfaceCapabilitiesKhr::supported_usage_flags: error converting flags")
    }

    pub fn build(self) -> SurfaceCapabilitiesKhr {
        SurfaceCapabilitiesKhr {
            raw: self.raw,
        }
    }
}


/// A `VkAndroidSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct AndroidSurfaceCreateInfoKhr<'s> {
    raw: vks::VkAndroidSurfaceCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> AndroidSurfaceCreateInfoKhr<'s> {
    pub fn builder<'b>() -> AndroidSurfaceCreateInfoKhrBuilder<'b> {
        AndroidSurfaceCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkAndroidSurfaceCreateInfoKHR) -> AndroidSurfaceCreateInfoKhr<'s> {
        AndroidSurfaceCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> AndroidSurfaceCreateFlagsKhr {
        AndroidSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("AndroidSurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn window<'a>(&'a self) -> *mut ANativeWindow {
        self.raw.window
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: AndroidSurfaceCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub unsafe fn set_window<'m>(&mut self, window: *mut ANativeWindow) {
        self.raw.window = window;
    }

    pub fn as_raw(&self) -> &vks::VkAndroidSurfaceCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<AndroidSurfaceCreateInfoKhr<'s>> for vks::VkAndroidSurfaceCreateInfoKHR {
    fn from(f: AndroidSurfaceCreateInfoKhr<'s>) -> vks::VkAndroidSurfaceCreateInfoKHR {
        f.raw
    }
}


/// A builder for `VkAndroidSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct AndroidSurfaceCreateInfoKhrBuilder<'b> {
    raw: vks::VkAndroidSurfaceCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> AndroidSurfaceCreateInfoKhrBuilder<'b> {
    pub fn new() -> AndroidSurfaceCreateInfoKhrBuilder<'b> {
        AndroidSurfaceCreateInfoKhrBuilder {
            raw: vks::VkAndroidSurfaceCreateInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> AndroidSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: AndroidSurfaceCreateFlagsKhr) -> AndroidSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub unsafe fn window<'m>(mut self, window: *mut ANativeWindow) -> AndroidSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.window = window;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> AndroidSurfaceCreateFlagsKhr {
        AndroidSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("AndroidSurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn get_window<'a>(&'a self) -> *mut ANativeWindow {
        self.raw.window
    }

    pub fn build(self) -> AndroidSurfaceCreateInfoKhr<'b> {
        AndroidSurfaceCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMirSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MirSurfaceCreateInfoKhr<'s> {
    raw: vks::VkMirSurfaceCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> MirSurfaceCreateInfoKhr<'s> {
    pub fn builder<'b>() -> MirSurfaceCreateInfoKhrBuilder<'b> {
        MirSurfaceCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMirSurfaceCreateInfoKHR) -> MirSurfaceCreateInfoKhr<'s> {
        MirSurfaceCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> MirSurfaceCreateFlagsKhr {
        MirSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("MirSurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn connection<'a>(&'a self) -> *mut MirConnection {
        self.raw.connection
    }

    pub fn mir_surface<'a>(&'a self) -> *mut MirSurface {
        self.raw.mirSurface
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: MirSurfaceCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub unsafe fn set_connection<'m>(&mut self, connection: *mut MirConnection) {
        self.raw.connection = connection;
    }

    pub unsafe fn set_mir_surface<'m>(&mut self, mir_surface: *mut MirSurface) {
        self.raw.mirSurface = mir_surface;
    }

    pub fn as_raw(&self) -> &vks::VkMirSurfaceCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<MirSurfaceCreateInfoKhr<'s>> for vks::VkMirSurfaceCreateInfoKHR {
    fn from(f: MirSurfaceCreateInfoKhr<'s>) -> vks::VkMirSurfaceCreateInfoKHR {
        f.raw
    }
}


/// A builder for `VkMirSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MirSurfaceCreateInfoKhrBuilder<'b> {
    raw: vks::VkMirSurfaceCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> MirSurfaceCreateInfoKhrBuilder<'b> {
    pub fn new() -> MirSurfaceCreateInfoKhrBuilder<'b> {
        MirSurfaceCreateInfoKhrBuilder {
            raw: vks::VkMirSurfaceCreateInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> MirSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: MirSurfaceCreateFlagsKhr) -> MirSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub unsafe fn connection<'m>(mut self, connection: *mut MirConnection) -> MirSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.connection = connection;
        self
    }

    pub unsafe fn mir_surface<'m>(mut self, mir_surface: *mut MirSurface) -> MirSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.mirSurface = mir_surface;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> MirSurfaceCreateFlagsKhr {
        MirSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("MirSurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn get_connection<'a>(&'a self) -> *mut MirConnection {
        self.raw.connection
    }

    pub fn get_mir_surface<'a>(&'a self) -> *mut MirSurface {
        self.raw.mirSurface
    }

    pub fn build(self) -> MirSurfaceCreateInfoKhr<'b> {
        MirSurfaceCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkViSurfaceCreateInfoNN`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ViSurfaceCreateInfoNn<'s> {
    raw: vks::VkViSurfaceCreateInfoNN,
    _p: PhantomData<&'s ()>,
}

impl<'s> ViSurfaceCreateInfoNn<'s> {
    pub fn builder<'b>() -> ViSurfaceCreateInfoNnBuilder<'b> {
        ViSurfaceCreateInfoNnBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkViSurfaceCreateInfoNN) -> ViSurfaceCreateInfoNn<'s> {
        ViSurfaceCreateInfoNn { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> ViSurfaceCreateFlagsNn {
        ViSurfaceCreateFlagsNn::from_bits(self.raw.flags)
            .expect("ViSurfaceCreateInfoNn::flags: error converting flags")
    }

    pub fn window<'a>(&'a self) -> *mut c_void {
        self.raw.window
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: ViSurfaceCreateFlagsNn) {
        self.raw.flags = flags.bits();
    }

    pub unsafe fn set_window<'m>(&mut self, window: *mut c_void) {
        self.raw.window = window;
    }

    pub fn as_raw(&self) -> &vks::VkViSurfaceCreateInfoNN {
        &self.raw
    }
}

impl<'s> From<ViSurfaceCreateInfoNn<'s>> for vks::VkViSurfaceCreateInfoNN {
    fn from(f: ViSurfaceCreateInfoNn<'s>) -> vks::VkViSurfaceCreateInfoNN {
        f.raw
    }
}


/// A builder for `VkViSurfaceCreateInfoNN`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ViSurfaceCreateInfoNnBuilder<'b> {
    raw: vks::VkViSurfaceCreateInfoNN,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ViSurfaceCreateInfoNnBuilder<'b> {
    pub fn new() -> ViSurfaceCreateInfoNnBuilder<'b> {
        ViSurfaceCreateInfoNnBuilder {
            raw: vks::VkViSurfaceCreateInfoNN::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ViSurfaceCreateInfoNnBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: ViSurfaceCreateFlagsNn) -> ViSurfaceCreateInfoNnBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub unsafe fn window<'m>(mut self, window: *mut c_void) -> ViSurfaceCreateInfoNnBuilder<'b> {
        self.raw.window = window;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> ViSurfaceCreateFlagsNn {
        ViSurfaceCreateFlagsNn::from_bits(self.raw.flags)
            .expect("ViSurfaceCreateInfoNn::flags: error converting flags")
    }

    pub fn get_window<'a>(&'a self) -> *mut c_void {
        self.raw.window
    }

    pub fn build(self) -> ViSurfaceCreateInfoNn<'b> {
        ViSurfaceCreateInfoNn {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkWaylandSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct WaylandSurfaceCreateInfoKhr<'s> {
    raw: vks::VkWaylandSurfaceCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> WaylandSurfaceCreateInfoKhr<'s> {
    pub fn builder<'b>() -> WaylandSurfaceCreateInfoKhrBuilder<'b> {
        WaylandSurfaceCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkWaylandSurfaceCreateInfoKHR) -> WaylandSurfaceCreateInfoKhr<'s> {
        WaylandSurfaceCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> WaylandSurfaceCreateFlagsKhr {
        WaylandSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("WaylandSurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn display<'a>(&'a self) -> *mut wl_display {
        self.raw.display
    }

    pub fn surface<'a>(&'a self) -> *mut wl_surface {
        self.raw.surface
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: WaylandSurfaceCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub unsafe fn set_display<'m>(&mut self, display: *mut wl_display) {
        self.raw.display = display;
    }

    pub unsafe fn set_surface<'m>(&mut self, surface: *mut wl_surface) {
        self.raw.surface = surface;
    }

    pub fn as_raw(&self) -> &vks::VkWaylandSurfaceCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<WaylandSurfaceCreateInfoKhr<'s>> for vks::VkWaylandSurfaceCreateInfoKHR {
    fn from(f: WaylandSurfaceCreateInfoKhr<'s>) -> vks::VkWaylandSurfaceCreateInfoKHR {
        f.raw
    }
}


/// A builder for `VkWaylandSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct WaylandSurfaceCreateInfoKhrBuilder<'b> {
    raw: vks::VkWaylandSurfaceCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> WaylandSurfaceCreateInfoKhrBuilder<'b> {
    pub fn new() -> WaylandSurfaceCreateInfoKhrBuilder<'b> {
        WaylandSurfaceCreateInfoKhrBuilder {
            raw: vks::VkWaylandSurfaceCreateInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> WaylandSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: WaylandSurfaceCreateFlagsKhr) -> WaylandSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub unsafe fn display<'m>(mut self, display: *mut wl_display) -> WaylandSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.display = display;
        self
    }

    pub unsafe fn surface<'m>(mut self, surface: *mut wl_surface) -> WaylandSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.surface = surface;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> WaylandSurfaceCreateFlagsKhr {
        WaylandSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("WaylandSurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn get_display<'a>(&'a self) -> *mut wl_display {
        self.raw.display
    }

    pub fn get_surface<'a>(&'a self) -> *mut wl_surface {
        self.raw.surface
    }

    pub fn build(self) -> WaylandSurfaceCreateInfoKhr<'b> {
        WaylandSurfaceCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkWin32SurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct Win32SurfaceCreateInfoKhr<'s> {
    raw: vks::VkWin32SurfaceCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> Win32SurfaceCreateInfoKhr<'s> {
    pub fn builder<'b>() -> Win32SurfaceCreateInfoKhrBuilder<'b> {
        Win32SurfaceCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkWin32SurfaceCreateInfoKHR) -> Win32SurfaceCreateInfoKhr<'s> {
        Win32SurfaceCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> Win32SurfaceCreateFlagsKhr {
        Win32SurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("Win32SurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn hinstance<'a>(&'a self) -> HINSTANCE {
        self.raw.hinstance.into()
    }

    pub fn hwnd<'a>(&'a self) -> HWND {
        self.raw.hwnd.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: Win32SurfaceCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub fn set_hinstance<'m>(&mut self, hinstance: HINSTANCE) {
        self.raw.hinstance = hinstance.into();
    }

    pub fn set_hwnd<'m>(&mut self, hwnd: HWND) {
        self.raw.hwnd = hwnd.into();
    }

    pub fn as_raw(&self) -> &vks::VkWin32SurfaceCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<Win32SurfaceCreateInfoKhr<'s>> for vks::VkWin32SurfaceCreateInfoKHR {
    fn from(f: Win32SurfaceCreateInfoKhr<'s>) -> vks::VkWin32SurfaceCreateInfoKHR {
        f.raw
    }
}


/// A builder for `VkWin32SurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct Win32SurfaceCreateInfoKhrBuilder<'b> {
    raw: vks::VkWin32SurfaceCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> Win32SurfaceCreateInfoKhrBuilder<'b> {
    pub fn new() -> Win32SurfaceCreateInfoKhrBuilder<'b> {
        Win32SurfaceCreateInfoKhrBuilder {
            raw: vks::VkWin32SurfaceCreateInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> Win32SurfaceCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: Win32SurfaceCreateFlagsKhr) -> Win32SurfaceCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn hinstance<'m>(mut self, hinstance: HINSTANCE) -> Win32SurfaceCreateInfoKhrBuilder<'b> {
        self.raw.hinstance = hinstance.into();
        self
    }

    pub fn hwnd<'m>(mut self, hwnd: HWND) -> Win32SurfaceCreateInfoKhrBuilder<'b> {
        self.raw.hwnd = hwnd.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> Win32SurfaceCreateFlagsKhr {
        Win32SurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("Win32SurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn get_hinstance<'a>(&'a self) -> HINSTANCE {
        self.raw.hinstance.into()
    }

    pub fn get_hwnd<'a>(&'a self) -> HWND {
        self.raw.hwnd.into()
    }

    pub fn build(self) -> Win32SurfaceCreateInfoKhr<'b> {
        Win32SurfaceCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkXlibSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct XlibSurfaceCreateInfoKhr<'s> {
    raw: vks::VkXlibSurfaceCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> XlibSurfaceCreateInfoKhr<'s> {
    pub fn builder<'b>() -> XlibSurfaceCreateInfoKhrBuilder<'b> {
        XlibSurfaceCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkXlibSurfaceCreateInfoKHR) -> XlibSurfaceCreateInfoKhr<'s> {
        XlibSurfaceCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> XlibSurfaceCreateFlagsKhr {
        XlibSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("XlibSurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn dpy<'a>(&'a self) -> *mut Display {
        self.raw.dpy
    }

    pub fn window<'a>(&'a self) -> Window {
        self.raw.window.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: XlibSurfaceCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub unsafe fn set_dpy<'m>(&mut self, dpy: *mut Display) {
        self.raw.dpy = dpy;
    }

    pub unsafe fn set_window<'m>(&mut self, window: Window) {
        self.raw.window = window.into();
    }

    pub fn as_raw(&self) -> &vks::VkXlibSurfaceCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<XlibSurfaceCreateInfoKhr<'s>> for vks::VkXlibSurfaceCreateInfoKHR {
    fn from(f: XlibSurfaceCreateInfoKhr<'s>) -> vks::VkXlibSurfaceCreateInfoKHR {
        f.raw
    }
}


/// A builder for `VkXlibSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct XlibSurfaceCreateInfoKhrBuilder<'b> {
    raw: vks::VkXlibSurfaceCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> XlibSurfaceCreateInfoKhrBuilder<'b> {
    pub fn new() -> XlibSurfaceCreateInfoKhrBuilder<'b> {
        XlibSurfaceCreateInfoKhrBuilder {
            raw: vks::VkXlibSurfaceCreateInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> XlibSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: XlibSurfaceCreateFlagsKhr) -> XlibSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub unsafe fn dpy<'m>(mut self, dpy: *mut Display) -> XlibSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.dpy = dpy;
        self
    }

    pub unsafe fn window<'m>(mut self, window: Window) -> XlibSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.window = window.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> XlibSurfaceCreateFlagsKhr {
        XlibSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("XlibSurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn get_dpy<'a>(&'a self) -> *mut Display {
        self.raw.dpy
    }

    pub fn get_window<'a>(&'a self) -> Window {
        self.raw.window.into()
    }

    pub fn build(self) -> XlibSurfaceCreateInfoKhr<'b> {
        XlibSurfaceCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkXcbSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct XcbSurfaceCreateInfoKhr<'s> {
    raw: vks::VkXcbSurfaceCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> XcbSurfaceCreateInfoKhr<'s> {
    pub fn builder<'b>() -> XcbSurfaceCreateInfoKhrBuilder<'b> {
        XcbSurfaceCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkXcbSurfaceCreateInfoKHR) -> XcbSurfaceCreateInfoKhr<'s> {
        XcbSurfaceCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> XcbSurfaceCreateFlagsKhr {
        XcbSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("XcbSurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn connection<'a>(&'a self) -> *mut xcb_connection_t {
        self.raw.connection
    }

    pub fn window<'a>(&'a self) -> xcb_window_t {
        self.raw.window.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: XcbSurfaceCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub unsafe fn set_connection<'m>(&mut self, connection: *mut xcb_connection_t) {
        self.raw.connection = connection;
    }

    pub unsafe fn set_window<'m>(&mut self, window: xcb_window_t) {
        self.raw.window = window.into();
    }

    pub fn as_raw(&self) -> &vks::VkXcbSurfaceCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<XcbSurfaceCreateInfoKhr<'s>> for vks::VkXcbSurfaceCreateInfoKHR {
    fn from(f: XcbSurfaceCreateInfoKhr<'s>) -> vks::VkXcbSurfaceCreateInfoKHR {
        f.raw
    }
}


/// A builder for `VkXcbSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct XcbSurfaceCreateInfoKhrBuilder<'b> {
    raw: vks::VkXcbSurfaceCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> XcbSurfaceCreateInfoKhrBuilder<'b> {
    pub fn new() -> XcbSurfaceCreateInfoKhrBuilder<'b> {
        XcbSurfaceCreateInfoKhrBuilder {
            raw: vks::VkXcbSurfaceCreateInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> XcbSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: XcbSurfaceCreateFlagsKhr) -> XcbSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub unsafe fn connection<'m>(mut self, connection: *mut xcb_connection_t) -> XcbSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.connection = connection;
        self
    }

    pub unsafe fn window<'m>(mut self, window: xcb_window_t) -> XcbSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.window = window.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> XcbSurfaceCreateFlagsKhr {
        XcbSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("XcbSurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn get_connection<'a>(&'a self) -> *mut xcb_connection_t {
        self.raw.connection
    }

    pub fn get_window<'a>(&'a self) -> xcb_window_t {
        self.raw.window.into()
    }

    pub fn build(self) -> XcbSurfaceCreateInfoKhr<'b> {
        XcbSurfaceCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSurfaceFormatKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SurfaceFormatKhr {
    raw: vks::VkSurfaceFormatKHR,
}

impl SurfaceFormatKhr {
    pub fn builder() -> SurfaceFormatKhrBuilder {
        SurfaceFormatKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSurfaceFormatKHR) -> SurfaceFormatKhr {
        SurfaceFormatKhr { raw, }
    }

    pub fn format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn color_space<'a>(&'a self) -> ColorSpaceKhr {
        self.raw.colorSpace.into()
    }

    pub fn set_format<'m>(&mut self, format: Format) {
        self.raw.format = format.into();
    }

    pub fn set_color_space<'m>(&mut self, color_space: ColorSpaceKhr) {
        self.raw.colorSpace = color_space.into();
    }

    pub fn as_raw(&self) -> &vks::VkSurfaceFormatKHR {
        &self.raw
    }
}

impl From<SurfaceFormatKhr> for vks::VkSurfaceFormatKHR {
    fn from(f: SurfaceFormatKhr) -> vks::VkSurfaceFormatKHR {
        f.raw
    }
}


/// A builder for `VkSurfaceFormatKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SurfaceFormatKhrBuilder {
    raw: vks::VkSurfaceFormatKHR,
}

impl SurfaceFormatKhrBuilder {
    pub fn new() -> SurfaceFormatKhrBuilder {
        SurfaceFormatKhrBuilder {
            raw: vks::VkSurfaceFormatKHR::default(),
        }
    }

    pub fn format<'m>(mut self, format: Format) -> SurfaceFormatKhrBuilder {
        self.raw.format = format.into();
        self
    }

    pub fn color_space<'m>(mut self, color_space: ColorSpaceKhr) -> SurfaceFormatKhrBuilder {
        self.raw.colorSpace = color_space.into();
        self
    }

    pub fn get_format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn get_color_space<'a>(&'a self) -> ColorSpaceKhr {
        self.raw.colorSpace.into()
    }

    pub fn build(self) -> SurfaceFormatKhr {
        SurfaceFormatKhr {
            raw: self.raw,
        }
    }
}


/// A `VkSwapchainCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SwapchainCreateInfoKhr<'s> {
    raw: vks::VkSwapchainCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> SwapchainCreateInfoKhr<'s> {
    pub fn builder<'b>() -> SwapchainCreateInfoKhrBuilder<'b> {
        SwapchainCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSwapchainCreateInfoKHR) -> SwapchainCreateInfoKhr<'s> {
        SwapchainCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> SwapchainCreateFlagsKhr {
        SwapchainCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("SwapchainCreateInfoKhr::flags: error converting flags")
    }

    pub fn surface<'a>(&'a self) -> vks::VkSurfaceKHR {
        self.raw.surface
    }

    pub fn min_image_count<'a>(&'a self) -> u32 {
        self.raw.minImageCount.into()
    }

    pub fn image_format<'a>(&'a self) -> Format {
        self.raw.imageFormat.into()
    }

    pub fn image_color_space<'a>(&'a self) -> ColorSpaceKhr {
        self.raw.imageColorSpace.into()
    }

    pub fn image_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.imageExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn image_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.imageExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn image_array_layers<'a>(&'a self) -> u32 {
        self.raw.imageArrayLayers.into()
    }

    pub fn image_usage<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.imageUsage)
            .expect("SwapchainCreateInfoKhr::image_usage: error converting flags")
    }

    pub fn image_sharing_mode<'a>(&'a self) -> SharingMode {
        self.raw.imageSharingMode.into()
    }

    pub fn queue_family_indices<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pQueueFamilyIndices as *const _, self.raw.queueFamilyIndexCount as usize) }
    }

    pub fn pre_transform<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.preTransform)
            .expect("SwapchainCreateInfoKhr::pre_transform: error converting flags")
    }

    pub fn composite_alpha<'a>(&'a self) -> CompositeAlphaFlagsKhr {
        CompositeAlphaFlagsKhr::from_bits(self.raw.compositeAlpha)
            .expect("SwapchainCreateInfoKhr::composite_alpha: error converting flags")
    }

    pub fn present_mode<'a>(&'a self) -> PresentModeKhr {
        self.raw.presentMode.into()
    }

    pub fn clipped<'a>(&'a self) -> bool {
        self.raw.clipped != 0
    }

    pub fn old_swapchain<'a>(&'a self) -> vks::VkSwapchainKHR {
        self.raw.oldSwapchain
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: SwapchainCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub fn set_surface<'m, H>(&mut self, surface: H)
            where H: Handle<Target=SurfaceKhrHandle> {
        self.raw.surface = surface.handle().0;
    }

    pub fn set_min_image_count<'m>(&mut self, min_image_count: u32) {
        self.raw.minImageCount = min_image_count.into();
    }

    pub fn set_image_format<'m>(&mut self, image_format: Format) {
        self.raw.imageFormat = image_format.into();
    }

    pub fn set_image_color_space<'m>(&mut self, image_color_space: ColorSpaceKhr) {
        self.raw.imageColorSpace = image_color_space.into();
    }

    pub fn set_image_extent<'m>(&mut self, image_extent: Extent2d) {
        self.raw.imageExtent = image_extent.raw;
    }

    pub fn set_image_array_layers<'m>(&mut self, image_array_layers: u32) {
        self.raw.imageArrayLayers = image_array_layers.into();
    }

    pub fn set_image_usage<'m>(&mut self, image_usage: ImageUsageFlags) {
        self.raw.imageUsage = image_usage.bits();
    }

    pub fn set_image_sharing_mode<'m>(&mut self, image_sharing_mode: SharingMode) {
        self.raw.imageSharingMode = image_sharing_mode.into();
    }

    pub fn set_queue_family_indices<'m, 'a>(&mut self, queue_family_indices: &'a [u32])
            where 'a: 's {
        assert!(self.raw.queueFamilyIndexCount == 0 || self.raw.queueFamilyIndexCount == queue_family_indices.len() as _, 
            "count inconsistency found when specifying `SwapchainCreateInfoKhr::queue_family_indices`.");
        self.raw.queueFamilyIndexCount = queue_family_indices.len() as _;
        self.raw.pQueueFamilyIndices = queue_family_indices.as_ptr() as *const u32 as *const _;
    }

    pub fn set_pre_transform<'m>(&mut self, pre_transform: SurfaceTransformFlagsKhr) {
        self.raw.preTransform = pre_transform.bits();
    }

    pub fn set_composite_alpha<'m>(&mut self, composite_alpha: CompositeAlphaFlagsKhr) {
        self.raw.compositeAlpha = composite_alpha.bits();
    }

    pub fn set_present_mode<'m>(&mut self, present_mode: PresentModeKhr) {
        self.raw.presentMode = present_mode.into();
    }

    pub fn set_clipped<'m>(&mut self, clipped: bool) {
        self.raw.clipped = clipped as u32;
    }

    pub fn set_old_swapchain<'m, H>(&mut self, old_swapchain: H)
            where H: Handle<Target=SwapchainKhrHandle> {
        self.raw.oldSwapchain = old_swapchain.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkSwapchainCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<SwapchainCreateInfoKhr<'s>> for vks::VkSwapchainCreateInfoKHR {
    fn from(f: SwapchainCreateInfoKhr<'s>) -> vks::VkSwapchainCreateInfoKHR {
        f.raw
    }
}


/// A builder for `VkSwapchainCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SwapchainCreateInfoKhrBuilder<'b> {
    raw: vks::VkSwapchainCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SwapchainCreateInfoKhrBuilder<'b> {
    pub fn new() -> SwapchainCreateInfoKhrBuilder<'b> {
        SwapchainCreateInfoKhrBuilder {
            raw: vks::VkSwapchainCreateInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: SwapchainCreateFlagsKhr) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn surface<'m, H>(mut self, surface: H) -> SwapchainCreateInfoKhrBuilder<'b>
            where H: Handle<Target=SurfaceKhrHandle> {
        self.raw.surface = surface.handle().0;
        self
    }

    pub fn min_image_count<'m>(mut self, min_image_count: u32) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.minImageCount = min_image_count.into();
        self
    }

    pub fn image_format<'m>(mut self, image_format: Format) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.imageFormat = image_format.into();
        self
    }

    pub fn image_color_space<'m>(mut self, image_color_space: ColorSpaceKhr) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.imageColorSpace = image_color_space.into();
        self
    }

    pub fn image_extent<'m>(mut self, image_extent: Extent2d) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.imageExtent = image_extent.raw;
        self
    }

    pub fn image_array_layers<'m>(mut self, image_array_layers: u32) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.imageArrayLayers = image_array_layers.into();
        self
    }

    pub fn image_usage<'m>(mut self, image_usage: ImageUsageFlags) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.imageUsage = image_usage.bits();
        self
    }

    pub fn image_sharing_mode<'m>(mut self, image_sharing_mode: SharingMode) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.imageSharingMode = image_sharing_mode.into();
        self
    }

    pub fn queue_family_indices<'m, 'a>(mut self, queue_family_indices: &'a [u32]) -> SwapchainCreateInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.queueFamilyIndexCount == 0 || self.raw.queueFamilyIndexCount == queue_family_indices.len() as _, 
            "count inconsistency found when specifying `SwapchainCreateInfoKhr::queue_family_indices`.");
        self.raw.queueFamilyIndexCount = queue_family_indices.len() as _;
        self.raw.pQueueFamilyIndices = queue_family_indices.as_ptr() as *const u32 as *const _;
        self
    }

    pub fn pre_transform<'m>(mut self, pre_transform: SurfaceTransformFlagsKhr) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.preTransform = pre_transform.bits();
        self
    }

    pub fn composite_alpha<'m>(mut self, composite_alpha: CompositeAlphaFlagsKhr) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.compositeAlpha = composite_alpha.bits();
        self
    }

    pub fn present_mode<'m>(mut self, present_mode: PresentModeKhr) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.presentMode = present_mode.into();
        self
    }

    pub fn clipped<'m>(mut self, clipped: bool) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.clipped = clipped as u32;
        self
    }

    pub fn old_swapchain<'m, H>(mut self, old_swapchain: H) -> SwapchainCreateInfoKhrBuilder<'b>
            where H: Handle<Target=SwapchainKhrHandle> {
        self.raw.oldSwapchain = old_swapchain.handle().0;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> SwapchainCreateFlagsKhr {
        SwapchainCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("SwapchainCreateInfoKhr::flags: error converting flags")
    }

    pub fn get_surface<'a>(&'a self) -> vks::VkSurfaceKHR {
        self.raw.surface
    }

    pub fn get_min_image_count<'a>(&'a self) -> u32 {
        self.raw.minImageCount.into()
    }

    pub fn get_image_format<'a>(&'a self) -> Format {
        self.raw.imageFormat.into()
    }

    pub fn get_image_color_space<'a>(&'a self) -> ColorSpaceKhr {
        self.raw.imageColorSpace.into()
    }

    pub fn get_image_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.imageExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn get_image_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.imageExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn get_image_array_layers<'a>(&'a self) -> u32 {
        self.raw.imageArrayLayers.into()
    }

    pub fn get_image_usage<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.imageUsage)
            .expect("SwapchainCreateInfoKhr::image_usage: error converting flags")
    }

    pub fn get_image_sharing_mode<'a>(&'a self) -> SharingMode {
        self.raw.imageSharingMode.into()
    }

    pub fn get_queue_family_indices<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pQueueFamilyIndices as *const _, self.raw.queueFamilyIndexCount as usize) }
    }

    pub fn get_pre_transform<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.preTransform)
            .expect("SwapchainCreateInfoKhr::pre_transform: error converting flags")
    }

    pub fn get_composite_alpha<'a>(&'a self) -> CompositeAlphaFlagsKhr {
        CompositeAlphaFlagsKhr::from_bits(self.raw.compositeAlpha)
            .expect("SwapchainCreateInfoKhr::composite_alpha: error converting flags")
    }

    pub fn get_present_mode<'a>(&'a self) -> PresentModeKhr {
        self.raw.presentMode.into()
    }

    pub fn get_clipped<'a>(&'a self) -> bool {
        self.raw.clipped != 0
    }

    pub fn get_old_swapchain<'a>(&'a self) -> vks::VkSwapchainKHR {
        self.raw.oldSwapchain
    }

    pub fn build(self) -> SwapchainCreateInfoKhr<'b> {
        SwapchainCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPresentInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PresentInfoKhr<'s> {
    raw: vks::VkPresentInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PresentInfoKhr<'s> {
    pub fn builder<'b>() -> PresentInfoKhrBuilder<'b> {
        PresentInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPresentInfoKHR) -> PresentInfoKhr<'s> {
        PresentInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn wait_semaphores<'a>(&'a self) -> &'a [vks::VkSemaphore] {
        unsafe { slice::from_raw_parts(self.raw.pWaitSemaphores as *const _, self.raw.waitSemaphoreCount as usize) }
    }

    pub fn swapchains<'a>(&'a self) -> &'a [vks::VkSwapchainKHR] {
        unsafe { slice::from_raw_parts(self.raw.pSwapchains as *const _, self.raw.swapchainCount as usize) }
    }

    pub fn image_indices<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pImageIndices as *const _, self.raw.swapchainCount as usize) }
    }

    pub fn results<'a>(&'a self) -> &'a [CallResult] {
        unsafe { slice::from_raw_parts(self.raw.pResults as *const _, self.raw.swapchainCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_wait_semaphores<'m, 'a>(&mut self, wait_semaphores: &'a [SemaphoreHandle])
            where 'a: 's {
        assert!(self.raw.waitSemaphoreCount == 0 || self.raw.waitSemaphoreCount == wait_semaphores.len() as _, 
            "count inconsistency found when specifying `PresentInfoKhr::wait_semaphores`.");
        self.raw.waitSemaphoreCount = wait_semaphores.len() as _;
        self.raw.pWaitSemaphores = wait_semaphores.as_ptr() as *const vks::VkSemaphore;
    }

    pub fn set_swapchains<'m, 'a>(&mut self, swapchains: &'a [SwapchainKhrHandle])
            where 'a: 's {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == swapchains.len() as _, 
            "count inconsistency found when specifying `PresentInfoKhr::swapchains`.");
        self.raw.swapchainCount = swapchains.len() as _;
        self.raw.pSwapchains = swapchains.as_ptr() as *const vks::VkSwapchainKHR;
    }

    pub fn set_image_indices<'m, 'a>(&mut self, image_indices: &'a [u32])
            where 'a: 's {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == image_indices.len() as _, 
            "count inconsistency found when specifying `PresentInfoKhr::image_indices`.");
        self.raw.swapchainCount = image_indices.len() as _;
        self.raw.pImageIndices = image_indices.as_ptr() as *const u32 as *const _;
    }

    pub fn set_results<'m, 'a>(&mut self, results: &'a mut [CallResult])
            where 'a: 's {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == results.len() as _, 
            "count inconsistency found when specifying `PresentInfoKhr::results`.");
        self.raw.swapchainCount = results.len() as _;
        self.raw.pResults = results.as_mut_ptr() as *mut CallResult as *mut _;
    }

    pub fn as_raw(&self) -> &vks::VkPresentInfoKHR {
        &self.raw
    }
}

impl<'s> From<PresentInfoKhr<'s>> for vks::VkPresentInfoKHR {
    fn from(f: PresentInfoKhr<'s>) -> vks::VkPresentInfoKHR {
        f.raw
    }
}


/// A builder for `VkPresentInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PresentInfoKhrBuilder<'b> {
    raw: vks::VkPresentInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PresentInfoKhrBuilder<'b> {
    pub fn new() -> PresentInfoKhrBuilder<'b> {
        PresentInfoKhrBuilder {
            raw: vks::VkPresentInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PresentInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn wait_semaphores<'m, 'a>(mut self, wait_semaphores: &'a [SemaphoreHandle]) -> PresentInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.waitSemaphoreCount == 0 || self.raw.waitSemaphoreCount == wait_semaphores.len() as _, 
            "count inconsistency found when specifying `PresentInfoKhr::wait_semaphores`.");
        self.raw.waitSemaphoreCount = wait_semaphores.len() as _;
        self.raw.pWaitSemaphores = wait_semaphores.as_ptr() as *const vks::VkSemaphore;
        self
    }

    pub fn swapchains<'m, 'a>(mut self, swapchains: &'a [SwapchainKhrHandle]) -> PresentInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == swapchains.len() as _, 
            "count inconsistency found when specifying `PresentInfoKhr::swapchains`.");
        self.raw.swapchainCount = swapchains.len() as _;
        self.raw.pSwapchains = swapchains.as_ptr() as *const vks::VkSwapchainKHR;
        self
    }

    pub fn image_indices<'m, 'a>(mut self, image_indices: &'a [u32]) -> PresentInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == image_indices.len() as _, 
            "count inconsistency found when specifying `PresentInfoKhr::image_indices`.");
        self.raw.swapchainCount = image_indices.len() as _;
        self.raw.pImageIndices = image_indices.as_ptr() as *const u32 as *const _;
        self
    }

    pub fn results<'m, 'a>(mut self, results: &'a mut [CallResult]) -> PresentInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == results.len() as _, 
            "count inconsistency found when specifying `PresentInfoKhr::results`.");
        self.raw.swapchainCount = results.len() as _;
        self.raw.pResults = results.as_mut_ptr() as *mut CallResult as *mut _;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_wait_semaphores<'a>(&'a self) -> &'a [vks::VkSemaphore] {
        unsafe { slice::from_raw_parts(self.raw.pWaitSemaphores as *const _, self.raw.waitSemaphoreCount as usize) }
    }

    pub fn get_swapchains<'a>(&'a self) -> &'a [vks::VkSwapchainKHR] {
        unsafe { slice::from_raw_parts(self.raw.pSwapchains as *const _, self.raw.swapchainCount as usize) }
    }

    pub fn get_image_indices<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pImageIndices as *const _, self.raw.swapchainCount as usize) }
    }

    pub fn get_results<'a>(&'a self) -> &'a [CallResult] {
        unsafe { slice::from_raw_parts(self.raw.pResults as *const _, self.raw.swapchainCount as usize) }
    }

    pub fn build(self) -> PresentInfoKhr<'b> {
        PresentInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDebugReportCallbackCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DebugReportCallbackCreateInfoExt<'s> {
    raw: vks::VkDebugReportCallbackCreateInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> DebugReportCallbackCreateInfoExt<'s> {
    pub fn builder<'b>() -> DebugReportCallbackCreateInfoExtBuilder<'b> {
        DebugReportCallbackCreateInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDebugReportCallbackCreateInfoEXT) -> DebugReportCallbackCreateInfoExt<'s> {
        DebugReportCallbackCreateInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> DebugReportFlagsExt {
        DebugReportFlagsExt::from_bits(self.raw.flags)
            .expect("DebugReportCallbackCreateInfoExt::flags: error converting flags")
    }

    pub fn pfn_callback<'a>(&'a self) -> PFN_vkDebugReportCallbackEXT {
        self.raw.pfnCallback.into()
    }

    pub fn user_data<'a>(&'a self) -> *mut c_void {
        self.raw.pUserData
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: DebugReportFlagsExt) {
        self.raw.flags = flags.bits();
    }

    pub unsafe fn set_pfn_callback<'m>(&mut self, pfn_callback: PFN_vkDebugReportCallbackEXT) {
        self.raw.pfnCallback = pfn_callback.into();
    }

    pub unsafe fn set_user_data<'m>(&mut self, user_data: *mut c_void) {
        self.raw.pUserData = user_data;
    }

    pub fn as_raw(&self) -> &vks::VkDebugReportCallbackCreateInfoEXT {
        &self.raw
    }
}

impl<'s> From<DebugReportCallbackCreateInfoExt<'s>> for vks::VkDebugReportCallbackCreateInfoEXT {
    fn from(f: DebugReportCallbackCreateInfoExt<'s>) -> vks::VkDebugReportCallbackCreateInfoEXT {
        f.raw
    }
}


/// A builder for `VkDebugReportCallbackCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DebugReportCallbackCreateInfoExtBuilder<'b> {
    raw: vks::VkDebugReportCallbackCreateInfoEXT,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DebugReportCallbackCreateInfoExtBuilder<'b> {
    pub fn new() -> DebugReportCallbackCreateInfoExtBuilder<'b> {
        DebugReportCallbackCreateInfoExtBuilder {
            raw: vks::VkDebugReportCallbackCreateInfoEXT::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DebugReportCallbackCreateInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: DebugReportFlagsExt) -> DebugReportCallbackCreateInfoExtBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub unsafe fn pfn_callback<'m>(mut self, pfn_callback: PFN_vkDebugReportCallbackEXT) -> DebugReportCallbackCreateInfoExtBuilder<'b> {
        self.raw.pfnCallback = pfn_callback.into();
        self
    }

    pub unsafe fn user_data<'m>(mut self, user_data: *mut c_void) -> DebugReportCallbackCreateInfoExtBuilder<'b> {
        self.raw.pUserData = user_data;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> DebugReportFlagsExt {
        DebugReportFlagsExt::from_bits(self.raw.flags)
            .expect("DebugReportCallbackCreateInfoExt::flags: error converting flags")
    }

    pub fn get_pfn_callback<'a>(&'a self) -> PFN_vkDebugReportCallbackEXT {
        self.raw.pfnCallback.into()
    }

    pub fn get_user_data<'a>(&'a self) -> *mut c_void {
        self.raw.pUserData
    }

    pub fn build(self) -> DebugReportCallbackCreateInfoExt<'b> {
        DebugReportCallbackCreateInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkValidationFlagsEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ValidationFlagsExt<'s> {
    raw: vks::VkValidationFlagsEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> ValidationFlagsExt<'s> {
    pub fn builder<'b>() -> ValidationFlagsExtBuilder<'b> {
        ValidationFlagsExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkValidationFlagsEXT) -> ValidationFlagsExt<'s> {
        ValidationFlagsExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn disabled_validation_checks<'a>(&'a self) -> &'a [ValidationCheckExt] {
        unsafe { slice::from_raw_parts(self.raw.pDisabledValidationChecks as *const _, self.raw.disabledValidationCheckCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_disabled_validation_checks<'m, 'a>(&mut self, disabled_validation_checks: &'a mut [ValidationCheckExt])
            where 'a: 's {
        assert!(self.raw.disabledValidationCheckCount == 0 || self.raw.disabledValidationCheckCount == disabled_validation_checks.len() as _, 
            "count inconsistency found when specifying `ValidationFlagsExt::disabled_validation_checks`.");
        self.raw.disabledValidationCheckCount = disabled_validation_checks.len() as _;
        self.raw.pDisabledValidationChecks = disabled_validation_checks.as_mut_ptr() as *mut ValidationCheckExt as *mut _;
    }

    pub fn as_raw(&self) -> &vks::VkValidationFlagsEXT {
        &self.raw
    }
}

impl<'s> From<ValidationFlagsExt<'s>> for vks::VkValidationFlagsEXT {
    fn from(f: ValidationFlagsExt<'s>) -> vks::VkValidationFlagsEXT {
        f.raw
    }
}


/// A builder for `VkValidationFlagsEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ValidationFlagsExtBuilder<'b> {
    raw: vks::VkValidationFlagsEXT,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ValidationFlagsExtBuilder<'b> {
    pub fn new() -> ValidationFlagsExtBuilder<'b> {
        ValidationFlagsExtBuilder {
            raw: vks::VkValidationFlagsEXT::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ValidationFlagsExtBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn disabled_validation_checks<'m, 'a>(mut self, disabled_validation_checks: &'a mut [ValidationCheckExt]) -> ValidationFlagsExtBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.disabledValidationCheckCount == 0 || self.raw.disabledValidationCheckCount == disabled_validation_checks.len() as _, 
            "count inconsistency found when specifying `ValidationFlagsExt::disabled_validation_checks`.");
        self.raw.disabledValidationCheckCount = disabled_validation_checks.len() as _;
        self.raw.pDisabledValidationChecks = disabled_validation_checks.as_mut_ptr() as *mut ValidationCheckExt as *mut _;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_disabled_validation_checks<'a>(&'a self) -> &'a [ValidationCheckExt] {
        unsafe { slice::from_raw_parts(self.raw.pDisabledValidationChecks as *const _, self.raw.disabledValidationCheckCount as usize) }
    }

    pub fn build(self) -> ValidationFlagsExt<'b> {
        ValidationFlagsExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineRasterizationStateRasterizationOrderAMD`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineRasterizationStateRasterizationOrderAmd<'s> {
    raw: vks::VkPipelineRasterizationStateRasterizationOrderAMD,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineRasterizationStateRasterizationOrderAmd<'s> {
    pub fn builder<'b>() -> PipelineRasterizationStateRasterizationOrderAmdBuilder<'b> {
        PipelineRasterizationStateRasterizationOrderAmdBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineRasterizationStateRasterizationOrderAMD) -> PipelineRasterizationStateRasterizationOrderAmd<'s> {
        PipelineRasterizationStateRasterizationOrderAmd { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn rasterization_order<'a>(&'a self) -> RasterizationOrderAmd {
        self.raw.rasterizationOrder.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_rasterization_order<'m>(&mut self, rasterization_order: RasterizationOrderAmd) {
        self.raw.rasterizationOrder = rasterization_order.into();
    }

    pub fn as_raw(&self) -> &vks::VkPipelineRasterizationStateRasterizationOrderAMD {
        &self.raw
    }
}

impl<'s> From<PipelineRasterizationStateRasterizationOrderAmd<'s>> for vks::VkPipelineRasterizationStateRasterizationOrderAMD {
    fn from(f: PipelineRasterizationStateRasterizationOrderAmd<'s>) -> vks::VkPipelineRasterizationStateRasterizationOrderAMD {
        f.raw
    }
}


/// A builder for `VkPipelineRasterizationStateRasterizationOrderAMD`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineRasterizationStateRasterizationOrderAmdBuilder<'b> {
    raw: vks::VkPipelineRasterizationStateRasterizationOrderAMD,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineRasterizationStateRasterizationOrderAmdBuilder<'b> {
    pub fn new() -> PipelineRasterizationStateRasterizationOrderAmdBuilder<'b> {
        PipelineRasterizationStateRasterizationOrderAmdBuilder {
            raw: vks::VkPipelineRasterizationStateRasterizationOrderAMD::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineRasterizationStateRasterizationOrderAmdBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn rasterization_order<'m>(mut self, rasterization_order: RasterizationOrderAmd) -> PipelineRasterizationStateRasterizationOrderAmdBuilder<'b> {
        self.raw.rasterizationOrder = rasterization_order.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_rasterization_order<'a>(&'a self) -> RasterizationOrderAmd {
        self.raw.rasterizationOrder.into()
    }

    pub fn build(self) -> PipelineRasterizationStateRasterizationOrderAmd<'b> {
        PipelineRasterizationStateRasterizationOrderAmd {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDebugMarkerObjectNameInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DebugMarkerObjectNameInfoExt<'s> {
    raw: vks::VkDebugMarkerObjectNameInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> DebugMarkerObjectNameInfoExt<'s> {
    pub fn builder<'b>() -> DebugMarkerObjectNameInfoExtBuilder<'b> {
        DebugMarkerObjectNameInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDebugMarkerObjectNameInfoEXT) -> DebugMarkerObjectNameInfoExt<'s> {
        DebugMarkerObjectNameInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn object_type<'a>(&'a self) -> DebugReportObjectTypeExt {
        self.raw.objectType.into()
    }

    pub fn object<'a>(&'a self) -> u64 {
        self.raw.object.into()
    }

    pub fn object_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(self.raw.pObjectName) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_object_type<'m>(&mut self, object_type: DebugReportObjectTypeExt) {
        self.raw.objectType = object_type.into();
    }

    pub fn set_object<'m>(&mut self, object: u64) {
        self.raw.object = object.into();
    }

    pub fn set_object_name<'m, 'a>(&mut self, object_name: &'a CStr)
            where 'a: 's {
        self.raw.pObjectName = object_name.as_ptr();
    }

    pub fn as_raw(&self) -> &vks::VkDebugMarkerObjectNameInfoEXT {
        &self.raw
    }
}

impl<'s> From<DebugMarkerObjectNameInfoExt<'s>> for vks::VkDebugMarkerObjectNameInfoEXT {
    fn from(f: DebugMarkerObjectNameInfoExt<'s>) -> vks::VkDebugMarkerObjectNameInfoEXT {
        f.raw
    }
}


/// A builder for `VkDebugMarkerObjectNameInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DebugMarkerObjectNameInfoExtBuilder<'b> {
    raw: vks::VkDebugMarkerObjectNameInfoEXT,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DebugMarkerObjectNameInfoExtBuilder<'b> {
    pub fn new() -> DebugMarkerObjectNameInfoExtBuilder<'b> {
        DebugMarkerObjectNameInfoExtBuilder {
            raw: vks::VkDebugMarkerObjectNameInfoEXT::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DebugMarkerObjectNameInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn object_type<'m>(mut self, object_type: DebugReportObjectTypeExt) -> DebugMarkerObjectNameInfoExtBuilder<'b> {
        self.raw.objectType = object_type.into();
        self
    }

    pub fn object<'m>(mut self, object: u64) -> DebugMarkerObjectNameInfoExtBuilder<'b> {
        self.raw.object = object.into();
        self
    }

    pub fn object_name<'m, 'a>(mut self, object_name: &'a CStr) -> DebugMarkerObjectNameInfoExtBuilder<'b>
            where 'a: 'b {
        self.raw.pObjectName = object_name.as_ptr();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_object_type<'a>(&'a self) -> DebugReportObjectTypeExt {
        self.raw.objectType.into()
    }

    pub fn get_object<'a>(&'a self) -> u64 {
        self.raw.object.into()
    }

    pub fn get_object_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(self.raw.pObjectName) }
    }

    pub fn build(self) -> DebugMarkerObjectNameInfoExt<'b> {
        DebugMarkerObjectNameInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDebugMarkerObjectTagInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DebugMarkerObjectTagInfoExt<'s> {
    raw: vks::VkDebugMarkerObjectTagInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> DebugMarkerObjectTagInfoExt<'s> {
    pub fn builder<'b>() -> DebugMarkerObjectTagInfoExtBuilder<'b> {
        DebugMarkerObjectTagInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDebugMarkerObjectTagInfoEXT) -> DebugMarkerObjectTagInfoExt<'s> {
        DebugMarkerObjectTagInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn object_type<'a>(&'a self) -> DebugReportObjectTypeExt {
        self.raw.objectType.into()
    }

    pub fn object<'a>(&'a self) -> u64 {
        self.raw.object.into()
    }

    pub fn tag_name<'a>(&'a self) -> u64 {
        self.raw.tagName.into()
    }

    pub fn tag_size<'a>(&'a self) -> usize {
        self.raw.tagSize.into()
    }

    pub fn tag<'a>(&'a self) -> *const c_void {
        self.raw.pTag
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_object_type<'m>(&mut self, object_type: DebugReportObjectTypeExt) {
        self.raw.objectType = object_type.into();
    }

    pub fn set_object<'m>(&mut self, object: u64) {
        self.raw.object = object.into();
    }

    pub fn set_tag_name<'m>(&mut self, tag_name: u64) {
        self.raw.tagName = tag_name.into();
    }

    pub fn set_tag_size<'m>(&mut self, tag_size: usize) {
        self.raw.tagSize = tag_size.into();
    }

    pub unsafe fn set_tag<'m>(&mut self, tag: *const c_void) {
        self.raw.pTag = tag;
    }

    pub fn as_raw(&self) -> &vks::VkDebugMarkerObjectTagInfoEXT {
        &self.raw
    }
}

impl<'s> From<DebugMarkerObjectTagInfoExt<'s>> for vks::VkDebugMarkerObjectTagInfoEXT {
    fn from(f: DebugMarkerObjectTagInfoExt<'s>) -> vks::VkDebugMarkerObjectTagInfoEXT {
        f.raw
    }
}


/// A builder for `VkDebugMarkerObjectTagInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DebugMarkerObjectTagInfoExtBuilder<'b> {
    raw: vks::VkDebugMarkerObjectTagInfoEXT,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DebugMarkerObjectTagInfoExtBuilder<'b> {
    pub fn new() -> DebugMarkerObjectTagInfoExtBuilder<'b> {
        DebugMarkerObjectTagInfoExtBuilder {
            raw: vks::VkDebugMarkerObjectTagInfoEXT::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DebugMarkerObjectTagInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn object_type<'m>(mut self, object_type: DebugReportObjectTypeExt) -> DebugMarkerObjectTagInfoExtBuilder<'b> {
        self.raw.objectType = object_type.into();
        self
    }

    pub fn object<'m>(mut self, object: u64) -> DebugMarkerObjectTagInfoExtBuilder<'b> {
        self.raw.object = object.into();
        self
    }

    pub fn tag_name<'m>(mut self, tag_name: u64) -> DebugMarkerObjectTagInfoExtBuilder<'b> {
        self.raw.tagName = tag_name.into();
        self
    }

    pub fn tag_size<'m>(mut self, tag_size: usize) -> DebugMarkerObjectTagInfoExtBuilder<'b> {
        self.raw.tagSize = tag_size.into();
        self
    }

    pub unsafe fn tag<'m>(mut self, tag: *const c_void) -> DebugMarkerObjectTagInfoExtBuilder<'b> {
        self.raw.pTag = tag;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_object_type<'a>(&'a self) -> DebugReportObjectTypeExt {
        self.raw.objectType.into()
    }

    pub fn get_object<'a>(&'a self) -> u64 {
        self.raw.object.into()
    }

    pub fn get_tag_name<'a>(&'a self) -> u64 {
        self.raw.tagName.into()
    }

    pub fn get_tag_size<'a>(&'a self) -> usize {
        self.raw.tagSize.into()
    }

    pub fn get_tag<'a>(&'a self) -> *const c_void {
        self.raw.pTag
    }

    pub fn build(self) -> DebugMarkerObjectTagInfoExt<'b> {
        DebugMarkerObjectTagInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDebugMarkerMarkerInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DebugMarkerMarkerInfoExt<'s> {
    raw: vks::VkDebugMarkerMarkerInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> DebugMarkerMarkerInfoExt<'s> {
    pub fn builder<'b>() -> DebugMarkerMarkerInfoExtBuilder<'b> {
        DebugMarkerMarkerInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDebugMarkerMarkerInfoEXT) -> DebugMarkerMarkerInfoExt<'s> {
        DebugMarkerMarkerInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn marker_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(self.raw.pMarkerName) }
    }

    pub fn color<'a>(&'a self) -> &[f32] {
        unsafe { slice::from_raw_parts(&self.raw.color as *const _, 4 as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_marker_name<'m, 'a>(&mut self, marker_name: &'a CStr)
            where 'a: 's {
        self.raw.pMarkerName = marker_name.as_ptr();
    }

    pub fn set_color<'m>(&mut self, color: [f32; 4]) {
        self.raw.color = color;
    }

    pub fn as_raw(&self) -> &vks::VkDebugMarkerMarkerInfoEXT {
        &self.raw
    }
}

impl<'s> From<DebugMarkerMarkerInfoExt<'s>> for vks::VkDebugMarkerMarkerInfoEXT {
    fn from(f: DebugMarkerMarkerInfoExt<'s>) -> vks::VkDebugMarkerMarkerInfoEXT {
        f.raw
    }
}


/// A builder for `VkDebugMarkerMarkerInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DebugMarkerMarkerInfoExtBuilder<'b> {
    raw: vks::VkDebugMarkerMarkerInfoEXT,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DebugMarkerMarkerInfoExtBuilder<'b> {
    pub fn new() -> DebugMarkerMarkerInfoExtBuilder<'b> {
        DebugMarkerMarkerInfoExtBuilder {
            raw: vks::VkDebugMarkerMarkerInfoEXT::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DebugMarkerMarkerInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn marker_name<'m, 'a>(mut self, marker_name: &'a CStr) -> DebugMarkerMarkerInfoExtBuilder<'b>
            where 'a: 'b {
        self.raw.pMarkerName = marker_name.as_ptr();
        self
    }

    pub fn color<'m>(mut self, color: [f32; 4]) -> DebugMarkerMarkerInfoExtBuilder<'b> {
        self.raw.color = color;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_marker_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(self.raw.pMarkerName) }
    }

    pub fn get_color<'a>(&'a self) -> &[f32] {
        unsafe { slice::from_raw_parts(&self.raw.color as *const _, 4 as usize) }
    }

    pub fn build(self) -> DebugMarkerMarkerInfoExt<'b> {
        DebugMarkerMarkerInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDedicatedAllocationImageCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DedicatedAllocationImageCreateInfoNv<'s> {
    raw: vks::VkDedicatedAllocationImageCreateInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> DedicatedAllocationImageCreateInfoNv<'s> {
    pub fn builder<'b>() -> DedicatedAllocationImageCreateInfoNvBuilder<'b> {
        DedicatedAllocationImageCreateInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDedicatedAllocationImageCreateInfoNV) -> DedicatedAllocationImageCreateInfoNv<'s> {
        DedicatedAllocationImageCreateInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn dedicated_allocation<'a>(&'a self) -> bool {
        self.raw.dedicatedAllocation != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_dedicated_allocation<'m>(&mut self, dedicated_allocation: bool) {
        self.raw.dedicatedAllocation = dedicated_allocation as u32;
    }

    pub fn as_raw(&self) -> &vks::VkDedicatedAllocationImageCreateInfoNV {
        &self.raw
    }
}

impl<'s> From<DedicatedAllocationImageCreateInfoNv<'s>> for vks::VkDedicatedAllocationImageCreateInfoNV {
    fn from(f: DedicatedAllocationImageCreateInfoNv<'s>) -> vks::VkDedicatedAllocationImageCreateInfoNV {
        f.raw
    }
}


/// A builder for `VkDedicatedAllocationImageCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DedicatedAllocationImageCreateInfoNvBuilder<'b> {
    raw: vks::VkDedicatedAllocationImageCreateInfoNV,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DedicatedAllocationImageCreateInfoNvBuilder<'b> {
    pub fn new() -> DedicatedAllocationImageCreateInfoNvBuilder<'b> {
        DedicatedAllocationImageCreateInfoNvBuilder {
            raw: vks::VkDedicatedAllocationImageCreateInfoNV::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DedicatedAllocationImageCreateInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn dedicated_allocation<'m>(mut self, dedicated_allocation: bool) -> DedicatedAllocationImageCreateInfoNvBuilder<'b> {
        self.raw.dedicatedAllocation = dedicated_allocation as u32;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_dedicated_allocation<'a>(&'a self) -> bool {
        self.raw.dedicatedAllocation != 0
    }

    pub fn build(self) -> DedicatedAllocationImageCreateInfoNv<'b> {
        DedicatedAllocationImageCreateInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDedicatedAllocationBufferCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DedicatedAllocationBufferCreateInfoNv<'s> {
    raw: vks::VkDedicatedAllocationBufferCreateInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> DedicatedAllocationBufferCreateInfoNv<'s> {
    pub fn builder<'b>() -> DedicatedAllocationBufferCreateInfoNvBuilder<'b> {
        DedicatedAllocationBufferCreateInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDedicatedAllocationBufferCreateInfoNV) -> DedicatedAllocationBufferCreateInfoNv<'s> {
        DedicatedAllocationBufferCreateInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn dedicated_allocation<'a>(&'a self) -> bool {
        self.raw.dedicatedAllocation != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_dedicated_allocation<'m>(&mut self, dedicated_allocation: bool) {
        self.raw.dedicatedAllocation = dedicated_allocation as u32;
    }

    pub fn as_raw(&self) -> &vks::VkDedicatedAllocationBufferCreateInfoNV {
        &self.raw
    }
}

impl<'s> From<DedicatedAllocationBufferCreateInfoNv<'s>> for vks::VkDedicatedAllocationBufferCreateInfoNV {
    fn from(f: DedicatedAllocationBufferCreateInfoNv<'s>) -> vks::VkDedicatedAllocationBufferCreateInfoNV {
        f.raw
    }
}


/// A builder for `VkDedicatedAllocationBufferCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DedicatedAllocationBufferCreateInfoNvBuilder<'b> {
    raw: vks::VkDedicatedAllocationBufferCreateInfoNV,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DedicatedAllocationBufferCreateInfoNvBuilder<'b> {
    pub fn new() -> DedicatedAllocationBufferCreateInfoNvBuilder<'b> {
        DedicatedAllocationBufferCreateInfoNvBuilder {
            raw: vks::VkDedicatedAllocationBufferCreateInfoNV::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DedicatedAllocationBufferCreateInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn dedicated_allocation<'m>(mut self, dedicated_allocation: bool) -> DedicatedAllocationBufferCreateInfoNvBuilder<'b> {
        self.raw.dedicatedAllocation = dedicated_allocation as u32;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_dedicated_allocation<'a>(&'a self) -> bool {
        self.raw.dedicatedAllocation != 0
    }

    pub fn build(self) -> DedicatedAllocationBufferCreateInfoNv<'b> {
        DedicatedAllocationBufferCreateInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDedicatedAllocationMemoryAllocateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DedicatedAllocationMemoryAllocateInfoNv<'s> {
    raw: vks::VkDedicatedAllocationMemoryAllocateInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> DedicatedAllocationMemoryAllocateInfoNv<'s> {
    pub fn builder<'b>() -> DedicatedAllocationMemoryAllocateInfoNvBuilder<'b> {
        DedicatedAllocationMemoryAllocateInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDedicatedAllocationMemoryAllocateInfoNV) -> DedicatedAllocationMemoryAllocateInfoNv<'s> {
        DedicatedAllocationMemoryAllocateInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_image<'m, H>(&mut self, image: H)
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
    }

    pub fn set_buffer<'m, H>(&mut self, buffer: H)
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkDedicatedAllocationMemoryAllocateInfoNV {
        &self.raw
    }
}

impl<'s> From<DedicatedAllocationMemoryAllocateInfoNv<'s>> for vks::VkDedicatedAllocationMemoryAllocateInfoNV {
    fn from(f: DedicatedAllocationMemoryAllocateInfoNv<'s>) -> vks::VkDedicatedAllocationMemoryAllocateInfoNV {
        f.raw
    }
}


/// A builder for `VkDedicatedAllocationMemoryAllocateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DedicatedAllocationMemoryAllocateInfoNvBuilder<'b> {
    raw: vks::VkDedicatedAllocationMemoryAllocateInfoNV,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DedicatedAllocationMemoryAllocateInfoNvBuilder<'b> {
    pub fn new() -> DedicatedAllocationMemoryAllocateInfoNvBuilder<'b> {
        DedicatedAllocationMemoryAllocateInfoNvBuilder {
            raw: vks::VkDedicatedAllocationMemoryAllocateInfoNV::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DedicatedAllocationMemoryAllocateInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn image<'m, H>(mut self, image: H) -> DedicatedAllocationMemoryAllocateInfoNvBuilder<'b>
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
        self
    }

    pub fn buffer<'m, H>(mut self, buffer: H) -> DedicatedAllocationMemoryAllocateInfoNvBuilder<'b>
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn get_buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn build(self) -> DedicatedAllocationMemoryAllocateInfoNv<'b> {
        DedicatedAllocationMemoryAllocateInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExternalImageFormatPropertiesNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExternalImageFormatPropertiesNv {
    raw: vks::VkExternalImageFormatPropertiesNV,
}

impl ExternalImageFormatPropertiesNv {
    pub fn builder() -> ExternalImageFormatPropertiesNvBuilder {
        ExternalImageFormatPropertiesNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExternalImageFormatPropertiesNV) -> ExternalImageFormatPropertiesNv {
        ExternalImageFormatPropertiesNv { raw, }
    }

    pub fn image_format_properties<'a>(&'a self) -> &'a ImageFormatProperties {
        unsafe { &*(&self.raw.imageFormatProperties as *const vks::VkImageFormatProperties as *const ImageFormatProperties) }
    }

    pub fn image_format_properties_mut<'a>(&'a mut self) -> &'a mut ImageFormatProperties {
        unsafe { &mut *(&mut self.raw.imageFormatProperties as *mut  vks::VkImageFormatProperties as *mut ImageFormatProperties) }
    }

    pub fn external_memory_features<'a>(&'a self) -> ExternalMemoryFeatureFlagsNv {
        ExternalMemoryFeatureFlagsNv::from_bits(self.raw.externalMemoryFeatures)
            .expect("ExternalImageFormatPropertiesNv::external_memory_features: error converting flags")
    }

    pub fn export_from_imported_handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsNv {
        ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.exportFromImportedHandleTypes)
            .expect("ExternalImageFormatPropertiesNv::export_from_imported_handle_types: error converting flags")
    }

    pub fn compatible_handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsNv {
        ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.compatibleHandleTypes)
            .expect("ExternalImageFormatPropertiesNv::compatible_handle_types: error converting flags")
    }

    pub fn set_image_format_properties<'m>(&mut self, image_format_properties: ImageFormatProperties) {
        self.raw.imageFormatProperties = image_format_properties.raw;
    }

    pub fn set_external_memory_features<'m>(&mut self, external_memory_features: ExternalMemoryFeatureFlagsNv) {
        self.raw.externalMemoryFeatures = external_memory_features.bits();
    }

    pub fn set_export_from_imported_handle_types<'m>(&mut self, export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsNv) {
        self.raw.exportFromImportedHandleTypes = export_from_imported_handle_types.bits();
    }

    pub fn set_compatible_handle_types<'m>(&mut self, compatible_handle_types: ExternalMemoryHandleTypeFlagsNv) {
        self.raw.compatibleHandleTypes = compatible_handle_types.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExternalImageFormatPropertiesNV {
        &self.raw
    }
}

impl From<ExternalImageFormatPropertiesNv> for vks::VkExternalImageFormatPropertiesNV {
    fn from(f: ExternalImageFormatPropertiesNv) -> vks::VkExternalImageFormatPropertiesNV {
        f.raw
    }
}


/// A builder for `VkExternalImageFormatPropertiesNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExternalImageFormatPropertiesNvBuilder {
    raw: vks::VkExternalImageFormatPropertiesNV,
}

impl ExternalImageFormatPropertiesNvBuilder {
    pub fn new() -> ExternalImageFormatPropertiesNvBuilder {
        ExternalImageFormatPropertiesNvBuilder {
            raw: vks::VkExternalImageFormatPropertiesNV::default(),
        }
    }

    pub fn image_format_properties<'m>(mut self, image_format_properties: ImageFormatProperties) -> ExternalImageFormatPropertiesNvBuilder {
        self.raw.imageFormatProperties = image_format_properties.raw;
        self
    }

    pub fn external_memory_features<'m>(mut self, external_memory_features: ExternalMemoryFeatureFlagsNv) -> ExternalImageFormatPropertiesNvBuilder {
        self.raw.externalMemoryFeatures = external_memory_features.bits();
        self
    }

    pub fn export_from_imported_handle_types<'m>(mut self, export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsNv) -> ExternalImageFormatPropertiesNvBuilder {
        self.raw.exportFromImportedHandleTypes = export_from_imported_handle_types.bits();
        self
    }

    pub fn compatible_handle_types<'m>(mut self, compatible_handle_types: ExternalMemoryHandleTypeFlagsNv) -> ExternalImageFormatPropertiesNvBuilder {
        self.raw.compatibleHandleTypes = compatible_handle_types.bits();
        self
    }

    pub fn get_image_format_properties<'a>(&'a self) -> &'a ImageFormatProperties {
        unsafe { &*(&self.raw.imageFormatProperties as *const vks::VkImageFormatProperties as *const ImageFormatProperties) }
    }

    pub fn get_image_format_properties_mut<'a>(&'a mut self) -> &'a mut ImageFormatProperties {
        unsafe { &mut *(&mut self.raw.imageFormatProperties as *mut  vks::VkImageFormatProperties as *mut ImageFormatProperties) }
    }

    pub fn get_external_memory_features<'a>(&'a self) -> ExternalMemoryFeatureFlagsNv {
        ExternalMemoryFeatureFlagsNv::from_bits(self.raw.externalMemoryFeatures)
            .expect("ExternalImageFormatPropertiesNv::external_memory_features: error converting flags")
    }

    pub fn get_export_from_imported_handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsNv {
        ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.exportFromImportedHandleTypes)
            .expect("ExternalImageFormatPropertiesNv::export_from_imported_handle_types: error converting flags")
    }

    pub fn get_compatible_handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsNv {
        ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.compatibleHandleTypes)
            .expect("ExternalImageFormatPropertiesNv::compatible_handle_types: error converting flags")
    }

    pub fn build(self) -> ExternalImageFormatPropertiesNv {
        ExternalImageFormatPropertiesNv {
            raw: self.raw,
        }
    }
}


/// A `VkExternalMemoryImageCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExternalMemoryImageCreateInfoNv<'s> {
    raw: vks::VkExternalMemoryImageCreateInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExternalMemoryImageCreateInfoNv<'s> {
    pub fn builder<'b>() -> ExternalMemoryImageCreateInfoNvBuilder<'b> {
        ExternalMemoryImageCreateInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExternalMemoryImageCreateInfoNV) -> ExternalMemoryImageCreateInfoNv<'s> {
        ExternalMemoryImageCreateInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsNv {
        ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.handleTypes)
            .expect("ExternalMemoryImageCreateInfoNv::handle_types: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_types<'m>(&mut self, handle_types: ExternalMemoryHandleTypeFlagsNv) {
        self.raw.handleTypes = handle_types.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExternalMemoryImageCreateInfoNV {
        &self.raw
    }
}

impl<'s> From<ExternalMemoryImageCreateInfoNv<'s>> for vks::VkExternalMemoryImageCreateInfoNV {
    fn from(f: ExternalMemoryImageCreateInfoNv<'s>) -> vks::VkExternalMemoryImageCreateInfoNV {
        f.raw
    }
}


/// A builder for `VkExternalMemoryImageCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExternalMemoryImageCreateInfoNvBuilder<'b> {
    raw: vks::VkExternalMemoryImageCreateInfoNV,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ExternalMemoryImageCreateInfoNvBuilder<'b> {
    pub fn new() -> ExternalMemoryImageCreateInfoNvBuilder<'b> {
        ExternalMemoryImageCreateInfoNvBuilder {
            raw: vks::VkExternalMemoryImageCreateInfoNV::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExternalMemoryImageCreateInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn handle_types<'m>(mut self, handle_types: ExternalMemoryHandleTypeFlagsNv) -> ExternalMemoryImageCreateInfoNvBuilder<'b> {
        self.raw.handleTypes = handle_types.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsNv {
        ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.handleTypes)
            .expect("ExternalMemoryImageCreateInfoNv::handle_types: error converting flags")
    }

    pub fn build(self) -> ExternalMemoryImageCreateInfoNv<'b> {
        ExternalMemoryImageCreateInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExportMemoryAllocateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExportMemoryAllocateInfoNv<'s> {
    raw: vks::VkExportMemoryAllocateInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExportMemoryAllocateInfoNv<'s> {
    pub fn builder<'b>() -> ExportMemoryAllocateInfoNvBuilder<'b> {
        ExportMemoryAllocateInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExportMemoryAllocateInfoNV) -> ExportMemoryAllocateInfoNv<'s> {
        ExportMemoryAllocateInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsNv {
        ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.handleTypes)
            .expect("ExportMemoryAllocateInfoNv::handle_types: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_types<'m>(&mut self, handle_types: ExternalMemoryHandleTypeFlagsNv) {
        self.raw.handleTypes = handle_types.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExportMemoryAllocateInfoNV {
        &self.raw
    }
}

impl<'s> From<ExportMemoryAllocateInfoNv<'s>> for vks::VkExportMemoryAllocateInfoNV {
    fn from(f: ExportMemoryAllocateInfoNv<'s>) -> vks::VkExportMemoryAllocateInfoNV {
        f.raw
    }
}


/// A builder for `VkExportMemoryAllocateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExportMemoryAllocateInfoNvBuilder<'b> {
    raw: vks::VkExportMemoryAllocateInfoNV,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ExportMemoryAllocateInfoNvBuilder<'b> {
    pub fn new() -> ExportMemoryAllocateInfoNvBuilder<'b> {
        ExportMemoryAllocateInfoNvBuilder {
            raw: vks::VkExportMemoryAllocateInfoNV::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExportMemoryAllocateInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn handle_types<'m>(mut self, handle_types: ExternalMemoryHandleTypeFlagsNv) -> ExportMemoryAllocateInfoNvBuilder<'b> {
        self.raw.handleTypes = handle_types.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsNv {
        ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.handleTypes)
            .expect("ExportMemoryAllocateInfoNv::handle_types: error converting flags")
    }

    pub fn build(self) -> ExportMemoryAllocateInfoNv<'b> {
        ExportMemoryAllocateInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImportMemoryWin32HandleInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImportMemoryWin32HandleInfoNv<'s> {
    raw: vks::VkImportMemoryWin32HandleInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImportMemoryWin32HandleInfoNv<'s> {
    pub fn builder<'b>() -> ImportMemoryWin32HandleInfoNvBuilder<'b> {
        ImportMemoryWin32HandleInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImportMemoryWin32HandleInfoNV) -> ImportMemoryWin32HandleInfoNv<'s> {
        ImportMemoryWin32HandleInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsNv {
        ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.handleType)
            .expect("ImportMemoryWin32HandleInfoNv::handle_type: error converting flags")
    }

    pub fn handle<'a>(&'a self) -> HANDLE {
        self.raw.handle.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalMemoryHandleTypeFlagsNv) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn set_handle<'m>(&mut self, handle: HANDLE) {
        self.raw.handle = handle.into();
    }

    pub fn as_raw(&self) -> &vks::VkImportMemoryWin32HandleInfoNV {
        &self.raw
    }
}

impl<'s> From<ImportMemoryWin32HandleInfoNv<'s>> for vks::VkImportMemoryWin32HandleInfoNV {
    fn from(f: ImportMemoryWin32HandleInfoNv<'s>) -> vks::VkImportMemoryWin32HandleInfoNV {
        f.raw
    }
}


/// A builder for `VkImportMemoryWin32HandleInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImportMemoryWin32HandleInfoNvBuilder<'b> {
    raw: vks::VkImportMemoryWin32HandleInfoNV,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ImportMemoryWin32HandleInfoNvBuilder<'b> {
    pub fn new() -> ImportMemoryWin32HandleInfoNvBuilder<'b> {
        ImportMemoryWin32HandleInfoNvBuilder {
            raw: vks::VkImportMemoryWin32HandleInfoNV::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImportMemoryWin32HandleInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalMemoryHandleTypeFlagsNv) -> ImportMemoryWin32HandleInfoNvBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self
    }

    pub fn handle<'m>(mut self, handle: HANDLE) -> ImportMemoryWin32HandleInfoNvBuilder<'b> {
        self.raw.handle = handle.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsNv {
        ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.handleType)
            .expect("ImportMemoryWin32HandleInfoNv::handle_type: error converting flags")
    }

    pub fn get_handle<'a>(&'a self) -> HANDLE {
        self.raw.handle.into()
    }

    pub fn build(self) -> ImportMemoryWin32HandleInfoNv<'b> {
        ImportMemoryWin32HandleInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExportMemoryWin32HandleInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExportMemoryWin32HandleInfoNv<'s> {
    raw: vks::VkExportMemoryWin32HandleInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExportMemoryWin32HandleInfoNv<'s> {
    pub fn builder<'b>() -> ExportMemoryWin32HandleInfoNvBuilder<'b> {
        ExportMemoryWin32HandleInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExportMemoryWin32HandleInfoNV) -> ExportMemoryWin32HandleInfoNv<'s> {
        ExportMemoryWin32HandleInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn attributes<'a>(&'a self) -> &'a SECURITY_ATTRIBUTES {
        unsafe { &*(self.raw.pAttributes as *const _) }
    }

    pub fn dw_access<'a>(&'a self) -> DWORD {
        self.raw.dwAccess.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_attributes<'m, 'a>(&mut self, attributes: &'a SECURITY_ATTRIBUTES) {
        self.raw.pAttributes = attributes;
    }

    pub fn set_dw_access<'m>(&mut self, dw_access: DWORD) {
        self.raw.dwAccess = dw_access.into();
    }

    pub fn as_raw(&self) -> &vks::VkExportMemoryWin32HandleInfoNV {
        &self.raw
    }
}

impl<'s> From<ExportMemoryWin32HandleInfoNv<'s>> for vks::VkExportMemoryWin32HandleInfoNV {
    fn from(f: ExportMemoryWin32HandleInfoNv<'s>) -> vks::VkExportMemoryWin32HandleInfoNV {
        f.raw
    }
}


/// A builder for `VkExportMemoryWin32HandleInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExportMemoryWin32HandleInfoNvBuilder<'b> {
    raw: vks::VkExportMemoryWin32HandleInfoNV,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ExportMemoryWin32HandleInfoNvBuilder<'b> {
    pub fn new() -> ExportMemoryWin32HandleInfoNvBuilder<'b> {
        ExportMemoryWin32HandleInfoNvBuilder {
            raw: vks::VkExportMemoryWin32HandleInfoNV::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExportMemoryWin32HandleInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn attributes<'m, 'a>(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> ExportMemoryWin32HandleInfoNvBuilder<'b> {
        self.raw.pAttributes = attributes;
        self
    }

    pub fn dw_access<'m>(mut self, dw_access: DWORD) -> ExportMemoryWin32HandleInfoNvBuilder<'b> {
        self.raw.dwAccess = dw_access.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_attributes<'a>(&'a self) -> &'a SECURITY_ATTRIBUTES {
        unsafe { &*(self.raw.pAttributes as *const _) }
    }

    pub fn get_dw_access<'a>(&'a self) -> DWORD {
        self.raw.dwAccess.into()
    }

    pub fn build(self) -> ExportMemoryWin32HandleInfoNv<'b> {
        ExportMemoryWin32HandleInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkWin32KeyedMutexAcquireReleaseInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct Win32KeyedMutexAcquireReleaseInfoNv<'s> {
    raw: vks::VkWin32KeyedMutexAcquireReleaseInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> Win32KeyedMutexAcquireReleaseInfoNv<'s> {
    pub fn builder<'b>() -> Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b> {
        Win32KeyedMutexAcquireReleaseInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkWin32KeyedMutexAcquireReleaseInfoNV) -> Win32KeyedMutexAcquireReleaseInfoNv<'s> {
        Win32KeyedMutexAcquireReleaseInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn acquire_syncs<'a>(&'a self) -> &'a [vks::VkDeviceMemory] {
        unsafe { slice::from_raw_parts(self.raw.pAcquireSyncs as *const _, self.raw.acquireCount as usize) }
    }

    pub fn acquire_keys<'a>(&'a self) -> &'a [u64] {
        unsafe { slice::from_raw_parts(self.raw.pAcquireKeys as *const _, self.raw.acquireCount as usize) }
    }

    pub fn acquire_timeout_milliseconds<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pAcquireTimeoutMilliseconds as *const _, self.raw.acquireCount as usize) }
    }

    pub fn release_syncs<'a>(&'a self) -> &'a [vks::VkDeviceMemory] {
        unsafe { slice::from_raw_parts(self.raw.pReleaseSyncs as *const _, self.raw.releaseCount as usize) }
    }

    pub fn release_keys<'a>(&'a self) -> &'a [u64] {
        unsafe { slice::from_raw_parts(self.raw.pReleaseKeys as *const _, self.raw.releaseCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_acquire_syncs<'m, 'a>(&mut self, acquire_syncs: &'a [DeviceMemoryHandle])
            where 'a: 's {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_syncs.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::acquire_syncs`.");
        self.raw.acquireCount = acquire_syncs.len() as _;
        self.raw.pAcquireSyncs = acquire_syncs.as_ptr() as *const vks::VkDeviceMemory;
    }

    pub fn set_acquire_keys<'m, 'a>(&mut self, acquire_keys: &'a [u64])
            where 'a: 's {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_keys.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::acquire_keys`.");
        self.raw.acquireCount = acquire_keys.len() as _;
        self.raw.pAcquireKeys = acquire_keys.as_ptr() as *const u64 as *const _;
    }

    pub fn set_acquire_timeout_milliseconds<'m, 'a>(&mut self, acquire_timeout_milliseconds: &'a [u32])
            where 'a: 's {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_timeout_milliseconds.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::acquire_timeout_milliseconds`.");
        self.raw.acquireCount = acquire_timeout_milliseconds.len() as _;
        self.raw.pAcquireTimeoutMilliseconds = acquire_timeout_milliseconds.as_ptr() as *const u32 as *const _;
    }

    pub fn set_release_syncs<'m, 'a>(&mut self, release_syncs: &'a [DeviceMemoryHandle])
            where 'a: 's {
        assert!(self.raw.releaseCount == 0 || self.raw.releaseCount == release_syncs.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::release_syncs`.");
        self.raw.releaseCount = release_syncs.len() as _;
        self.raw.pReleaseSyncs = release_syncs.as_ptr() as *const vks::VkDeviceMemory;
    }

    pub fn set_release_keys<'m, 'a>(&mut self, release_keys: &'a [u64])
            where 'a: 's {
        assert!(self.raw.releaseCount == 0 || self.raw.releaseCount == release_keys.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::release_keys`.");
        self.raw.releaseCount = release_keys.len() as _;
        self.raw.pReleaseKeys = release_keys.as_ptr() as *const u64 as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkWin32KeyedMutexAcquireReleaseInfoNV {
        &self.raw
    }
}

impl<'s> From<Win32KeyedMutexAcquireReleaseInfoNv<'s>> for vks::VkWin32KeyedMutexAcquireReleaseInfoNV {
    fn from(f: Win32KeyedMutexAcquireReleaseInfoNv<'s>) -> vks::VkWin32KeyedMutexAcquireReleaseInfoNV {
        f.raw
    }
}


/// A builder for `VkWin32KeyedMutexAcquireReleaseInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b> {
    raw: vks::VkWin32KeyedMutexAcquireReleaseInfoNV,
    _p: PhantomData<&'b ()>, 
}

impl<'b> Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b> {
    pub fn new() -> Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b> {
        Win32KeyedMutexAcquireReleaseInfoNvBuilder {
            raw: vks::VkWin32KeyedMutexAcquireReleaseInfoNV::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn acquire_syncs<'m, 'a>(mut self, acquire_syncs: &'a [DeviceMemoryHandle]) -> Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_syncs.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::acquire_syncs`.");
        self.raw.acquireCount = acquire_syncs.len() as _;
        self.raw.pAcquireSyncs = acquire_syncs.as_ptr() as *const vks::VkDeviceMemory;
        self
    }

    pub fn acquire_keys<'m, 'a>(mut self, acquire_keys: &'a [u64]) -> Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_keys.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::acquire_keys`.");
        self.raw.acquireCount = acquire_keys.len() as _;
        self.raw.pAcquireKeys = acquire_keys.as_ptr() as *const u64 as *const _;
        self
    }

    pub fn acquire_timeout_milliseconds<'m, 'a>(mut self, acquire_timeout_milliseconds: &'a [u32]) -> Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_timeout_milliseconds.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::acquire_timeout_milliseconds`.");
        self.raw.acquireCount = acquire_timeout_milliseconds.len() as _;
        self.raw.pAcquireTimeoutMilliseconds = acquire_timeout_milliseconds.as_ptr() as *const u32 as *const _;
        self
    }

    pub fn release_syncs<'m, 'a>(mut self, release_syncs: &'a [DeviceMemoryHandle]) -> Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.releaseCount == 0 || self.raw.releaseCount == release_syncs.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::release_syncs`.");
        self.raw.releaseCount = release_syncs.len() as _;
        self.raw.pReleaseSyncs = release_syncs.as_ptr() as *const vks::VkDeviceMemory;
        self
    }

    pub fn release_keys<'m, 'a>(mut self, release_keys: &'a [u64]) -> Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.releaseCount == 0 || self.raw.releaseCount == release_keys.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::release_keys`.");
        self.raw.releaseCount = release_keys.len() as _;
        self.raw.pReleaseKeys = release_keys.as_ptr() as *const u64 as *const _;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_acquire_syncs<'a>(&'a self) -> &'a [vks::VkDeviceMemory] {
        unsafe { slice::from_raw_parts(self.raw.pAcquireSyncs as *const _, self.raw.acquireCount as usize) }
    }

    pub fn get_acquire_keys<'a>(&'a self) -> &'a [u64] {
        unsafe { slice::from_raw_parts(self.raw.pAcquireKeys as *const _, self.raw.acquireCount as usize) }
    }

    pub fn get_acquire_timeout_milliseconds<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pAcquireTimeoutMilliseconds as *const _, self.raw.acquireCount as usize) }
    }

    pub fn get_release_syncs<'a>(&'a self) -> &'a [vks::VkDeviceMemory] {
        unsafe { slice::from_raw_parts(self.raw.pReleaseSyncs as *const _, self.raw.releaseCount as usize) }
    }

    pub fn get_release_keys<'a>(&'a self) -> &'a [u64] {
        unsafe { slice::from_raw_parts(self.raw.pReleaseKeys as *const _, self.raw.releaseCount as usize) }
    }

    pub fn build(self) -> Win32KeyedMutexAcquireReleaseInfoNv<'b> {
        Win32KeyedMutexAcquireReleaseInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceGeneratedCommandsFeaturesNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceGeneratedCommandsFeaturesNvx<'s> {
    raw: vks::VkDeviceGeneratedCommandsFeaturesNVX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> DeviceGeneratedCommandsFeaturesNvx<'s> {
    pub fn builder<'b>() -> DeviceGeneratedCommandsFeaturesNvxBuilder<'b> {
        DeviceGeneratedCommandsFeaturesNvxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceGeneratedCommandsFeaturesNVX) -> DeviceGeneratedCommandsFeaturesNvx<'s> {
        DeviceGeneratedCommandsFeaturesNvx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn compute_binding_point_support<'a>(&'a self) -> bool {
        self.raw.computeBindingPointSupport != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_compute_binding_point_support<'m>(&mut self, compute_binding_point_support: bool) {
        self.raw.computeBindingPointSupport = compute_binding_point_support as u32;
    }

    pub fn as_raw(&self) -> &vks::VkDeviceGeneratedCommandsFeaturesNVX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<DeviceGeneratedCommandsFeaturesNvx<'s>> for vks::VkDeviceGeneratedCommandsFeaturesNVX {
    fn from(f: DeviceGeneratedCommandsFeaturesNvx<'s>) -> vks::VkDeviceGeneratedCommandsFeaturesNVX {
        f.raw
    }
}


/// A builder for `VkDeviceGeneratedCommandsFeaturesNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct DeviceGeneratedCommandsFeaturesNvxBuilder<'b> {
    raw: vks::VkDeviceGeneratedCommandsFeaturesNVX,
    _p: PhantomData<&'b ()>, 
}

#[cfg(feature = "experimental")]
impl<'b> DeviceGeneratedCommandsFeaturesNvxBuilder<'b> {
    pub fn new() -> DeviceGeneratedCommandsFeaturesNvxBuilder<'b> {
        DeviceGeneratedCommandsFeaturesNvxBuilder {
            raw: vks::VkDeviceGeneratedCommandsFeaturesNVX::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceGeneratedCommandsFeaturesNvxBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn compute_binding_point_support<'m>(mut self, compute_binding_point_support: bool) -> DeviceGeneratedCommandsFeaturesNvxBuilder<'b> {
        self.raw.computeBindingPointSupport = compute_binding_point_support as u32;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_compute_binding_point_support<'a>(&'a self) -> bool {
        self.raw.computeBindingPointSupport != 0
    }

    pub fn build(self) -> DeviceGeneratedCommandsFeaturesNvx<'b> {
        DeviceGeneratedCommandsFeaturesNvx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceGeneratedCommandsLimitsNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceGeneratedCommandsLimitsNvx<'s> {
    raw: vks::VkDeviceGeneratedCommandsLimitsNVX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> DeviceGeneratedCommandsLimitsNvx<'s> {
    pub fn builder<'b>() -> DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
        DeviceGeneratedCommandsLimitsNvxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceGeneratedCommandsLimitsNVX) -> DeviceGeneratedCommandsLimitsNvx<'s> {
        DeviceGeneratedCommandsLimitsNvx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn max_indirect_commands_layout_token_count<'a>(&'a self) -> u32 {
        self.raw.maxIndirectCommandsLayoutTokenCount.into()
    }

    pub fn max_object_entry_counts<'a>(&'a self) -> u32 {
        self.raw.maxObjectEntryCounts.into()
    }

    pub fn min_sequence_count_buffer_offset_alignment<'a>(&'a self) -> u32 {
        self.raw.minSequenceCountBufferOffsetAlignment.into()
    }

    pub fn min_sequence_index_buffer_offset_alignment<'a>(&'a self) -> u32 {
        self.raw.minSequenceIndexBufferOffsetAlignment.into()
    }

    pub fn min_commands_token_buffer_offset_alignment<'a>(&'a self) -> u32 {
        self.raw.minCommandsTokenBufferOffsetAlignment.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_max_indirect_commands_layout_token_count<'m>(&mut self, max_indirect_commands_layout_token_count: u32) {
        self.raw.maxIndirectCommandsLayoutTokenCount = max_indirect_commands_layout_token_count.into();
    }

    pub fn set_max_object_entry_counts<'m>(&mut self, max_object_entry_counts: u32) {
        self.raw.maxObjectEntryCounts = max_object_entry_counts.into();
    }

    pub fn set_min_sequence_count_buffer_offset_alignment<'m>(&mut self, min_sequence_count_buffer_offset_alignment: u32) {
        self.raw.minSequenceCountBufferOffsetAlignment = min_sequence_count_buffer_offset_alignment.into();
    }

    pub fn set_min_sequence_index_buffer_offset_alignment<'m>(&mut self, min_sequence_index_buffer_offset_alignment: u32) {
        self.raw.minSequenceIndexBufferOffsetAlignment = min_sequence_index_buffer_offset_alignment.into();
    }

    pub fn set_min_commands_token_buffer_offset_alignment<'m>(&mut self, min_commands_token_buffer_offset_alignment: u32) {
        self.raw.minCommandsTokenBufferOffsetAlignment = min_commands_token_buffer_offset_alignment.into();
    }

    pub fn as_raw(&self) -> &vks::VkDeviceGeneratedCommandsLimitsNVX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<DeviceGeneratedCommandsLimitsNvx<'s>> for vks::VkDeviceGeneratedCommandsLimitsNVX {
    fn from(f: DeviceGeneratedCommandsLimitsNvx<'s>) -> vks::VkDeviceGeneratedCommandsLimitsNVX {
        f.raw
    }
}


/// A builder for `VkDeviceGeneratedCommandsLimitsNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
    raw: vks::VkDeviceGeneratedCommandsLimitsNVX,
    _p: PhantomData<&'b ()>, 
}

#[cfg(feature = "experimental")]
impl<'b> DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
    pub fn new() -> DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
        DeviceGeneratedCommandsLimitsNvxBuilder {
            raw: vks::VkDeviceGeneratedCommandsLimitsNVX::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn max_indirect_commands_layout_token_count<'m>(mut self, max_indirect_commands_layout_token_count: u32) -> DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
        self.raw.maxIndirectCommandsLayoutTokenCount = max_indirect_commands_layout_token_count.into();
        self
    }

    pub fn max_object_entry_counts<'m>(mut self, max_object_entry_counts: u32) -> DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
        self.raw.maxObjectEntryCounts = max_object_entry_counts.into();
        self
    }

    pub fn min_sequence_count_buffer_offset_alignment<'m>(mut self, min_sequence_count_buffer_offset_alignment: u32) -> DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
        self.raw.minSequenceCountBufferOffsetAlignment = min_sequence_count_buffer_offset_alignment.into();
        self
    }

    pub fn min_sequence_index_buffer_offset_alignment<'m>(mut self, min_sequence_index_buffer_offset_alignment: u32) -> DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
        self.raw.minSequenceIndexBufferOffsetAlignment = min_sequence_index_buffer_offset_alignment.into();
        self
    }

    pub fn min_commands_token_buffer_offset_alignment<'m>(mut self, min_commands_token_buffer_offset_alignment: u32) -> DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
        self.raw.minCommandsTokenBufferOffsetAlignment = min_commands_token_buffer_offset_alignment.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_max_indirect_commands_layout_token_count<'a>(&'a self) -> u32 {
        self.raw.maxIndirectCommandsLayoutTokenCount.into()
    }

    pub fn get_max_object_entry_counts<'a>(&'a self) -> u32 {
        self.raw.maxObjectEntryCounts.into()
    }

    pub fn get_min_sequence_count_buffer_offset_alignment<'a>(&'a self) -> u32 {
        self.raw.minSequenceCountBufferOffsetAlignment.into()
    }

    pub fn get_min_sequence_index_buffer_offset_alignment<'a>(&'a self) -> u32 {
        self.raw.minSequenceIndexBufferOffsetAlignment.into()
    }

    pub fn get_min_commands_token_buffer_offset_alignment<'a>(&'a self) -> u32 {
        self.raw.minCommandsTokenBufferOffsetAlignment.into()
    }

    pub fn build(self) -> DeviceGeneratedCommandsLimitsNvx<'b> {
        DeviceGeneratedCommandsLimitsNvx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkCmdReserveSpaceForCommandsInfoNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct CmdReserveSpaceForCommandsInfoNvx<'s> {
    raw: vks::VkCmdReserveSpaceForCommandsInfoNVX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> CmdReserveSpaceForCommandsInfoNvx<'s> {
    pub fn builder<'b>() -> CmdReserveSpaceForCommandsInfoNvxBuilder<'b> {
        CmdReserveSpaceForCommandsInfoNvxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkCmdReserveSpaceForCommandsInfoNVX) -> CmdReserveSpaceForCommandsInfoNvx<'s> {
        CmdReserveSpaceForCommandsInfoNvx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn object_table<'a>(&'a self) -> vks::VkObjectTableNVX {
        self.raw.objectTable
    }

    pub fn indirect_commands_layout<'a>(&'a self) -> vks::VkIndirectCommandsLayoutNVX {
        self.raw.indirectCommandsLayout
    }

    pub fn max_sequences_count<'a>(&'a self) -> u32 {
        self.raw.maxSequencesCount.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_object_table<'m, H>(&mut self, object_table: H)
            where H: Handle<Target=ObjectTableNvxHandle> {
        self.raw.objectTable = object_table.handle().0;
    }

    pub fn set_indirect_commands_layout<'m, H>(&mut self, indirect_commands_layout: H)
            where H: Handle<Target=IndirectCommandsLayoutNvxHandle> {
        self.raw.indirectCommandsLayout = indirect_commands_layout.handle().0;
    }

    pub fn set_max_sequences_count<'m>(&mut self, max_sequences_count: u32) {
        self.raw.maxSequencesCount = max_sequences_count.into();
    }

    pub fn as_raw(&self) -> &vks::VkCmdReserveSpaceForCommandsInfoNVX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<CmdReserveSpaceForCommandsInfoNvx<'s>> for vks::VkCmdReserveSpaceForCommandsInfoNVX {
    fn from(f: CmdReserveSpaceForCommandsInfoNvx<'s>) -> vks::VkCmdReserveSpaceForCommandsInfoNVX {
        f.raw
    }
}


/// A builder for `VkCmdReserveSpaceForCommandsInfoNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct CmdReserveSpaceForCommandsInfoNvxBuilder<'b> {
    raw: vks::VkCmdReserveSpaceForCommandsInfoNVX,
    _p: PhantomData<&'b ()>, 
}

#[cfg(feature = "experimental")]
impl<'b> CmdReserveSpaceForCommandsInfoNvxBuilder<'b> {
    pub fn new() -> CmdReserveSpaceForCommandsInfoNvxBuilder<'b> {
        CmdReserveSpaceForCommandsInfoNvxBuilder {
            raw: vks::VkCmdReserveSpaceForCommandsInfoNVX::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> CmdReserveSpaceForCommandsInfoNvxBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn object_table<'m, H>(mut self, object_table: H) -> CmdReserveSpaceForCommandsInfoNvxBuilder<'b>
            where H: Handle<Target=ObjectTableNvxHandle> {
        self.raw.objectTable = object_table.handle().0;
        self
    }

    pub fn indirect_commands_layout<'m, H>(mut self, indirect_commands_layout: H) -> CmdReserveSpaceForCommandsInfoNvxBuilder<'b>
            where H: Handle<Target=IndirectCommandsLayoutNvxHandle> {
        self.raw.indirectCommandsLayout = indirect_commands_layout.handle().0;
        self
    }

    pub fn max_sequences_count<'m>(mut self, max_sequences_count: u32) -> CmdReserveSpaceForCommandsInfoNvxBuilder<'b> {
        self.raw.maxSequencesCount = max_sequences_count.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_object_table<'a>(&'a self) -> vks::VkObjectTableNVX {
        self.raw.objectTable
    }

    pub fn get_indirect_commands_layout<'a>(&'a self) -> vks::VkIndirectCommandsLayoutNVX {
        self.raw.indirectCommandsLayout
    }

    pub fn get_max_sequences_count<'a>(&'a self) -> u32 {
        self.raw.maxSequencesCount.into()
    }

    pub fn build(self) -> CmdReserveSpaceForCommandsInfoNvx<'b> {
        CmdReserveSpaceForCommandsInfoNvx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkObjectTableDescriptorSetEntryNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ObjectTableDescriptorSetEntryNvx {
    raw: vks::VkObjectTableDescriptorSetEntryNVX,
}

#[cfg(feature = "experimental")]
impl ObjectTableDescriptorSetEntryNvx {
    pub fn builder() -> ObjectTableDescriptorSetEntryNvxBuilder {
        ObjectTableDescriptorSetEntryNvxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkObjectTableDescriptorSetEntryNVX) -> ObjectTableDescriptorSetEntryNvx {
        ObjectTableDescriptorSetEntryNvx { raw, }
    }

    pub fn type_of<'a>(&'a self) -> ObjectEntryTypeNvx {
        self.raw.type_.into()
    }

    pub fn flags<'a>(&'a self) -> ObjectEntryUsageFlagsNvx {
        ObjectEntryUsageFlagsNvx::from_bits(self.raw.flags)
            .expect("ObjectTableDescriptorSetEntryNvx::flags: error converting flags")
    }

    pub fn pipeline_layout<'a>(&'a self) -> vks::VkPipelineLayout {
        self.raw.pipelineLayout
    }

    pub fn descriptor_set<'a>(&'a self) -> vks::VkDescriptorSet {
        self.raw.descriptorSet
    }

    pub fn set_type_of<'m>(&mut self, type_of: ObjectEntryTypeNvx) {
        self.raw.type_ = type_of.into();
    }

    pub fn set_flags<'m>(&mut self, flags: ObjectEntryUsageFlagsNvx) {
        self.raw.flags = flags.bits();
    }

    pub fn set_pipeline_layout<'m, H>(&mut self, pipeline_layout: H)
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.pipelineLayout = pipeline_layout.handle().0;
    }

    pub fn set_descriptor_set<'m, H>(&mut self, descriptor_set: H)
            where H: Handle<Target=DescriptorSetHandle> {
        self.raw.descriptorSet = descriptor_set.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkObjectTableDescriptorSetEntryNVX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl From<ObjectTableDescriptorSetEntryNvx> for vks::VkObjectTableDescriptorSetEntryNVX {
    fn from(f: ObjectTableDescriptorSetEntryNvx) -> vks::VkObjectTableDescriptorSetEntryNVX {
        f.raw
    }
}


/// A builder for `VkObjectTableDescriptorSetEntryNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct ObjectTableDescriptorSetEntryNvxBuilder {
    raw: vks::VkObjectTableDescriptorSetEntryNVX,
}

#[cfg(feature = "experimental")]
impl ObjectTableDescriptorSetEntryNvxBuilder {
    pub fn new() -> ObjectTableDescriptorSetEntryNvxBuilder {
        ObjectTableDescriptorSetEntryNvxBuilder {
            raw: vks::VkObjectTableDescriptorSetEntryNVX::default(),
        }
    }

    pub fn type_of<'m>(mut self, type_of: ObjectEntryTypeNvx) -> ObjectTableDescriptorSetEntryNvxBuilder {
        self.raw.type_ = type_of.into();
        self
    }

    pub fn flags<'m>(mut self, flags: ObjectEntryUsageFlagsNvx) -> ObjectTableDescriptorSetEntryNvxBuilder {
        self.raw.flags = flags.bits();
        self
    }

    pub fn pipeline_layout<'m, H>(mut self, pipeline_layout: H) -> ObjectTableDescriptorSetEntryNvxBuilder
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.pipelineLayout = pipeline_layout.handle().0;
        self
    }

    pub fn descriptor_set<'m, H>(mut self, descriptor_set: H) -> ObjectTableDescriptorSetEntryNvxBuilder
            where H: Handle<Target=DescriptorSetHandle> {
        self.raw.descriptorSet = descriptor_set.handle().0;
        self
    }

    pub fn get_type_of<'a>(&'a self) -> ObjectEntryTypeNvx {
        self.raw.type_.into()
    }

    pub fn get_flags<'a>(&'a self) -> ObjectEntryUsageFlagsNvx {
        ObjectEntryUsageFlagsNvx::from_bits(self.raw.flags)
            .expect("ObjectTableDescriptorSetEntryNvx::flags: error converting flags")
    }

    pub fn get_pipeline_layout<'a>(&'a self) -> vks::VkPipelineLayout {
        self.raw.pipelineLayout
    }

    pub fn get_descriptor_set<'a>(&'a self) -> vks::VkDescriptorSet {
        self.raw.descriptorSet
    }

    pub fn build(self) -> ObjectTableDescriptorSetEntryNvx {
        ObjectTableDescriptorSetEntryNvx {
            raw: self.raw,
        }
    }
}


/// A `VkObjectTableVertexBufferEntryNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ObjectTableVertexBufferEntryNvx {
    raw: vks::VkObjectTableVertexBufferEntryNVX,
}

#[cfg(feature = "experimental")]
impl ObjectTableVertexBufferEntryNvx {
    pub fn builder() -> ObjectTableVertexBufferEntryNvxBuilder {
        ObjectTableVertexBufferEntryNvxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkObjectTableVertexBufferEntryNVX) -> ObjectTableVertexBufferEntryNvx {
        ObjectTableVertexBufferEntryNvx { raw, }
    }

    pub fn type_of<'a>(&'a self) -> ObjectEntryTypeNvx {
        self.raw.type_.into()
    }

    pub fn flags<'a>(&'a self) -> ObjectEntryUsageFlagsNvx {
        ObjectEntryUsageFlagsNvx::from_bits(self.raw.flags)
            .expect("ObjectTableVertexBufferEntryNvx::flags: error converting flags")
    }

    pub fn buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn set_type_of<'m>(&mut self, type_of: ObjectEntryTypeNvx) {
        self.raw.type_ = type_of.into();
    }

    pub fn set_flags<'m>(&mut self, flags: ObjectEntryUsageFlagsNvx) {
        self.raw.flags = flags.bits();
    }

    pub fn set_buffer<'m, H>(&mut self, buffer: H)
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkObjectTableVertexBufferEntryNVX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl From<ObjectTableVertexBufferEntryNvx> for vks::VkObjectTableVertexBufferEntryNVX {
    fn from(f: ObjectTableVertexBufferEntryNvx) -> vks::VkObjectTableVertexBufferEntryNVX {
        f.raw
    }
}


/// A builder for `VkObjectTableVertexBufferEntryNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct ObjectTableVertexBufferEntryNvxBuilder {
    raw: vks::VkObjectTableVertexBufferEntryNVX,
}

#[cfg(feature = "experimental")]
impl ObjectTableVertexBufferEntryNvxBuilder {
    pub fn new() -> ObjectTableVertexBufferEntryNvxBuilder {
        ObjectTableVertexBufferEntryNvxBuilder {
            raw: vks::VkObjectTableVertexBufferEntryNVX::default(),
        }
    }

    pub fn type_of<'m>(mut self, type_of: ObjectEntryTypeNvx) -> ObjectTableVertexBufferEntryNvxBuilder {
        self.raw.type_ = type_of.into();
        self
    }

    pub fn flags<'m>(mut self, flags: ObjectEntryUsageFlagsNvx) -> ObjectTableVertexBufferEntryNvxBuilder {
        self.raw.flags = flags.bits();
        self
    }

    pub fn buffer<'m, H>(mut self, buffer: H) -> ObjectTableVertexBufferEntryNvxBuilder
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
        self
    }

    pub fn get_type_of<'a>(&'a self) -> ObjectEntryTypeNvx {
        self.raw.type_.into()
    }

    pub fn get_flags<'a>(&'a self) -> ObjectEntryUsageFlagsNvx {
        ObjectEntryUsageFlagsNvx::from_bits(self.raw.flags)
            .expect("ObjectTableVertexBufferEntryNvx::flags: error converting flags")
    }

    pub fn get_buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn build(self) -> ObjectTableVertexBufferEntryNvx {
        ObjectTableVertexBufferEntryNvx {
            raw: self.raw,
        }
    }
}


/// A `VkObjectTableIndexBufferEntryNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ObjectTableIndexBufferEntryNvx {
    raw: vks::VkObjectTableIndexBufferEntryNVX,
}

#[cfg(feature = "experimental")]
impl ObjectTableIndexBufferEntryNvx {
    pub fn builder() -> ObjectTableIndexBufferEntryNvxBuilder {
        ObjectTableIndexBufferEntryNvxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkObjectTableIndexBufferEntryNVX) -> ObjectTableIndexBufferEntryNvx {
        ObjectTableIndexBufferEntryNvx { raw, }
    }

    pub fn type_of<'a>(&'a self) -> ObjectEntryTypeNvx {
        self.raw.type_.into()
    }

    pub fn flags<'a>(&'a self) -> ObjectEntryUsageFlagsNvx {
        ObjectEntryUsageFlagsNvx::from_bits(self.raw.flags)
            .expect("ObjectTableIndexBufferEntryNvx::flags: error converting flags")
    }

    pub fn buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn index_type<'a>(&'a self) -> IndexType {
        self.raw.indexType.into()
    }

    pub fn set_type_of<'m>(&mut self, type_of: ObjectEntryTypeNvx) {
        self.raw.type_ = type_of.into();
    }

    pub fn set_flags<'m>(&mut self, flags: ObjectEntryUsageFlagsNvx) {
        self.raw.flags = flags.bits();
    }

    pub fn set_buffer<'m, H>(&mut self, buffer: H)
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
    }

    pub fn set_index_type<'m>(&mut self, index_type: IndexType) {
        self.raw.indexType = index_type.into();
    }

    pub fn as_raw(&self) -> &vks::VkObjectTableIndexBufferEntryNVX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl From<ObjectTableIndexBufferEntryNvx> for vks::VkObjectTableIndexBufferEntryNVX {
    fn from(f: ObjectTableIndexBufferEntryNvx) -> vks::VkObjectTableIndexBufferEntryNVX {
        f.raw
    }
}


/// A builder for `VkObjectTableIndexBufferEntryNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct ObjectTableIndexBufferEntryNvxBuilder {
    raw: vks::VkObjectTableIndexBufferEntryNVX,
}

#[cfg(feature = "experimental")]
impl ObjectTableIndexBufferEntryNvxBuilder {
    pub fn new() -> ObjectTableIndexBufferEntryNvxBuilder {
        ObjectTableIndexBufferEntryNvxBuilder {
            raw: vks::VkObjectTableIndexBufferEntryNVX::default(),
        }
    }

    pub fn type_of<'m>(mut self, type_of: ObjectEntryTypeNvx) -> ObjectTableIndexBufferEntryNvxBuilder {
        self.raw.type_ = type_of.into();
        self
    }

    pub fn flags<'m>(mut self, flags: ObjectEntryUsageFlagsNvx) -> ObjectTableIndexBufferEntryNvxBuilder {
        self.raw.flags = flags.bits();
        self
    }

    pub fn buffer<'m, H>(mut self, buffer: H) -> ObjectTableIndexBufferEntryNvxBuilder
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
        self
    }

    pub fn index_type<'m>(mut self, index_type: IndexType) -> ObjectTableIndexBufferEntryNvxBuilder {
        self.raw.indexType = index_type.into();
        self
    }

    pub fn get_type_of<'a>(&'a self) -> ObjectEntryTypeNvx {
        self.raw.type_.into()
    }

    pub fn get_flags<'a>(&'a self) -> ObjectEntryUsageFlagsNvx {
        ObjectEntryUsageFlagsNvx::from_bits(self.raw.flags)
            .expect("ObjectTableIndexBufferEntryNvx::flags: error converting flags")
    }

    pub fn get_buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn get_index_type<'a>(&'a self) -> IndexType {
        self.raw.indexType.into()
    }

    pub fn build(self) -> ObjectTableIndexBufferEntryNvx {
        ObjectTableIndexBufferEntryNvx {
            raw: self.raw,
        }
    }
}


/// A `VkObjectTablePushConstantEntryNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ObjectTablePushConstantEntryNvx {
    raw: vks::VkObjectTablePushConstantEntryNVX,
}

#[cfg(feature = "experimental")]
impl ObjectTablePushConstantEntryNvx {
    pub fn builder() -> ObjectTablePushConstantEntryNvxBuilder {
        ObjectTablePushConstantEntryNvxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkObjectTablePushConstantEntryNVX) -> ObjectTablePushConstantEntryNvx {
        ObjectTablePushConstantEntryNvx { raw, }
    }

    pub fn type_of<'a>(&'a self) -> ObjectEntryTypeNvx {
        self.raw.type_.into()
    }

    pub fn flags<'a>(&'a self) -> ObjectEntryUsageFlagsNvx {
        ObjectEntryUsageFlagsNvx::from_bits(self.raw.flags)
            .expect("ObjectTablePushConstantEntryNvx::flags: error converting flags")
    }

    pub fn pipeline_layout<'a>(&'a self) -> vks::VkPipelineLayout {
        self.raw.pipelineLayout
    }

    pub fn stage_flags<'a>(&'a self) -> ShaderStageFlags {
        ShaderStageFlags::from_bits(self.raw.stageFlags)
            .expect("ObjectTablePushConstantEntryNvx::stage_flags: error converting flags")
    }

    pub fn set_type_of<'m>(&mut self, type_of: ObjectEntryTypeNvx) {
        self.raw.type_ = type_of.into();
    }

    pub fn set_flags<'m>(&mut self, flags: ObjectEntryUsageFlagsNvx) {
        self.raw.flags = flags.bits();
    }

    pub fn set_pipeline_layout<'m, H>(&mut self, pipeline_layout: H)
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.pipelineLayout = pipeline_layout.handle().0;
    }

    pub fn set_stage_flags<'m>(&mut self, stage_flags: ShaderStageFlags) {
        self.raw.stageFlags = stage_flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkObjectTablePushConstantEntryNVX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl From<ObjectTablePushConstantEntryNvx> for vks::VkObjectTablePushConstantEntryNVX {
    fn from(f: ObjectTablePushConstantEntryNvx) -> vks::VkObjectTablePushConstantEntryNVX {
        f.raw
    }
}


/// A builder for `VkObjectTablePushConstantEntryNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct ObjectTablePushConstantEntryNvxBuilder {
    raw: vks::VkObjectTablePushConstantEntryNVX,
}

#[cfg(feature = "experimental")]
impl ObjectTablePushConstantEntryNvxBuilder {
    pub fn new() -> ObjectTablePushConstantEntryNvxBuilder {
        ObjectTablePushConstantEntryNvxBuilder {
            raw: vks::VkObjectTablePushConstantEntryNVX::default(),
        }
    }

    pub fn type_of<'m>(mut self, type_of: ObjectEntryTypeNvx) -> ObjectTablePushConstantEntryNvxBuilder {
        self.raw.type_ = type_of.into();
        self
    }

    pub fn flags<'m>(mut self, flags: ObjectEntryUsageFlagsNvx) -> ObjectTablePushConstantEntryNvxBuilder {
        self.raw.flags = flags.bits();
        self
    }

    pub fn pipeline_layout<'m, H>(mut self, pipeline_layout: H) -> ObjectTablePushConstantEntryNvxBuilder
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.pipelineLayout = pipeline_layout.handle().0;
        self
    }

    pub fn stage_flags<'m>(mut self, stage_flags: ShaderStageFlags) -> ObjectTablePushConstantEntryNvxBuilder {
        self.raw.stageFlags = stage_flags.bits();
        self
    }

    pub fn get_type_of<'a>(&'a self) -> ObjectEntryTypeNvx {
        self.raw.type_.into()
    }

    pub fn get_flags<'a>(&'a self) -> ObjectEntryUsageFlagsNvx {
        ObjectEntryUsageFlagsNvx::from_bits(self.raw.flags)
            .expect("ObjectTablePushConstantEntryNvx::flags: error converting flags")
    }

    pub fn get_pipeline_layout<'a>(&'a self) -> vks::VkPipelineLayout {
        self.raw.pipelineLayout
    }

    pub fn get_stage_flags<'a>(&'a self) -> ShaderStageFlags {
        ShaderStageFlags::from_bits(self.raw.stageFlags)
            .expect("ObjectTablePushConstantEntryNvx::stage_flags: error converting flags")
    }

    pub fn build(self) -> ObjectTablePushConstantEntryNvx {
        ObjectTablePushConstantEntryNvx {
            raw: self.raw,
        }
    }
}


/// A `VkPhysicalDeviceFeatures2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceFeatures2Khr<'s> {
    raw: vks::VkPhysicalDeviceFeatures2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceFeatures2Khr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceFeatures2KhrBuilder<'b> {
        PhysicalDeviceFeatures2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceFeatures2KHR) -> PhysicalDeviceFeatures2Khr<'s> {
        PhysicalDeviceFeatures2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn features<'a>(&'a self) -> &'a PhysicalDeviceFeatures {
        unsafe { &*(&self.raw.features as *const vks::VkPhysicalDeviceFeatures as *const PhysicalDeviceFeatures) }
    }

    pub fn features_mut<'a>(&'a mut self) -> &'a mut PhysicalDeviceFeatures {
        unsafe { &mut *(&mut self.raw.features as *mut  vks::VkPhysicalDeviceFeatures as *mut PhysicalDeviceFeatures) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_features<'m>(&mut self, features: PhysicalDeviceFeatures) {
        self.raw.features = features.raw;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceFeatures2KHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceFeatures2Khr<'s>> for vks::VkPhysicalDeviceFeatures2KHR {
    fn from(f: PhysicalDeviceFeatures2Khr<'s>) -> vks::VkPhysicalDeviceFeatures2KHR {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceFeatures2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceFeatures2KhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceFeatures2KHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PhysicalDeviceFeatures2KhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceFeatures2KhrBuilder<'b> {
        PhysicalDeviceFeatures2KhrBuilder {
            raw: vks::VkPhysicalDeviceFeatures2KHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceFeatures2KhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn features<'m>(mut self, features: PhysicalDeviceFeatures) -> PhysicalDeviceFeatures2KhrBuilder<'b> {
        self.raw.features = features.raw;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_features<'a>(&'a self) -> &'a PhysicalDeviceFeatures {
        unsafe { &*(&self.raw.features as *const vks::VkPhysicalDeviceFeatures as *const PhysicalDeviceFeatures) }
    }

    pub fn get_features_mut<'a>(&'a mut self) -> &'a mut PhysicalDeviceFeatures {
        unsafe { &mut *(&mut self.raw.features as *mut  vks::VkPhysicalDeviceFeatures as *mut PhysicalDeviceFeatures) }
    }

    pub fn build(self) -> PhysicalDeviceFeatures2Khr<'b> {
        PhysicalDeviceFeatures2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceProperties2Khr<'s> {
    raw: vks::VkPhysicalDeviceProperties2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceProperties2Khr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceProperties2KhrBuilder<'b> {
        PhysicalDeviceProperties2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceProperties2KHR) -> PhysicalDeviceProperties2Khr<'s> {
        PhysicalDeviceProperties2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn properties<'a>(&'a self) -> &'a PhysicalDeviceProperties {
        unsafe { &*(&self.raw.properties as *const vks::VkPhysicalDeviceProperties as *const PhysicalDeviceProperties) }
    }

    pub fn properties_mut<'a>(&'a mut self) -> &'a mut PhysicalDeviceProperties {
        unsafe { &mut *(&mut self.raw.properties as *mut  vks::VkPhysicalDeviceProperties as *mut PhysicalDeviceProperties) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_properties<'m>(&mut self, properties: PhysicalDeviceProperties) {
        self.raw.properties = properties.raw;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceProperties2KHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceProperties2Khr<'s>> for vks::VkPhysicalDeviceProperties2KHR {
    fn from(f: PhysicalDeviceProperties2Khr<'s>) -> vks::VkPhysicalDeviceProperties2KHR {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceProperties2KhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceProperties2KHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PhysicalDeviceProperties2KhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceProperties2KhrBuilder<'b> {
        PhysicalDeviceProperties2KhrBuilder {
            raw: vks::VkPhysicalDeviceProperties2KHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceProperties2KhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn properties<'m>(mut self, properties: PhysicalDeviceProperties) -> PhysicalDeviceProperties2KhrBuilder<'b> {
        self.raw.properties = properties.raw;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_properties<'a>(&'a self) -> &'a PhysicalDeviceProperties {
        unsafe { &*(&self.raw.properties as *const vks::VkPhysicalDeviceProperties as *const PhysicalDeviceProperties) }
    }

    pub fn get_properties_mut<'a>(&'a mut self) -> &'a mut PhysicalDeviceProperties {
        unsafe { &mut *(&mut self.raw.properties as *mut  vks::VkPhysicalDeviceProperties as *mut PhysicalDeviceProperties) }
    }

    pub fn build(self) -> PhysicalDeviceProperties2Khr<'b> {
        PhysicalDeviceProperties2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkFormatProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct FormatProperties2Khr<'s> {
    raw: vks::VkFormatProperties2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> FormatProperties2Khr<'s> {
    pub fn builder<'b>() -> FormatProperties2KhrBuilder<'b> {
        FormatProperties2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkFormatProperties2KHR) -> FormatProperties2Khr<'s> {
        FormatProperties2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn format_properties<'a>(&'a self) -> &'a FormatProperties {
        unsafe { &*(&self.raw.formatProperties as *const vks::VkFormatProperties as *const FormatProperties) }
    }

    pub fn format_properties_mut<'a>(&'a mut self) -> &'a mut FormatProperties {
        unsafe { &mut *(&mut self.raw.formatProperties as *mut  vks::VkFormatProperties as *mut FormatProperties) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_format_properties<'m>(&mut self, format_properties: FormatProperties) {
        self.raw.formatProperties = format_properties.raw;
    }

    pub fn as_raw(&self) -> &vks::VkFormatProperties2KHR {
        &self.raw
    }
}

impl<'s> From<FormatProperties2Khr<'s>> for vks::VkFormatProperties2KHR {
    fn from(f: FormatProperties2Khr<'s>) -> vks::VkFormatProperties2KHR {
        f.raw
    }
}


/// A builder for `VkFormatProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct FormatProperties2KhrBuilder<'b> {
    raw: vks::VkFormatProperties2KHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> FormatProperties2KhrBuilder<'b> {
    pub fn new() -> FormatProperties2KhrBuilder<'b> {
        FormatProperties2KhrBuilder {
            raw: vks::VkFormatProperties2KHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> FormatProperties2KhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn format_properties<'m>(mut self, format_properties: FormatProperties) -> FormatProperties2KhrBuilder<'b> {
        self.raw.formatProperties = format_properties.raw;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_format_properties<'a>(&'a self) -> &'a FormatProperties {
        unsafe { &*(&self.raw.formatProperties as *const vks::VkFormatProperties as *const FormatProperties) }
    }

    pub fn get_format_properties_mut<'a>(&'a mut self) -> &'a mut FormatProperties {
        unsafe { &mut *(&mut self.raw.formatProperties as *mut  vks::VkFormatProperties as *mut FormatProperties) }
    }

    pub fn build(self) -> FormatProperties2Khr<'b> {
        FormatProperties2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImageFormatProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageFormatProperties2Khr<'s> {
    raw: vks::VkImageFormatProperties2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImageFormatProperties2Khr<'s> {
    pub fn builder<'b>() -> ImageFormatProperties2KhrBuilder<'b> {
        ImageFormatProperties2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageFormatProperties2KHR) -> ImageFormatProperties2Khr<'s> {
        ImageFormatProperties2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn image_format_properties<'a>(&'a self) -> &'a ImageFormatProperties {
        unsafe { &*(&self.raw.imageFormatProperties as *const vks::VkImageFormatProperties as *const ImageFormatProperties) }
    }

    pub fn image_format_properties_mut<'a>(&'a mut self) -> &'a mut ImageFormatProperties {
        unsafe { &mut *(&mut self.raw.imageFormatProperties as *mut  vks::VkImageFormatProperties as *mut ImageFormatProperties) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_image_format_properties<'m>(&mut self, image_format_properties: ImageFormatProperties) {
        self.raw.imageFormatProperties = image_format_properties.raw;
    }

    pub fn as_raw(&self) -> &vks::VkImageFormatProperties2KHR {
        &self.raw
    }
}

impl<'s> From<ImageFormatProperties2Khr<'s>> for vks::VkImageFormatProperties2KHR {
    fn from(f: ImageFormatProperties2Khr<'s>) -> vks::VkImageFormatProperties2KHR {
        f.raw
    }
}


/// A builder for `VkImageFormatProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageFormatProperties2KhrBuilder<'b> {
    raw: vks::VkImageFormatProperties2KHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ImageFormatProperties2KhrBuilder<'b> {
    pub fn new() -> ImageFormatProperties2KhrBuilder<'b> {
        ImageFormatProperties2KhrBuilder {
            raw: vks::VkImageFormatProperties2KHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> ImageFormatProperties2KhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn image_format_properties<'m>(mut self, image_format_properties: ImageFormatProperties) -> ImageFormatProperties2KhrBuilder<'b> {
        self.raw.imageFormatProperties = image_format_properties.raw;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_image_format_properties<'a>(&'a self) -> &'a ImageFormatProperties {
        unsafe { &*(&self.raw.imageFormatProperties as *const vks::VkImageFormatProperties as *const ImageFormatProperties) }
    }

    pub fn get_image_format_properties_mut<'a>(&'a mut self) -> &'a mut ImageFormatProperties {
        unsafe { &mut *(&mut self.raw.imageFormatProperties as *mut  vks::VkImageFormatProperties as *mut ImageFormatProperties) }
    }

    pub fn build(self) -> ImageFormatProperties2Khr<'b> {
        ImageFormatProperties2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceImageFormatInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceImageFormatInfo2Khr<'s> {
    raw: vks::VkPhysicalDeviceImageFormatInfo2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceImageFormatInfo2Khr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
        PhysicalDeviceImageFormatInfo2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceImageFormatInfo2KHR) -> PhysicalDeviceImageFormatInfo2Khr<'s> {
        PhysicalDeviceImageFormatInfo2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn type_of<'a>(&'a self) -> ImageType {
        self.raw.type_.into()
    }

    pub fn tiling<'a>(&'a self) -> ImageTiling {
        self.raw.tiling.into()
    }

    pub fn usage<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.usage)
            .expect("PhysicalDeviceImageFormatInfo2Khr::usage: error converting flags")
    }

    pub fn flags<'a>(&'a self) -> ImageCreateFlags {
        ImageCreateFlags::from_bits(self.raw.flags)
            .expect("PhysicalDeviceImageFormatInfo2Khr::flags: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_format<'m>(&mut self, format: Format) {
        self.raw.format = format.into();
    }

    pub fn set_type_of<'m>(&mut self, type_of: ImageType) {
        self.raw.type_ = type_of.into();
    }

    pub fn set_tiling<'m>(&mut self, tiling: ImageTiling) {
        self.raw.tiling = tiling.into();
    }

    pub fn set_usage<'m>(&mut self, usage: ImageUsageFlags) {
        self.raw.usage = usage.bits();
    }

    pub fn set_flags<'m>(&mut self, flags: ImageCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceImageFormatInfo2KHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceImageFormatInfo2Khr<'s>> for vks::VkPhysicalDeviceImageFormatInfo2KHR {
    fn from(f: PhysicalDeviceImageFormatInfo2Khr<'s>) -> vks::VkPhysicalDeviceImageFormatInfo2KHR {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceImageFormatInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceImageFormatInfo2KHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
        PhysicalDeviceImageFormatInfo2KhrBuilder {
            raw: vks::VkPhysicalDeviceImageFormatInfo2KHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn format<'m>(mut self, format: Format) -> PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
        self.raw.format = format.into();
        self
    }

    pub fn type_of<'m>(mut self, type_of: ImageType) -> PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
        self.raw.type_ = type_of.into();
        self
    }

    pub fn tiling<'m>(mut self, tiling: ImageTiling) -> PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
        self.raw.tiling = tiling.into();
        self
    }

    pub fn usage<'m>(mut self, usage: ImageUsageFlags) -> PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
        self.raw.usage = usage.bits();
        self
    }

    pub fn flags<'m>(mut self, flags: ImageCreateFlags) -> PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn get_type_of<'a>(&'a self) -> ImageType {
        self.raw.type_.into()
    }

    pub fn get_tiling<'a>(&'a self) -> ImageTiling {
        self.raw.tiling.into()
    }

    pub fn get_usage<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.usage)
            .expect("PhysicalDeviceImageFormatInfo2Khr::usage: error converting flags")
    }

    pub fn get_flags<'a>(&'a self) -> ImageCreateFlags {
        ImageCreateFlags::from_bits(self.raw.flags)
            .expect("PhysicalDeviceImageFormatInfo2Khr::flags: error converting flags")
    }

    pub fn build(self) -> PhysicalDeviceImageFormatInfo2Khr<'b> {
        PhysicalDeviceImageFormatInfo2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkQueueFamilyProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct QueueFamilyProperties2Khr<'s> {
    raw: vks::VkQueueFamilyProperties2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> QueueFamilyProperties2Khr<'s> {
    pub fn builder<'b>() -> QueueFamilyProperties2KhrBuilder<'b> {
        QueueFamilyProperties2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkQueueFamilyProperties2KHR) -> QueueFamilyProperties2Khr<'s> {
        QueueFamilyProperties2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn queue_family_properties<'a>(&'a self) -> &'a QueueFamilyProperties {
        unsafe { &*(&self.raw.queueFamilyProperties as *const vks::VkQueueFamilyProperties as *const QueueFamilyProperties) }
    }

    pub fn queue_family_properties_mut<'a>(&'a mut self) -> &'a mut QueueFamilyProperties {
        unsafe { &mut *(&mut self.raw.queueFamilyProperties as *mut  vks::VkQueueFamilyProperties as *mut QueueFamilyProperties) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_queue_family_properties<'m>(&mut self, queue_family_properties: QueueFamilyProperties) {
        self.raw.queueFamilyProperties = queue_family_properties.raw;
    }

    pub fn as_raw(&self) -> &vks::VkQueueFamilyProperties2KHR {
        &self.raw
    }
}

impl<'s> From<QueueFamilyProperties2Khr<'s>> for vks::VkQueueFamilyProperties2KHR {
    fn from(f: QueueFamilyProperties2Khr<'s>) -> vks::VkQueueFamilyProperties2KHR {
        f.raw
    }
}


/// A builder for `VkQueueFamilyProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct QueueFamilyProperties2KhrBuilder<'b> {
    raw: vks::VkQueueFamilyProperties2KHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> QueueFamilyProperties2KhrBuilder<'b> {
    pub fn new() -> QueueFamilyProperties2KhrBuilder<'b> {
        QueueFamilyProperties2KhrBuilder {
            raw: vks::VkQueueFamilyProperties2KHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> QueueFamilyProperties2KhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn queue_family_properties<'m>(mut self, queue_family_properties: QueueFamilyProperties) -> QueueFamilyProperties2KhrBuilder<'b> {
        self.raw.queueFamilyProperties = queue_family_properties.raw;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_queue_family_properties<'a>(&'a self) -> &'a QueueFamilyProperties {
        unsafe { &*(&self.raw.queueFamilyProperties as *const vks::VkQueueFamilyProperties as *const QueueFamilyProperties) }
    }

    pub fn get_queue_family_properties_mut<'a>(&'a mut self) -> &'a mut QueueFamilyProperties {
        unsafe { &mut *(&mut self.raw.queueFamilyProperties as *mut  vks::VkQueueFamilyProperties as *mut QueueFamilyProperties) }
    }

    pub fn build(self) -> QueueFamilyProperties2Khr<'b> {
        QueueFamilyProperties2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceMemoryProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceMemoryProperties2Khr<'s> {
    raw: vks::VkPhysicalDeviceMemoryProperties2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceMemoryProperties2Khr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceMemoryProperties2KhrBuilder<'b> {
        PhysicalDeviceMemoryProperties2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceMemoryProperties2KHR) -> PhysicalDeviceMemoryProperties2Khr<'s> {
        PhysicalDeviceMemoryProperties2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn memory_properties<'a>(&'a self) -> &'a PhysicalDeviceMemoryProperties {
        unsafe { &*(&self.raw.memoryProperties as *const vks::VkPhysicalDeviceMemoryProperties as *const PhysicalDeviceMemoryProperties) }
    }

    pub fn memory_properties_mut<'a>(&'a mut self) -> &'a mut PhysicalDeviceMemoryProperties {
        unsafe { &mut *(&mut self.raw.memoryProperties as *mut  vks::VkPhysicalDeviceMemoryProperties as *mut PhysicalDeviceMemoryProperties) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_memory_properties<'m>(&mut self, memory_properties: PhysicalDeviceMemoryProperties) {
        self.raw.memoryProperties = memory_properties.raw;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceMemoryProperties2KHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceMemoryProperties2Khr<'s>> for vks::VkPhysicalDeviceMemoryProperties2KHR {
    fn from(f: PhysicalDeviceMemoryProperties2Khr<'s>) -> vks::VkPhysicalDeviceMemoryProperties2KHR {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceMemoryProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceMemoryProperties2KhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceMemoryProperties2KHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PhysicalDeviceMemoryProperties2KhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceMemoryProperties2KhrBuilder<'b> {
        PhysicalDeviceMemoryProperties2KhrBuilder {
            raw: vks::VkPhysicalDeviceMemoryProperties2KHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceMemoryProperties2KhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn memory_properties<'m>(mut self, memory_properties: PhysicalDeviceMemoryProperties) -> PhysicalDeviceMemoryProperties2KhrBuilder<'b> {
        self.raw.memoryProperties = memory_properties.raw;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_memory_properties<'a>(&'a self) -> &'a PhysicalDeviceMemoryProperties {
        unsafe { &*(&self.raw.memoryProperties as *const vks::VkPhysicalDeviceMemoryProperties as *const PhysicalDeviceMemoryProperties) }
    }

    pub fn get_memory_properties_mut<'a>(&'a mut self) -> &'a mut PhysicalDeviceMemoryProperties {
        unsafe { &mut *(&mut self.raw.memoryProperties as *mut  vks::VkPhysicalDeviceMemoryProperties as *mut PhysicalDeviceMemoryProperties) }
    }

    pub fn build(self) -> PhysicalDeviceMemoryProperties2Khr<'b> {
        PhysicalDeviceMemoryProperties2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSparseImageFormatProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SparseImageFormatProperties2Khr<'s> {
    raw: vks::VkSparseImageFormatProperties2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> SparseImageFormatProperties2Khr<'s> {
    pub fn builder<'b>() -> SparseImageFormatProperties2KhrBuilder<'b> {
        SparseImageFormatProperties2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSparseImageFormatProperties2KHR) -> SparseImageFormatProperties2Khr<'s> {
        SparseImageFormatProperties2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn properties<'a>(&'a self) -> &'a SparseImageFormatProperties {
        unsafe { &*(&self.raw.properties as *const vks::VkSparseImageFormatProperties as *const SparseImageFormatProperties) }
    }

    pub fn properties_mut<'a>(&'a mut self) -> &'a mut SparseImageFormatProperties {
        unsafe { &mut *(&mut self.raw.properties as *mut  vks::VkSparseImageFormatProperties as *mut SparseImageFormatProperties) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_properties<'m>(&mut self, properties: SparseImageFormatProperties) {
        self.raw.properties = properties.raw;
    }

    pub fn as_raw(&self) -> &vks::VkSparseImageFormatProperties2KHR {
        &self.raw
    }
}

impl<'s> From<SparseImageFormatProperties2Khr<'s>> for vks::VkSparseImageFormatProperties2KHR {
    fn from(f: SparseImageFormatProperties2Khr<'s>) -> vks::VkSparseImageFormatProperties2KHR {
        f.raw
    }
}


/// A builder for `VkSparseImageFormatProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SparseImageFormatProperties2KhrBuilder<'b> {
    raw: vks::VkSparseImageFormatProperties2KHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SparseImageFormatProperties2KhrBuilder<'b> {
    pub fn new() -> SparseImageFormatProperties2KhrBuilder<'b> {
        SparseImageFormatProperties2KhrBuilder {
            raw: vks::VkSparseImageFormatProperties2KHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> SparseImageFormatProperties2KhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn properties<'m>(mut self, properties: SparseImageFormatProperties) -> SparseImageFormatProperties2KhrBuilder<'b> {
        self.raw.properties = properties.raw;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_properties<'a>(&'a self) -> &'a SparseImageFormatProperties {
        unsafe { &*(&self.raw.properties as *const vks::VkSparseImageFormatProperties as *const SparseImageFormatProperties) }
    }

    pub fn get_properties_mut<'a>(&'a mut self) -> &'a mut SparseImageFormatProperties {
        unsafe { &mut *(&mut self.raw.properties as *mut  vks::VkSparseImageFormatProperties as *mut SparseImageFormatProperties) }
    }

    pub fn build(self) -> SparseImageFormatProperties2Khr<'b> {
        SparseImageFormatProperties2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceSparseImageFormatInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceSparseImageFormatInfo2Khr<'s> {
    raw: vks::VkPhysicalDeviceSparseImageFormatInfo2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceSparseImageFormatInfo2Khr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
        PhysicalDeviceSparseImageFormatInfo2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceSparseImageFormatInfo2KHR) -> PhysicalDeviceSparseImageFormatInfo2Khr<'s> {
        PhysicalDeviceSparseImageFormatInfo2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn type_of<'a>(&'a self) -> ImageType {
        self.raw.type_.into()
    }

    pub fn samples<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.samples)
            .expect("PhysicalDeviceSparseImageFormatInfo2Khr::samples: error converting flags")
    }

    pub fn usage<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.usage)
            .expect("PhysicalDeviceSparseImageFormatInfo2Khr::usage: error converting flags")
    }

    pub fn tiling<'a>(&'a self) -> ImageTiling {
        self.raw.tiling.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_format<'m>(&mut self, format: Format) {
        self.raw.format = format.into();
    }

    pub fn set_type_of<'m>(&mut self, type_of: ImageType) {
        self.raw.type_ = type_of.into();
    }

    pub fn set_samples<'m>(&mut self, samples: SampleCountFlags) {
        self.raw.samples = samples.bits();
    }

    pub fn set_usage<'m>(&mut self, usage: ImageUsageFlags) {
        self.raw.usage = usage.bits();
    }

    pub fn set_tiling<'m>(&mut self, tiling: ImageTiling) {
        self.raw.tiling = tiling.into();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceSparseImageFormatInfo2KHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceSparseImageFormatInfo2Khr<'s>> for vks::VkPhysicalDeviceSparseImageFormatInfo2KHR {
    fn from(f: PhysicalDeviceSparseImageFormatInfo2Khr<'s>) -> vks::VkPhysicalDeviceSparseImageFormatInfo2KHR {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceSparseImageFormatInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceSparseImageFormatInfo2KHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
        PhysicalDeviceSparseImageFormatInfo2KhrBuilder {
            raw: vks::VkPhysicalDeviceSparseImageFormatInfo2KHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn format<'m>(mut self, format: Format) -> PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
        self.raw.format = format.into();
        self
    }

    pub fn type_of<'m>(mut self, type_of: ImageType) -> PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
        self.raw.type_ = type_of.into();
        self
    }

    pub fn samples<'m>(mut self, samples: SampleCountFlags) -> PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
        self.raw.samples = samples.bits();
        self
    }

    pub fn usage<'m>(mut self, usage: ImageUsageFlags) -> PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
        self.raw.usage = usage.bits();
        self
    }

    pub fn tiling<'m>(mut self, tiling: ImageTiling) -> PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
        self.raw.tiling = tiling.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn get_type_of<'a>(&'a self) -> ImageType {
        self.raw.type_.into()
    }

    pub fn get_samples<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.samples)
            .expect("PhysicalDeviceSparseImageFormatInfo2Khr::samples: error converting flags")
    }

    pub fn get_usage<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.usage)
            .expect("PhysicalDeviceSparseImageFormatInfo2Khr::usage: error converting flags")
    }

    pub fn get_tiling<'a>(&'a self) -> ImageTiling {
        self.raw.tiling.into()
    }

    pub fn build(self) -> PhysicalDeviceSparseImageFormatInfo2Khr<'b> {
        PhysicalDeviceSparseImageFormatInfo2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDevicePushDescriptorPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDevicePushDescriptorPropertiesKhr<'s> {
    raw: vks::VkPhysicalDevicePushDescriptorPropertiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDevicePushDescriptorPropertiesKhr<'s> {
    pub fn builder<'b>() -> PhysicalDevicePushDescriptorPropertiesKhrBuilder<'b> {
        PhysicalDevicePushDescriptorPropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDevicePushDescriptorPropertiesKHR) -> PhysicalDevicePushDescriptorPropertiesKhr<'s> {
        PhysicalDevicePushDescriptorPropertiesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn max_push_descriptors<'a>(&'a self) -> u32 {
        self.raw.maxPushDescriptors.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_max_push_descriptors<'m>(&mut self, max_push_descriptors: u32) {
        self.raw.maxPushDescriptors = max_push_descriptors.into();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDevicePushDescriptorPropertiesKHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDevicePushDescriptorPropertiesKhr<'s>> for vks::VkPhysicalDevicePushDescriptorPropertiesKHR {
    fn from(f: PhysicalDevicePushDescriptorPropertiesKhr<'s>) -> vks::VkPhysicalDevicePushDescriptorPropertiesKHR {
        f.raw
    }
}


/// A builder for `VkPhysicalDevicePushDescriptorPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDevicePushDescriptorPropertiesKhrBuilder<'b> {
    raw: vks::VkPhysicalDevicePushDescriptorPropertiesKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PhysicalDevicePushDescriptorPropertiesKhrBuilder<'b> {
    pub fn new() -> PhysicalDevicePushDescriptorPropertiesKhrBuilder<'b> {
        PhysicalDevicePushDescriptorPropertiesKhrBuilder {
            raw: vks::VkPhysicalDevicePushDescriptorPropertiesKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDevicePushDescriptorPropertiesKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn max_push_descriptors<'m>(mut self, max_push_descriptors: u32) -> PhysicalDevicePushDescriptorPropertiesKhrBuilder<'b> {
        self.raw.maxPushDescriptors = max_push_descriptors.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_max_push_descriptors<'a>(&'a self) -> u32 {
        self.raw.maxPushDescriptors.into()
    }

    pub fn build(self) -> PhysicalDevicePushDescriptorPropertiesKhr<'b> {
        PhysicalDevicePushDescriptorPropertiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPresentRegionsKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PresentRegionsKhr<'s> {
    raw: vks::VkPresentRegionsKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PresentRegionsKhr<'s> {
    pub fn builder<'b>() -> PresentRegionsKhrBuilder<'b> {
        PresentRegionsKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPresentRegionsKHR) -> PresentRegionsKhr<'s> {
        PresentRegionsKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn regions<'a>(&'a self) -> &'a [PresentRegionKhr] {
        unsafe { slice::from_raw_parts(self.raw.pRegions as *const _, self.raw.swapchainCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_regions<'m, 'a>(&mut self, regions: &'a [PresentRegionKhr])
            where 'a: 's {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == regions.len() as _, 
            "count inconsistency found when specifying `PresentRegionsKhr::regions`.");
        self.raw.swapchainCount = regions.len() as _;
        self.raw.pRegions = regions.as_ptr() as *const vks::VkPresentRegionKHR;
    }

    pub fn as_raw(&self) -> &vks::VkPresentRegionsKHR {
        &self.raw
    }
}

impl<'s> From<PresentRegionsKhr<'s>> for vks::VkPresentRegionsKHR {
    fn from(f: PresentRegionsKhr<'s>) -> vks::VkPresentRegionsKHR {
        f.raw
    }
}


/// A builder for `VkPresentRegionsKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PresentRegionsKhrBuilder<'b> {
    raw: vks::VkPresentRegionsKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PresentRegionsKhrBuilder<'b> {
    pub fn new() -> PresentRegionsKhrBuilder<'b> {
        PresentRegionsKhrBuilder {
            raw: vks::VkPresentRegionsKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PresentRegionsKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn regions<'m, 'a>(mut self, regions: &'a [PresentRegionKhr]) -> PresentRegionsKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == regions.len() as _, 
            "count inconsistency found when specifying `PresentRegionsKhr::regions`.");
        self.raw.swapchainCount = regions.len() as _;
        self.raw.pRegions = regions.as_ptr() as *const vks::VkPresentRegionKHR;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_regions<'a>(&'a self) -> &'a [PresentRegionKhr] {
        unsafe { slice::from_raw_parts(self.raw.pRegions as *const _, self.raw.swapchainCount as usize) }
    }

    pub fn build(self) -> PresentRegionsKhr<'b> {
        PresentRegionsKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPresentRegionKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PresentRegionKhr<'s> {
    raw: vks::VkPresentRegionKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PresentRegionKhr<'s> {
    pub fn builder<'b>() -> PresentRegionKhrBuilder<'b> {
        PresentRegionKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPresentRegionKHR) -> PresentRegionKhr<'s> {
        PresentRegionKhr { raw, _p: PhantomData }
    }

    pub fn rectangles<'a>(&'a self) -> &'a [RectLayerKhr] {
        unsafe { slice::from_raw_parts(self.raw.pRectangles as *const _, self.raw.rectangleCount as usize) }
    }

    pub fn set_rectangles<'m, 'a>(&mut self, rectangles: &'a [RectLayerKhr])
            where 'a: 's {
        assert!(self.raw.rectangleCount == 0 || self.raw.rectangleCount == rectangles.len() as _, 
            "count inconsistency found when specifying `PresentRegionKhr::rectangles`.");
        self.raw.rectangleCount = rectangles.len() as _;
        self.raw.pRectangles = rectangles.as_ptr() as *const vks::VkRectLayerKHR;
    }

    pub fn as_raw(&self) -> &vks::VkPresentRegionKHR {
        &self.raw
    }
}

impl<'s> From<PresentRegionKhr<'s>> for vks::VkPresentRegionKHR {
    fn from(f: PresentRegionKhr<'s>) -> vks::VkPresentRegionKHR {
        f.raw
    }
}


/// A builder for `VkPresentRegionKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PresentRegionKhrBuilder<'b> {
    raw: vks::VkPresentRegionKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PresentRegionKhrBuilder<'b> {
    pub fn new() -> PresentRegionKhrBuilder<'b> {
        PresentRegionKhrBuilder {
            raw: vks::VkPresentRegionKHR::default(),
            _p: PhantomData,
        }
    }

    pub fn rectangles<'m, 'a>(mut self, rectangles: &'a [RectLayerKhr]) -> PresentRegionKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.rectangleCount == 0 || self.raw.rectangleCount == rectangles.len() as _, 
            "count inconsistency found when specifying `PresentRegionKhr::rectangles`.");
        self.raw.rectangleCount = rectangles.len() as _;
        self.raw.pRectangles = rectangles.as_ptr() as *const vks::VkRectLayerKHR;
        self
    }

    pub fn get_rectangles<'a>(&'a self) -> &'a [RectLayerKhr] {
        unsafe { slice::from_raw_parts(self.raw.pRectangles as *const _, self.raw.rectangleCount as usize) }
    }

    pub fn build(self) -> PresentRegionKhr<'b> {
        PresentRegionKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkRectLayerKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct RectLayerKhr {
    raw: vks::VkRectLayerKHR,
}

impl RectLayerKhr {
    pub fn builder() -> RectLayerKhrBuilder {
        RectLayerKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkRectLayerKHR) -> RectLayerKhr {
        RectLayerKhr { raw, }
    }

    pub fn offset<'a>(&'a self) -> &'a Offset2d {
        unsafe { &*(&self.raw.offset as *const vks::VkOffset2D as *const Offset2d) }
    }

    pub fn offset_mut<'a>(&'a mut self) -> &'a mut Offset2d {
        unsafe { &mut *(&mut self.raw.offset as *mut  vks::VkOffset2D as *mut Offset2d) }
    }

    pub fn extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.extent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn layer<'a>(&'a self) -> u32 {
        self.raw.layer.into()
    }

    pub fn set_offset<'m>(&mut self, offset: Offset2d) {
        self.raw.offset = offset.raw;
    }

    pub fn set_extent<'m>(&mut self, extent: Extent2d) {
        self.raw.extent = extent.raw;
    }

    pub fn set_layer<'m>(&mut self, layer: u32) {
        self.raw.layer = layer.into();
    }

    pub fn as_raw(&self) -> &vks::VkRectLayerKHR {
        &self.raw
    }
}

impl From<RectLayerKhr> for vks::VkRectLayerKHR {
    fn from(f: RectLayerKhr) -> vks::VkRectLayerKHR {
        f.raw
    }
}


/// A builder for `VkRectLayerKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct RectLayerKhrBuilder {
    raw: vks::VkRectLayerKHR,
}

impl RectLayerKhrBuilder {
    pub fn new() -> RectLayerKhrBuilder {
        RectLayerKhrBuilder {
            raw: vks::VkRectLayerKHR::default(),
        }
    }

    pub fn offset<'m>(mut self, offset: Offset2d) -> RectLayerKhrBuilder {
        self.raw.offset = offset.raw;
        self
    }

    pub fn extent<'m>(mut self, extent: Extent2d) -> RectLayerKhrBuilder {
        self.raw.extent = extent.raw;
        self
    }

    pub fn layer<'m>(mut self, layer: u32) -> RectLayerKhrBuilder {
        self.raw.layer = layer.into();
        self
    }

    pub fn get_offset<'a>(&'a self) -> &'a Offset2d {
        unsafe { &*(&self.raw.offset as *const vks::VkOffset2D as *const Offset2d) }
    }

    pub fn get_offset_mut<'a>(&'a mut self) -> &'a mut Offset2d {
        unsafe { &mut *(&mut self.raw.offset as *mut  vks::VkOffset2D as *mut Offset2d) }
    }

    pub fn get_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.extent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn get_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn get_layer<'a>(&'a self) -> u32 {
        self.raw.layer.into()
    }

    pub fn build(self) -> RectLayerKhr {
        RectLayerKhr {
            raw: self.raw,
        }
    }
}


/// A `VkPhysicalDeviceVariablePointerFeaturesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceVariablePointerFeaturesKhr<'s> {
    raw: vks::VkPhysicalDeviceVariablePointerFeaturesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceVariablePointerFeaturesKhr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceVariablePointerFeaturesKhrBuilder<'b> {
        PhysicalDeviceVariablePointerFeaturesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceVariablePointerFeaturesKHR) -> PhysicalDeviceVariablePointerFeaturesKhr<'s> {
        PhysicalDeviceVariablePointerFeaturesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn variable_pointers_storage_buffer<'a>(&'a self) -> bool {
        self.raw.variablePointersStorageBuffer != 0
    }

    pub fn variable_pointers<'a>(&'a self) -> bool {
        self.raw.variablePointers != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_variable_pointers_storage_buffer<'m>(&mut self, variable_pointers_storage_buffer: bool) {
        self.raw.variablePointersStorageBuffer = variable_pointers_storage_buffer as u32;
    }

    pub fn set_variable_pointers<'m>(&mut self, variable_pointers: bool) {
        self.raw.variablePointers = variable_pointers as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceVariablePointerFeaturesKHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceVariablePointerFeaturesKhr<'s>> for vks::VkPhysicalDeviceVariablePointerFeaturesKHR {
    fn from(f: PhysicalDeviceVariablePointerFeaturesKhr<'s>) -> vks::VkPhysicalDeviceVariablePointerFeaturesKHR {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceVariablePointerFeaturesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceVariablePointerFeaturesKhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceVariablePointerFeaturesKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PhysicalDeviceVariablePointerFeaturesKhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceVariablePointerFeaturesKhrBuilder<'b> {
        PhysicalDeviceVariablePointerFeaturesKhrBuilder {
            raw: vks::VkPhysicalDeviceVariablePointerFeaturesKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceVariablePointerFeaturesKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn variable_pointers_storage_buffer<'m>(mut self, variable_pointers_storage_buffer: bool) -> PhysicalDeviceVariablePointerFeaturesKhrBuilder<'b> {
        self.raw.variablePointersStorageBuffer = variable_pointers_storage_buffer as u32;
        self
    }

    pub fn variable_pointers<'m>(mut self, variable_pointers: bool) -> PhysicalDeviceVariablePointerFeaturesKhrBuilder<'b> {
        self.raw.variablePointers = variable_pointers as u32;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_variable_pointers_storage_buffer<'a>(&'a self) -> bool {
        self.raw.variablePointersStorageBuffer != 0
    }

    pub fn get_variable_pointers<'a>(&'a self) -> bool {
        self.raw.variablePointers != 0
    }

    pub fn build(self) -> PhysicalDeviceVariablePointerFeaturesKhr<'b> {
        PhysicalDeviceVariablePointerFeaturesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExternalMemoryPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExternalMemoryPropertiesKhr {
    raw: vks::VkExternalMemoryPropertiesKHR,
}

impl ExternalMemoryPropertiesKhr {
    pub fn builder() -> ExternalMemoryPropertiesKhrBuilder {
        ExternalMemoryPropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExternalMemoryPropertiesKHR) -> ExternalMemoryPropertiesKhr {
        ExternalMemoryPropertiesKhr { raw, }
    }

    pub fn external_memory_features<'a>(&'a self) -> ExternalMemoryFeatureFlagsKhr {
        ExternalMemoryFeatureFlagsKhr::from_bits(self.raw.externalMemoryFeatures)
            .expect("ExternalMemoryPropertiesKhr::external_memory_features: error converting flags")
    }

    pub fn export_from_imported_handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.exportFromImportedHandleTypes)
            .expect("ExternalMemoryPropertiesKhr::export_from_imported_handle_types: error converting flags")
    }

    pub fn compatible_handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.compatibleHandleTypes)
            .expect("ExternalMemoryPropertiesKhr::compatible_handle_types: error converting flags")
    }

    pub fn set_external_memory_features<'m>(&mut self, external_memory_features: ExternalMemoryFeatureFlagsKhr) {
        self.raw.externalMemoryFeatures = external_memory_features.bits();
    }

    pub fn set_export_from_imported_handle_types<'m>(&mut self, export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.exportFromImportedHandleTypes = export_from_imported_handle_types.bits();
    }

    pub fn set_compatible_handle_types<'m>(&mut self, compatible_handle_types: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.compatibleHandleTypes = compatible_handle_types.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExternalMemoryPropertiesKHR {
        &self.raw
    }
}

impl From<ExternalMemoryPropertiesKhr> for vks::VkExternalMemoryPropertiesKHR {
    fn from(f: ExternalMemoryPropertiesKhr) -> vks::VkExternalMemoryPropertiesKHR {
        f.raw
    }
}


/// A builder for `VkExternalMemoryPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExternalMemoryPropertiesKhrBuilder {
    raw: vks::VkExternalMemoryPropertiesKHR,
}

impl ExternalMemoryPropertiesKhrBuilder {
    pub fn new() -> ExternalMemoryPropertiesKhrBuilder {
        ExternalMemoryPropertiesKhrBuilder {
            raw: vks::VkExternalMemoryPropertiesKHR::default(),
        }
    }

    pub fn external_memory_features<'m>(mut self, external_memory_features: ExternalMemoryFeatureFlagsKhr) -> ExternalMemoryPropertiesKhrBuilder {
        self.raw.externalMemoryFeatures = external_memory_features.bits();
        self
    }

    pub fn export_from_imported_handle_types<'m>(mut self, export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsKhr) -> ExternalMemoryPropertiesKhrBuilder {
        self.raw.exportFromImportedHandleTypes = export_from_imported_handle_types.bits();
        self
    }

    pub fn compatible_handle_types<'m>(mut self, compatible_handle_types: ExternalMemoryHandleTypeFlagsKhr) -> ExternalMemoryPropertiesKhrBuilder {
        self.raw.compatibleHandleTypes = compatible_handle_types.bits();
        self
    }

    pub fn get_external_memory_features<'a>(&'a self) -> ExternalMemoryFeatureFlagsKhr {
        ExternalMemoryFeatureFlagsKhr::from_bits(self.raw.externalMemoryFeatures)
            .expect("ExternalMemoryPropertiesKhr::external_memory_features: error converting flags")
    }

    pub fn get_export_from_imported_handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.exportFromImportedHandleTypes)
            .expect("ExternalMemoryPropertiesKhr::export_from_imported_handle_types: error converting flags")
    }

    pub fn get_compatible_handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.compatibleHandleTypes)
            .expect("ExternalMemoryPropertiesKhr::compatible_handle_types: error converting flags")
    }

    pub fn build(self) -> ExternalMemoryPropertiesKhr {
        ExternalMemoryPropertiesKhr {
            raw: self.raw,
        }
    }
}


/// A `VkPhysicalDeviceExternalImageFormatInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceExternalImageFormatInfoKhr<'s> {
    raw: vks::VkPhysicalDeviceExternalImageFormatInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceExternalImageFormatInfoKhr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceExternalImageFormatInfoKhrBuilder<'b> {
        PhysicalDeviceExternalImageFormatInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceExternalImageFormatInfoKHR) -> PhysicalDeviceExternalImageFormatInfoKhr<'s> {
        PhysicalDeviceExternalImageFormatInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("PhysicalDeviceExternalImageFormatInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceExternalImageFormatInfoKHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceExternalImageFormatInfoKhr<'s>> for vks::VkPhysicalDeviceExternalImageFormatInfoKHR {
    fn from(f: PhysicalDeviceExternalImageFormatInfoKhr<'s>) -> vks::VkPhysicalDeviceExternalImageFormatInfoKHR {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceExternalImageFormatInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceExternalImageFormatInfoKhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceExternalImageFormatInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PhysicalDeviceExternalImageFormatInfoKhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceExternalImageFormatInfoKhrBuilder<'b> {
        PhysicalDeviceExternalImageFormatInfoKhrBuilder {
            raw: vks::VkPhysicalDeviceExternalImageFormatInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PhysicalDeviceExternalImageFormatInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) -> PhysicalDeviceExternalImageFormatInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("PhysicalDeviceExternalImageFormatInfoKhr::handle_type: error converting flags")
    }

    pub fn build(self) -> PhysicalDeviceExternalImageFormatInfoKhr<'b> {
        PhysicalDeviceExternalImageFormatInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExternalImageFormatPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExternalImageFormatPropertiesKhr<'s> {
    raw: vks::VkExternalImageFormatPropertiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExternalImageFormatPropertiesKhr<'s> {
    pub fn builder<'b>() -> ExternalImageFormatPropertiesKhrBuilder<'b> {
        ExternalImageFormatPropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExternalImageFormatPropertiesKHR) -> ExternalImageFormatPropertiesKhr<'s> {
        ExternalImageFormatPropertiesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn external_memory_properties<'a>(&'a self) -> &'a ExternalMemoryPropertiesKhr {
        unsafe { &*(&self.raw.externalMemoryProperties as *const vks::VkExternalMemoryPropertiesKHR as *const ExternalMemoryPropertiesKhr) }
    }

    pub fn external_memory_properties_mut<'a>(&'a mut self) -> &'a mut ExternalMemoryPropertiesKhr {
        unsafe { &mut *(&mut self.raw.externalMemoryProperties as *mut  vks::VkExternalMemoryPropertiesKHR as *mut ExternalMemoryPropertiesKhr) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_external_memory_properties<'m>(&mut self, external_memory_properties: ExternalMemoryPropertiesKhr) {
        self.raw.externalMemoryProperties = external_memory_properties.raw;
    }

    pub fn as_raw(&self) -> &vks::VkExternalImageFormatPropertiesKHR {
        &self.raw
    }
}

impl<'s> From<ExternalImageFormatPropertiesKhr<'s>> for vks::VkExternalImageFormatPropertiesKHR {
    fn from(f: ExternalImageFormatPropertiesKhr<'s>) -> vks::VkExternalImageFormatPropertiesKHR {
        f.raw
    }
}


/// A builder for `VkExternalImageFormatPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExternalImageFormatPropertiesKhrBuilder<'b> {
    raw: vks::VkExternalImageFormatPropertiesKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ExternalImageFormatPropertiesKhrBuilder<'b> {
    pub fn new() -> ExternalImageFormatPropertiesKhrBuilder<'b> {
        ExternalImageFormatPropertiesKhrBuilder {
            raw: vks::VkExternalImageFormatPropertiesKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> ExternalImageFormatPropertiesKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn external_memory_properties<'m>(mut self, external_memory_properties: ExternalMemoryPropertiesKhr) -> ExternalImageFormatPropertiesKhrBuilder<'b> {
        self.raw.externalMemoryProperties = external_memory_properties.raw;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_external_memory_properties<'a>(&'a self) -> &'a ExternalMemoryPropertiesKhr {
        unsafe { &*(&self.raw.externalMemoryProperties as *const vks::VkExternalMemoryPropertiesKHR as *const ExternalMemoryPropertiesKhr) }
    }

    pub fn get_external_memory_properties_mut<'a>(&'a mut self) -> &'a mut ExternalMemoryPropertiesKhr {
        unsafe { &mut *(&mut self.raw.externalMemoryProperties as *mut  vks::VkExternalMemoryPropertiesKHR as *mut ExternalMemoryPropertiesKhr) }
    }

    pub fn build(self) -> ExternalImageFormatPropertiesKhr<'b> {
        ExternalImageFormatPropertiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceExternalBufferInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceExternalBufferInfoKhr<'s> {
    raw: vks::VkPhysicalDeviceExternalBufferInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceExternalBufferInfoKhr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceExternalBufferInfoKhrBuilder<'b> {
        PhysicalDeviceExternalBufferInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceExternalBufferInfoKHR) -> PhysicalDeviceExternalBufferInfoKhr<'s> {
        PhysicalDeviceExternalBufferInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> BufferCreateFlags {
        BufferCreateFlags::from_bits(self.raw.flags)
            .expect("PhysicalDeviceExternalBufferInfoKhr::flags: error converting flags")
    }

    pub fn usage<'a>(&'a self) -> BufferUsageFlags {
        BufferUsageFlags::from_bits(self.raw.usage)
            .expect("PhysicalDeviceExternalBufferInfoKhr::usage: error converting flags")
    }

    pub fn handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("PhysicalDeviceExternalBufferInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: BufferCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_usage<'m>(&mut self, usage: BufferUsageFlags) {
        self.raw.usage = usage.bits();
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceExternalBufferInfoKHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceExternalBufferInfoKhr<'s>> for vks::VkPhysicalDeviceExternalBufferInfoKHR {
    fn from(f: PhysicalDeviceExternalBufferInfoKhr<'s>) -> vks::VkPhysicalDeviceExternalBufferInfoKHR {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceExternalBufferInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceExternalBufferInfoKhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceExternalBufferInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PhysicalDeviceExternalBufferInfoKhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceExternalBufferInfoKhrBuilder<'b> {
        PhysicalDeviceExternalBufferInfoKhrBuilder {
            raw: vks::VkPhysicalDeviceExternalBufferInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PhysicalDeviceExternalBufferInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: BufferCreateFlags) -> PhysicalDeviceExternalBufferInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn usage<'m>(mut self, usage: BufferUsageFlags) -> PhysicalDeviceExternalBufferInfoKhrBuilder<'b> {
        self.raw.usage = usage.bits();
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) -> PhysicalDeviceExternalBufferInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> BufferCreateFlags {
        BufferCreateFlags::from_bits(self.raw.flags)
            .expect("PhysicalDeviceExternalBufferInfoKhr::flags: error converting flags")
    }

    pub fn get_usage<'a>(&'a self) -> BufferUsageFlags {
        BufferUsageFlags::from_bits(self.raw.usage)
            .expect("PhysicalDeviceExternalBufferInfoKhr::usage: error converting flags")
    }

    pub fn get_handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("PhysicalDeviceExternalBufferInfoKhr::handle_type: error converting flags")
    }

    pub fn build(self) -> PhysicalDeviceExternalBufferInfoKhr<'b> {
        PhysicalDeviceExternalBufferInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExternalBufferPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExternalBufferPropertiesKhr<'s> {
    raw: vks::VkExternalBufferPropertiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExternalBufferPropertiesKhr<'s> {
    pub fn builder<'b>() -> ExternalBufferPropertiesKhrBuilder<'b> {
        ExternalBufferPropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExternalBufferPropertiesKHR) -> ExternalBufferPropertiesKhr<'s> {
        ExternalBufferPropertiesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn external_memory_properties<'a>(&'a self) -> &'a ExternalMemoryPropertiesKhr {
        unsafe { &*(&self.raw.externalMemoryProperties as *const vks::VkExternalMemoryPropertiesKHR as *const ExternalMemoryPropertiesKhr) }
    }

    pub fn external_memory_properties_mut<'a>(&'a mut self) -> &'a mut ExternalMemoryPropertiesKhr {
        unsafe { &mut *(&mut self.raw.externalMemoryProperties as *mut  vks::VkExternalMemoryPropertiesKHR as *mut ExternalMemoryPropertiesKhr) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_external_memory_properties<'m>(&mut self, external_memory_properties: ExternalMemoryPropertiesKhr) {
        self.raw.externalMemoryProperties = external_memory_properties.raw;
    }

    pub fn as_raw(&self) -> &vks::VkExternalBufferPropertiesKHR {
        &self.raw
    }
}

impl<'s> From<ExternalBufferPropertiesKhr<'s>> for vks::VkExternalBufferPropertiesKHR {
    fn from(f: ExternalBufferPropertiesKhr<'s>) -> vks::VkExternalBufferPropertiesKHR {
        f.raw
    }
}


/// A builder for `VkExternalBufferPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExternalBufferPropertiesKhrBuilder<'b> {
    raw: vks::VkExternalBufferPropertiesKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ExternalBufferPropertiesKhrBuilder<'b> {
    pub fn new() -> ExternalBufferPropertiesKhrBuilder<'b> {
        ExternalBufferPropertiesKhrBuilder {
            raw: vks::VkExternalBufferPropertiesKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> ExternalBufferPropertiesKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn external_memory_properties<'m>(mut self, external_memory_properties: ExternalMemoryPropertiesKhr) -> ExternalBufferPropertiesKhrBuilder<'b> {
        self.raw.externalMemoryProperties = external_memory_properties.raw;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_external_memory_properties<'a>(&'a self) -> &'a ExternalMemoryPropertiesKhr {
        unsafe { &*(&self.raw.externalMemoryProperties as *const vks::VkExternalMemoryPropertiesKHR as *const ExternalMemoryPropertiesKhr) }
    }

    pub fn get_external_memory_properties_mut<'a>(&'a mut self) -> &'a mut ExternalMemoryPropertiesKhr {
        unsafe { &mut *(&mut self.raw.externalMemoryProperties as *mut  vks::VkExternalMemoryPropertiesKHR as *mut ExternalMemoryPropertiesKhr) }
    }

    pub fn build(self) -> ExternalBufferPropertiesKhr<'b> {
        ExternalBufferPropertiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceIDPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceIDPropertiesKhr<'s> {
    raw: vks::VkPhysicalDeviceIDPropertiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceIDPropertiesKhr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceIDPropertiesKhrBuilder<'b> {
        PhysicalDeviceIDPropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceIDPropertiesKHR) -> PhysicalDeviceIDPropertiesKhr<'s> {
        PhysicalDeviceIDPropertiesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn device_uuid<'a>(&'a self) -> &[u8] {
        unsafe { slice::from_raw_parts(&self.raw.deviceUUID as *const _, vks::VK_UUID_SIZE as usize) }
    }

    pub fn driver_uuid<'a>(&'a self) -> &[u8] {
        unsafe { slice::from_raw_parts(&self.raw.driverUUID as *const _, vks::VK_UUID_SIZE as usize) }
    }

    pub fn device_luid<'a>(&'a self) -> &[u8] {
        unsafe { slice::from_raw_parts(&self.raw.deviceLUID as *const _, vks::VK_LUID_SIZE_KHR as usize) }
    }

    pub fn device_node_mask<'a>(&'a self) -> u32 {
        self.raw.deviceNodeMask.into()
    }

    pub fn device_luid_valid<'a>(&'a self) -> bool {
        self.raw.deviceLUIDValid != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_device_uuid<'m>(&mut self, device_uuid: [u8; vks::VK_UUID_SIZE]) {
        self.raw.deviceUUID = device_uuid;
    }

    pub fn set_driver_uuid<'m>(&mut self, driver_uuid: [u8; vks::VK_UUID_SIZE]) {
        self.raw.driverUUID = driver_uuid;
    }

    pub fn set_device_luid<'m>(&mut self, device_luid: [u8; vks::VK_LUID_SIZE_KHR]) {
        self.raw.deviceLUID = device_luid;
    }

    pub fn set_device_node_mask<'m>(&mut self, device_node_mask: u32) {
        self.raw.deviceNodeMask = device_node_mask.into();
    }

    pub fn set_device_luid_valid<'m>(&mut self, device_luid_valid: bool) {
        self.raw.deviceLUIDValid = device_luid_valid as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceIDPropertiesKHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceIDPropertiesKhr<'s>> for vks::VkPhysicalDeviceIDPropertiesKHR {
    fn from(f: PhysicalDeviceIDPropertiesKhr<'s>) -> vks::VkPhysicalDeviceIDPropertiesKHR {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceIDPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceIDPropertiesKhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceIDPropertiesKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PhysicalDeviceIDPropertiesKhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceIDPropertiesKhrBuilder<'b> {
        PhysicalDeviceIDPropertiesKhrBuilder {
            raw: vks::VkPhysicalDeviceIDPropertiesKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceIDPropertiesKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn device_uuid<'m>(mut self, device_uuid: [u8; vks::VK_UUID_SIZE]) -> PhysicalDeviceIDPropertiesKhrBuilder<'b> {
        self.raw.deviceUUID = device_uuid;
        self
    }

    pub fn driver_uuid<'m>(mut self, driver_uuid: [u8; vks::VK_UUID_SIZE]) -> PhysicalDeviceIDPropertiesKhrBuilder<'b> {
        self.raw.driverUUID = driver_uuid;
        self
    }

    pub fn device_luid<'m>(mut self, device_luid: [u8; vks::VK_LUID_SIZE_KHR]) -> PhysicalDeviceIDPropertiesKhrBuilder<'b> {
        self.raw.deviceLUID = device_luid;
        self
    }

    pub fn device_node_mask<'m>(mut self, device_node_mask: u32) -> PhysicalDeviceIDPropertiesKhrBuilder<'b> {
        self.raw.deviceNodeMask = device_node_mask.into();
        self
    }

    pub fn device_luid_valid<'m>(mut self, device_luid_valid: bool) -> PhysicalDeviceIDPropertiesKhrBuilder<'b> {
        self.raw.deviceLUIDValid = device_luid_valid as u32;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_device_uuid<'a>(&'a self) -> &[u8] {
        unsafe { slice::from_raw_parts(&self.raw.deviceUUID as *const _, vks::VK_UUID_SIZE as usize) }
    }

    pub fn get_driver_uuid<'a>(&'a self) -> &[u8] {
        unsafe { slice::from_raw_parts(&self.raw.driverUUID as *const _, vks::VK_UUID_SIZE as usize) }
    }

    pub fn get_device_luid<'a>(&'a self) -> &[u8] {
        unsafe { slice::from_raw_parts(&self.raw.deviceLUID as *const _, vks::VK_LUID_SIZE_KHR as usize) }
    }

    pub fn get_device_node_mask<'a>(&'a self) -> u32 {
        self.raw.deviceNodeMask.into()
    }

    pub fn get_device_luid_valid<'a>(&'a self) -> bool {
        self.raw.deviceLUIDValid != 0
    }

    pub fn build(self) -> PhysicalDeviceIDPropertiesKhr<'b> {
        PhysicalDeviceIDPropertiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExternalMemoryImageCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExternalMemoryImageCreateInfoKhr<'s> {
    raw: vks::VkExternalMemoryImageCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExternalMemoryImageCreateInfoKhr<'s> {
    pub fn builder<'b>() -> ExternalMemoryImageCreateInfoKhrBuilder<'b> {
        ExternalMemoryImageCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExternalMemoryImageCreateInfoKHR) -> ExternalMemoryImageCreateInfoKhr<'s> {
        ExternalMemoryImageCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExternalMemoryImageCreateInfoKhr::handle_types: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_types<'m>(&mut self, handle_types: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.handleTypes = handle_types.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExternalMemoryImageCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<ExternalMemoryImageCreateInfoKhr<'s>> for vks::VkExternalMemoryImageCreateInfoKHR {
    fn from(f: ExternalMemoryImageCreateInfoKhr<'s>) -> vks::VkExternalMemoryImageCreateInfoKHR {
        f.raw
    }
}


/// A builder for `VkExternalMemoryImageCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExternalMemoryImageCreateInfoKhrBuilder<'b> {
    raw: vks::VkExternalMemoryImageCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ExternalMemoryImageCreateInfoKhrBuilder<'b> {
    pub fn new() -> ExternalMemoryImageCreateInfoKhrBuilder<'b> {
        ExternalMemoryImageCreateInfoKhrBuilder {
            raw: vks::VkExternalMemoryImageCreateInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExternalMemoryImageCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn handle_types<'m>(mut self, handle_types: ExternalMemoryHandleTypeFlagsKhr) -> ExternalMemoryImageCreateInfoKhrBuilder<'b> {
        self.raw.handleTypes = handle_types.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExternalMemoryImageCreateInfoKhr::handle_types: error converting flags")
    }

    pub fn build(self) -> ExternalMemoryImageCreateInfoKhr<'b> {
        ExternalMemoryImageCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExternalMemoryBufferCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExternalMemoryBufferCreateInfoKhr<'s> {
    raw: vks::VkExternalMemoryBufferCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExternalMemoryBufferCreateInfoKhr<'s> {
    pub fn builder<'b>() -> ExternalMemoryBufferCreateInfoKhrBuilder<'b> {
        ExternalMemoryBufferCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExternalMemoryBufferCreateInfoKHR) -> ExternalMemoryBufferCreateInfoKhr<'s> {
        ExternalMemoryBufferCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExternalMemoryBufferCreateInfoKhr::handle_types: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_types<'m>(&mut self, handle_types: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.handleTypes = handle_types.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExternalMemoryBufferCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<ExternalMemoryBufferCreateInfoKhr<'s>> for vks::VkExternalMemoryBufferCreateInfoKHR {
    fn from(f: ExternalMemoryBufferCreateInfoKhr<'s>) -> vks::VkExternalMemoryBufferCreateInfoKHR {
        f.raw
    }
}


/// A builder for `VkExternalMemoryBufferCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExternalMemoryBufferCreateInfoKhrBuilder<'b> {
    raw: vks::VkExternalMemoryBufferCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ExternalMemoryBufferCreateInfoKhrBuilder<'b> {
    pub fn new() -> ExternalMemoryBufferCreateInfoKhrBuilder<'b> {
        ExternalMemoryBufferCreateInfoKhrBuilder {
            raw: vks::VkExternalMemoryBufferCreateInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExternalMemoryBufferCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn handle_types<'m>(mut self, handle_types: ExternalMemoryHandleTypeFlagsKhr) -> ExternalMemoryBufferCreateInfoKhrBuilder<'b> {
        self.raw.handleTypes = handle_types.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExternalMemoryBufferCreateInfoKhr::handle_types: error converting flags")
    }

    pub fn build(self) -> ExternalMemoryBufferCreateInfoKhr<'b> {
        ExternalMemoryBufferCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExportMemoryAllocateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExportMemoryAllocateInfoKhr<'s> {
    raw: vks::VkExportMemoryAllocateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExportMemoryAllocateInfoKhr<'s> {
    pub fn builder<'b>() -> ExportMemoryAllocateInfoKhrBuilder<'b> {
        ExportMemoryAllocateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExportMemoryAllocateInfoKHR) -> ExportMemoryAllocateInfoKhr<'s> {
        ExportMemoryAllocateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExportMemoryAllocateInfoKhr::handle_types: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_types<'m>(&mut self, handle_types: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.handleTypes = handle_types.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExportMemoryAllocateInfoKHR {
        &self.raw
    }
}

impl<'s> From<ExportMemoryAllocateInfoKhr<'s>> for vks::VkExportMemoryAllocateInfoKHR {
    fn from(f: ExportMemoryAllocateInfoKhr<'s>) -> vks::VkExportMemoryAllocateInfoKHR {
        f.raw
    }
}


/// A builder for `VkExportMemoryAllocateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExportMemoryAllocateInfoKhrBuilder<'b> {
    raw: vks::VkExportMemoryAllocateInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ExportMemoryAllocateInfoKhrBuilder<'b> {
    pub fn new() -> ExportMemoryAllocateInfoKhrBuilder<'b> {
        ExportMemoryAllocateInfoKhrBuilder {
            raw: vks::VkExportMemoryAllocateInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExportMemoryAllocateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn handle_types<'m>(mut self, handle_types: ExternalMemoryHandleTypeFlagsKhr) -> ExportMemoryAllocateInfoKhrBuilder<'b> {
        self.raw.handleTypes = handle_types.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExportMemoryAllocateInfoKhr::handle_types: error converting flags")
    }

    pub fn build(self) -> ExportMemoryAllocateInfoKhr<'b> {
        ExportMemoryAllocateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImportMemoryWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImportMemoryWin32HandleInfoKhr<'s> {
    raw: vks::VkImportMemoryWin32HandleInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImportMemoryWin32HandleInfoKhr<'s> {
    pub fn builder<'b>() -> ImportMemoryWin32HandleInfoKhrBuilder<'b> {
        ImportMemoryWin32HandleInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImportMemoryWin32HandleInfoKHR) -> ImportMemoryWin32HandleInfoKhr<'s> {
        ImportMemoryWin32HandleInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportMemoryWin32HandleInfoKhr::handle_type: error converting flags")
    }

    pub fn handle<'a>(&'a self) -> HANDLE {
        self.raw.handle.into()
    }

    pub fn name<'a>(&'a self) -> LPCWSTR {
        self.raw.name.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn set_handle<'m>(&mut self, handle: HANDLE) {
        self.raw.handle = handle.into();
    }

    pub fn set_name<'m>(&mut self, name: LPCWSTR) {
        self.raw.name = name.into();
    }

    pub fn as_raw(&self) -> &vks::VkImportMemoryWin32HandleInfoKHR {
        &self.raw
    }
}

impl<'s> From<ImportMemoryWin32HandleInfoKhr<'s>> for vks::VkImportMemoryWin32HandleInfoKHR {
    fn from(f: ImportMemoryWin32HandleInfoKhr<'s>) -> vks::VkImportMemoryWin32HandleInfoKHR {
        f.raw
    }
}


/// A builder for `VkImportMemoryWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImportMemoryWin32HandleInfoKhrBuilder<'b> {
    raw: vks::VkImportMemoryWin32HandleInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ImportMemoryWin32HandleInfoKhrBuilder<'b> {
    pub fn new() -> ImportMemoryWin32HandleInfoKhrBuilder<'b> {
        ImportMemoryWin32HandleInfoKhrBuilder {
            raw: vks::VkImportMemoryWin32HandleInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImportMemoryWin32HandleInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) -> ImportMemoryWin32HandleInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self
    }

    pub fn handle<'m>(mut self, handle: HANDLE) -> ImportMemoryWin32HandleInfoKhrBuilder<'b> {
        self.raw.handle = handle.into();
        self
    }

    pub fn name<'m>(mut self, name: LPCWSTR) -> ImportMemoryWin32HandleInfoKhrBuilder<'b> {
        self.raw.name = name.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportMemoryWin32HandleInfoKhr::handle_type: error converting flags")
    }

    pub fn get_handle<'a>(&'a self) -> HANDLE {
        self.raw.handle.into()
    }

    pub fn get_name<'a>(&'a self) -> LPCWSTR {
        self.raw.name.into()
    }

    pub fn build(self) -> ImportMemoryWin32HandleInfoKhr<'b> {
        ImportMemoryWin32HandleInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExportMemoryWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExportMemoryWin32HandleInfoKhr<'s> {
    raw: vks::VkExportMemoryWin32HandleInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExportMemoryWin32HandleInfoKhr<'s> {
    pub fn builder<'b>() -> ExportMemoryWin32HandleInfoKhrBuilder<'b> {
        ExportMemoryWin32HandleInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExportMemoryWin32HandleInfoKHR) -> ExportMemoryWin32HandleInfoKhr<'s> {
        ExportMemoryWin32HandleInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn attributes<'a>(&'a self) -> &'a SECURITY_ATTRIBUTES {
        unsafe { &*(self.raw.pAttributes as *const _) }
    }

    pub fn dw_access<'a>(&'a self) -> DWORD {
        self.raw.dwAccess.into()
    }

    pub fn name<'a>(&'a self) -> LPCWSTR {
        self.raw.name.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_attributes<'m, 'a>(&mut self, attributes: &'a SECURITY_ATTRIBUTES) {
        self.raw.pAttributes = attributes;
    }

    pub fn set_dw_access<'m>(&mut self, dw_access: DWORD) {
        self.raw.dwAccess = dw_access.into();
    }

    pub fn set_name<'m>(&mut self, name: LPCWSTR) {
        self.raw.name = name.into();
    }

    pub fn as_raw(&self) -> &vks::VkExportMemoryWin32HandleInfoKHR {
        &self.raw
    }
}

impl<'s> From<ExportMemoryWin32HandleInfoKhr<'s>> for vks::VkExportMemoryWin32HandleInfoKHR {
    fn from(f: ExportMemoryWin32HandleInfoKhr<'s>) -> vks::VkExportMemoryWin32HandleInfoKHR {
        f.raw
    }
}


/// A builder for `VkExportMemoryWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExportMemoryWin32HandleInfoKhrBuilder<'b> {
    raw: vks::VkExportMemoryWin32HandleInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ExportMemoryWin32HandleInfoKhrBuilder<'b> {
    pub fn new() -> ExportMemoryWin32HandleInfoKhrBuilder<'b> {
        ExportMemoryWin32HandleInfoKhrBuilder {
            raw: vks::VkExportMemoryWin32HandleInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExportMemoryWin32HandleInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn attributes<'m, 'a>(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> ExportMemoryWin32HandleInfoKhrBuilder<'b> {
        self.raw.pAttributes = attributes;
        self
    }

    pub fn dw_access<'m>(mut self, dw_access: DWORD) -> ExportMemoryWin32HandleInfoKhrBuilder<'b> {
        self.raw.dwAccess = dw_access.into();
        self
    }

    pub fn name<'m>(mut self, name: LPCWSTR) -> ExportMemoryWin32HandleInfoKhrBuilder<'b> {
        self.raw.name = name.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_attributes<'a>(&'a self) -> &'a SECURITY_ATTRIBUTES {
        unsafe { &*(self.raw.pAttributes as *const _) }
    }

    pub fn get_dw_access<'a>(&'a self) -> DWORD {
        self.raw.dwAccess.into()
    }

    pub fn get_name<'a>(&'a self) -> LPCWSTR {
        self.raw.name.into()
    }

    pub fn build(self) -> ExportMemoryWin32HandleInfoKhr<'b> {
        ExportMemoryWin32HandleInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMemoryWin32HandlePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryWin32HandlePropertiesKhr<'s> {
    raw: vks::VkMemoryWin32HandlePropertiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> MemoryWin32HandlePropertiesKhr<'s> {
    pub fn builder<'b>() -> MemoryWin32HandlePropertiesKhrBuilder<'b> {
        MemoryWin32HandlePropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryWin32HandlePropertiesKHR) -> MemoryWin32HandlePropertiesKhr<'s> {
        MemoryWin32HandlePropertiesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn memory_type_bits<'a>(&'a self) -> u32 {
        self.raw.memoryTypeBits.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_memory_type_bits<'m>(&mut self, memory_type_bits: u32) {
        self.raw.memoryTypeBits = memory_type_bits.into();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryWin32HandlePropertiesKHR {
        &self.raw
    }
}

impl<'s> From<MemoryWin32HandlePropertiesKhr<'s>> for vks::VkMemoryWin32HandlePropertiesKHR {
    fn from(f: MemoryWin32HandlePropertiesKhr<'s>) -> vks::VkMemoryWin32HandlePropertiesKHR {
        f.raw
    }
}


/// A builder for `VkMemoryWin32HandlePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryWin32HandlePropertiesKhrBuilder<'b> {
    raw: vks::VkMemoryWin32HandlePropertiesKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> MemoryWin32HandlePropertiesKhrBuilder<'b> {
    pub fn new() -> MemoryWin32HandlePropertiesKhrBuilder<'b> {
        MemoryWin32HandlePropertiesKhrBuilder {
            raw: vks::VkMemoryWin32HandlePropertiesKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> MemoryWin32HandlePropertiesKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn memory_type_bits<'m>(mut self, memory_type_bits: u32) -> MemoryWin32HandlePropertiesKhrBuilder<'b> {
        self.raw.memoryTypeBits = memory_type_bits.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_memory_type_bits<'a>(&'a self) -> u32 {
        self.raw.memoryTypeBits.into()
    }

    pub fn build(self) -> MemoryWin32HandlePropertiesKhr<'b> {
        MemoryWin32HandlePropertiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMemoryGetWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryGetWin32HandleInfoKhr<'s> {
    raw: vks::VkMemoryGetWin32HandleInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> MemoryGetWin32HandleInfoKhr<'s> {
    pub fn builder<'b>() -> MemoryGetWin32HandleInfoKhrBuilder<'b> {
        MemoryGetWin32HandleInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryGetWin32HandleInfoKHR) -> MemoryGetWin32HandleInfoKhr<'s> {
        MemoryGetWin32HandleInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn memory<'a>(&'a self) -> vks::VkDeviceMemory {
        self.raw.memory
    }

    pub fn handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("MemoryGetWin32HandleInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_memory<'m, H>(&mut self, memory: H)
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryGetWin32HandleInfoKHR {
        &self.raw
    }
}

impl<'s> From<MemoryGetWin32HandleInfoKhr<'s>> for vks::VkMemoryGetWin32HandleInfoKHR {
    fn from(f: MemoryGetWin32HandleInfoKhr<'s>) -> vks::VkMemoryGetWin32HandleInfoKHR {
        f.raw
    }
}


/// A builder for `VkMemoryGetWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryGetWin32HandleInfoKhrBuilder<'b> {
    raw: vks::VkMemoryGetWin32HandleInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> MemoryGetWin32HandleInfoKhrBuilder<'b> {
    pub fn new() -> MemoryGetWin32HandleInfoKhrBuilder<'b> {
        MemoryGetWin32HandleInfoKhrBuilder {
            raw: vks::VkMemoryGetWin32HandleInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> MemoryGetWin32HandleInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn memory<'m, H>(mut self, memory: H) -> MemoryGetWin32HandleInfoKhrBuilder<'b>
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) -> MemoryGetWin32HandleInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_memory<'a>(&'a self) -> vks::VkDeviceMemory {
        self.raw.memory
    }

    pub fn get_handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("MemoryGetWin32HandleInfoKhr::handle_type: error converting flags")
    }

    pub fn build(self) -> MemoryGetWin32HandleInfoKhr<'b> {
        MemoryGetWin32HandleInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImportMemoryFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImportMemoryFdInfoKhr<'s> {
    raw: vks::VkImportMemoryFdInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImportMemoryFdInfoKhr<'s> {
    pub fn builder<'b>() -> ImportMemoryFdInfoKhrBuilder<'b> {
        ImportMemoryFdInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImportMemoryFdInfoKHR) -> ImportMemoryFdInfoKhr<'s> {
        ImportMemoryFdInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportMemoryFdInfoKhr::handle_type: error converting flags")
    }

    pub fn fd<'a>(&'a self) -> i32 {
        self.raw.fd.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn set_fd<'m>(&mut self, fd: i32) {
        self.raw.fd = fd.into();
    }

    pub fn as_raw(&self) -> &vks::VkImportMemoryFdInfoKHR {
        &self.raw
    }
}

impl<'s> From<ImportMemoryFdInfoKhr<'s>> for vks::VkImportMemoryFdInfoKHR {
    fn from(f: ImportMemoryFdInfoKhr<'s>) -> vks::VkImportMemoryFdInfoKHR {
        f.raw
    }
}


/// A builder for `VkImportMemoryFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImportMemoryFdInfoKhrBuilder<'b> {
    raw: vks::VkImportMemoryFdInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ImportMemoryFdInfoKhrBuilder<'b> {
    pub fn new() -> ImportMemoryFdInfoKhrBuilder<'b> {
        ImportMemoryFdInfoKhrBuilder {
            raw: vks::VkImportMemoryFdInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImportMemoryFdInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) -> ImportMemoryFdInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self
    }

    pub fn fd<'m>(mut self, fd: i32) -> ImportMemoryFdInfoKhrBuilder<'b> {
        self.raw.fd = fd.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportMemoryFdInfoKhr::handle_type: error converting flags")
    }

    pub fn get_fd<'a>(&'a self) -> i32 {
        self.raw.fd.into()
    }

    pub fn build(self) -> ImportMemoryFdInfoKhr<'b> {
        ImportMemoryFdInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMemoryFdPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryFdPropertiesKhr<'s> {
    raw: vks::VkMemoryFdPropertiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> MemoryFdPropertiesKhr<'s> {
    pub fn builder<'b>() -> MemoryFdPropertiesKhrBuilder<'b> {
        MemoryFdPropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryFdPropertiesKHR) -> MemoryFdPropertiesKhr<'s> {
        MemoryFdPropertiesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn memory_type_bits<'a>(&'a self) -> u32 {
        self.raw.memoryTypeBits.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_memory_type_bits<'m>(&mut self, memory_type_bits: u32) {
        self.raw.memoryTypeBits = memory_type_bits.into();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryFdPropertiesKHR {
        &self.raw
    }
}

impl<'s> From<MemoryFdPropertiesKhr<'s>> for vks::VkMemoryFdPropertiesKHR {
    fn from(f: MemoryFdPropertiesKhr<'s>) -> vks::VkMemoryFdPropertiesKHR {
        f.raw
    }
}


/// A builder for `VkMemoryFdPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryFdPropertiesKhrBuilder<'b> {
    raw: vks::VkMemoryFdPropertiesKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> MemoryFdPropertiesKhrBuilder<'b> {
    pub fn new() -> MemoryFdPropertiesKhrBuilder<'b> {
        MemoryFdPropertiesKhrBuilder {
            raw: vks::VkMemoryFdPropertiesKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> MemoryFdPropertiesKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn memory_type_bits<'m>(mut self, memory_type_bits: u32) -> MemoryFdPropertiesKhrBuilder<'b> {
        self.raw.memoryTypeBits = memory_type_bits.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_memory_type_bits<'a>(&'a self) -> u32 {
        self.raw.memoryTypeBits.into()
    }

    pub fn build(self) -> MemoryFdPropertiesKhr<'b> {
        MemoryFdPropertiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMemoryGetFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryGetFdInfoKhr<'s> {
    raw: vks::VkMemoryGetFdInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> MemoryGetFdInfoKhr<'s> {
    pub fn builder<'b>() -> MemoryGetFdInfoKhrBuilder<'b> {
        MemoryGetFdInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryGetFdInfoKHR) -> MemoryGetFdInfoKhr<'s> {
        MemoryGetFdInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn memory<'a>(&'a self) -> vks::VkDeviceMemory {
        self.raw.memory
    }

    pub fn handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("MemoryGetFdInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_memory<'m, H>(&mut self, memory: H)
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryGetFdInfoKHR {
        &self.raw
    }
}

impl<'s> From<MemoryGetFdInfoKhr<'s>> for vks::VkMemoryGetFdInfoKHR {
    fn from(f: MemoryGetFdInfoKhr<'s>) -> vks::VkMemoryGetFdInfoKHR {
        f.raw
    }
}


/// A builder for `VkMemoryGetFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryGetFdInfoKhrBuilder<'b> {
    raw: vks::VkMemoryGetFdInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> MemoryGetFdInfoKhrBuilder<'b> {
    pub fn new() -> MemoryGetFdInfoKhrBuilder<'b> {
        MemoryGetFdInfoKhrBuilder {
            raw: vks::VkMemoryGetFdInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> MemoryGetFdInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn memory<'m, H>(mut self, memory: H) -> MemoryGetFdInfoKhrBuilder<'b>
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) -> MemoryGetFdInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_memory<'a>(&'a self) -> vks::VkDeviceMemory {
        self.raw.memory
    }

    pub fn get_handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("MemoryGetFdInfoKhr::handle_type: error converting flags")
    }

    pub fn build(self) -> MemoryGetFdInfoKhr<'b> {
        MemoryGetFdInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkWin32KeyedMutexAcquireReleaseInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct Win32KeyedMutexAcquireReleaseInfoKhr<'s> {
    raw: vks::VkWin32KeyedMutexAcquireReleaseInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> Win32KeyedMutexAcquireReleaseInfoKhr<'s> {
    pub fn builder<'b>() -> Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b> {
        Win32KeyedMutexAcquireReleaseInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkWin32KeyedMutexAcquireReleaseInfoKHR) -> Win32KeyedMutexAcquireReleaseInfoKhr<'s> {
        Win32KeyedMutexAcquireReleaseInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn acquire_syncs<'a>(&'a self) -> &'a [vks::VkDeviceMemory] {
        unsafe { slice::from_raw_parts(self.raw.pAcquireSyncs as *const _, self.raw.acquireCount as usize) }
    }

    pub fn acquire_keys<'a>(&'a self) -> &'a [u64] {
        unsafe { slice::from_raw_parts(self.raw.pAcquireKeys as *const _, self.raw.acquireCount as usize) }
    }

    pub fn acquire_timeouts<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pAcquireTimeouts as *const _, self.raw.acquireCount as usize) }
    }

    pub fn release_syncs<'a>(&'a self) -> &'a [vks::VkDeviceMemory] {
        unsafe { slice::from_raw_parts(self.raw.pReleaseSyncs as *const _, self.raw.releaseCount as usize) }
    }

    pub fn release_keys<'a>(&'a self) -> &'a [u64] {
        unsafe { slice::from_raw_parts(self.raw.pReleaseKeys as *const _, self.raw.releaseCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_acquire_syncs<'m, 'a>(&mut self, acquire_syncs: &'a [DeviceMemoryHandle])
            where 'a: 's {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_syncs.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::acquire_syncs`.");
        self.raw.acquireCount = acquire_syncs.len() as _;
        self.raw.pAcquireSyncs = acquire_syncs.as_ptr() as *const vks::VkDeviceMemory;
    }

    pub fn set_acquire_keys<'m, 'a>(&mut self, acquire_keys: &'a [u64])
            where 'a: 's {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_keys.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::acquire_keys`.");
        self.raw.acquireCount = acquire_keys.len() as _;
        self.raw.pAcquireKeys = acquire_keys.as_ptr() as *const u64 as *const _;
    }

    pub fn set_acquire_timeouts<'m, 'a>(&mut self, acquire_timeouts: &'a [u32])
            where 'a: 's {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_timeouts.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::acquire_timeouts`.");
        self.raw.acquireCount = acquire_timeouts.len() as _;
        self.raw.pAcquireTimeouts = acquire_timeouts.as_ptr() as *const u32 as *const _;
    }

    pub fn set_release_syncs<'m, 'a>(&mut self, release_syncs: &'a [DeviceMemoryHandle])
            where 'a: 's {
        assert!(self.raw.releaseCount == 0 || self.raw.releaseCount == release_syncs.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::release_syncs`.");
        self.raw.releaseCount = release_syncs.len() as _;
        self.raw.pReleaseSyncs = release_syncs.as_ptr() as *const vks::VkDeviceMemory;
    }

    pub fn set_release_keys<'m, 'a>(&mut self, release_keys: &'a [u64])
            where 'a: 's {
        assert!(self.raw.releaseCount == 0 || self.raw.releaseCount == release_keys.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::release_keys`.");
        self.raw.releaseCount = release_keys.len() as _;
        self.raw.pReleaseKeys = release_keys.as_ptr() as *const u64 as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkWin32KeyedMutexAcquireReleaseInfoKHR {
        &self.raw
    }
}

impl<'s> From<Win32KeyedMutexAcquireReleaseInfoKhr<'s>> for vks::VkWin32KeyedMutexAcquireReleaseInfoKHR {
    fn from(f: Win32KeyedMutexAcquireReleaseInfoKhr<'s>) -> vks::VkWin32KeyedMutexAcquireReleaseInfoKHR {
        f.raw
    }
}


/// A builder for `VkWin32KeyedMutexAcquireReleaseInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b> {
    raw: vks::VkWin32KeyedMutexAcquireReleaseInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b> {
    pub fn new() -> Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b> {
        Win32KeyedMutexAcquireReleaseInfoKhrBuilder {
            raw: vks::VkWin32KeyedMutexAcquireReleaseInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn acquire_syncs<'m, 'a>(mut self, acquire_syncs: &'a [DeviceMemoryHandle]) -> Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_syncs.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::acquire_syncs`.");
        self.raw.acquireCount = acquire_syncs.len() as _;
        self.raw.pAcquireSyncs = acquire_syncs.as_ptr() as *const vks::VkDeviceMemory;
        self
    }

    pub fn acquire_keys<'m, 'a>(mut self, acquire_keys: &'a [u64]) -> Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_keys.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::acquire_keys`.");
        self.raw.acquireCount = acquire_keys.len() as _;
        self.raw.pAcquireKeys = acquire_keys.as_ptr() as *const u64 as *const _;
        self
    }

    pub fn acquire_timeouts<'m, 'a>(mut self, acquire_timeouts: &'a [u32]) -> Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_timeouts.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::acquire_timeouts`.");
        self.raw.acquireCount = acquire_timeouts.len() as _;
        self.raw.pAcquireTimeouts = acquire_timeouts.as_ptr() as *const u32 as *const _;
        self
    }

    pub fn release_syncs<'m, 'a>(mut self, release_syncs: &'a [DeviceMemoryHandle]) -> Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.releaseCount == 0 || self.raw.releaseCount == release_syncs.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::release_syncs`.");
        self.raw.releaseCount = release_syncs.len() as _;
        self.raw.pReleaseSyncs = release_syncs.as_ptr() as *const vks::VkDeviceMemory;
        self
    }

    pub fn release_keys<'m, 'a>(mut self, release_keys: &'a [u64]) -> Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.releaseCount == 0 || self.raw.releaseCount == release_keys.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::release_keys`.");
        self.raw.releaseCount = release_keys.len() as _;
        self.raw.pReleaseKeys = release_keys.as_ptr() as *const u64 as *const _;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_acquire_syncs<'a>(&'a self) -> &'a [vks::VkDeviceMemory] {
        unsafe { slice::from_raw_parts(self.raw.pAcquireSyncs as *const _, self.raw.acquireCount as usize) }
    }

    pub fn get_acquire_keys<'a>(&'a self) -> &'a [u64] {
        unsafe { slice::from_raw_parts(self.raw.pAcquireKeys as *const _, self.raw.acquireCount as usize) }
    }

    pub fn get_acquire_timeouts<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pAcquireTimeouts as *const _, self.raw.acquireCount as usize) }
    }

    pub fn get_release_syncs<'a>(&'a self) -> &'a [vks::VkDeviceMemory] {
        unsafe { slice::from_raw_parts(self.raw.pReleaseSyncs as *const _, self.raw.releaseCount as usize) }
    }

    pub fn get_release_keys<'a>(&'a self) -> &'a [u64] {
        unsafe { slice::from_raw_parts(self.raw.pReleaseKeys as *const _, self.raw.releaseCount as usize) }
    }

    pub fn build(self) -> Win32KeyedMutexAcquireReleaseInfoKhr<'b> {
        Win32KeyedMutexAcquireReleaseInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceExternalSemaphoreInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceExternalSemaphoreInfoKhr<'s> {
    raw: vks::VkPhysicalDeviceExternalSemaphoreInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceExternalSemaphoreInfoKhr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceExternalSemaphoreInfoKhrBuilder<'b> {
        PhysicalDeviceExternalSemaphoreInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceExternalSemaphoreInfoKHR) -> PhysicalDeviceExternalSemaphoreInfoKhr<'s> {
        PhysicalDeviceExternalSemaphoreInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_type<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("PhysicalDeviceExternalSemaphoreInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceExternalSemaphoreInfoKHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceExternalSemaphoreInfoKhr<'s>> for vks::VkPhysicalDeviceExternalSemaphoreInfoKHR {
    fn from(f: PhysicalDeviceExternalSemaphoreInfoKhr<'s>) -> vks::VkPhysicalDeviceExternalSemaphoreInfoKHR {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceExternalSemaphoreInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceExternalSemaphoreInfoKhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceExternalSemaphoreInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PhysicalDeviceExternalSemaphoreInfoKhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceExternalSemaphoreInfoKhrBuilder<'b> {
        PhysicalDeviceExternalSemaphoreInfoKhrBuilder {
            raw: vks::VkPhysicalDeviceExternalSemaphoreInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PhysicalDeviceExternalSemaphoreInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) -> PhysicalDeviceExternalSemaphoreInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_handle_type<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("PhysicalDeviceExternalSemaphoreInfoKhr::handle_type: error converting flags")
    }

    pub fn build(self) -> PhysicalDeviceExternalSemaphoreInfoKhr<'b> {
        PhysicalDeviceExternalSemaphoreInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExternalSemaphorePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExternalSemaphorePropertiesKhr<'s> {
    raw: vks::VkExternalSemaphorePropertiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExternalSemaphorePropertiesKhr<'s> {
    pub fn builder<'b>() -> ExternalSemaphorePropertiesKhrBuilder<'b> {
        ExternalSemaphorePropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExternalSemaphorePropertiesKHR) -> ExternalSemaphorePropertiesKhr<'s> {
        ExternalSemaphorePropertiesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn export_from_imported_handle_types<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.exportFromImportedHandleTypes)
            .expect("ExternalSemaphorePropertiesKhr::export_from_imported_handle_types: error converting flags")
    }

    pub fn compatible_handle_types<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.compatibleHandleTypes)
            .expect("ExternalSemaphorePropertiesKhr::compatible_handle_types: error converting flags")
    }

    pub fn external_semaphore_features<'a>(&'a self) -> ExternalSemaphoreFeatureFlagsKhr {
        ExternalSemaphoreFeatureFlagsKhr::from_bits(self.raw.externalSemaphoreFeatures)
            .expect("ExternalSemaphorePropertiesKhr::external_semaphore_features: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_export_from_imported_handle_types<'m>(&mut self, export_from_imported_handle_types: ExternalSemaphoreHandleTypeFlagsKhr) {
        self.raw.exportFromImportedHandleTypes = export_from_imported_handle_types.bits();
    }

    pub fn set_compatible_handle_types<'m>(&mut self, compatible_handle_types: ExternalSemaphoreHandleTypeFlagsKhr) {
        self.raw.compatibleHandleTypes = compatible_handle_types.bits();
    }

    pub fn set_external_semaphore_features<'m>(&mut self, external_semaphore_features: ExternalSemaphoreFeatureFlagsKhr) {
        self.raw.externalSemaphoreFeatures = external_semaphore_features.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExternalSemaphorePropertiesKHR {
        &self.raw
    }
}

impl<'s> From<ExternalSemaphorePropertiesKhr<'s>> for vks::VkExternalSemaphorePropertiesKHR {
    fn from(f: ExternalSemaphorePropertiesKhr<'s>) -> vks::VkExternalSemaphorePropertiesKHR {
        f.raw
    }
}


/// A builder for `VkExternalSemaphorePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExternalSemaphorePropertiesKhrBuilder<'b> {
    raw: vks::VkExternalSemaphorePropertiesKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ExternalSemaphorePropertiesKhrBuilder<'b> {
    pub fn new() -> ExternalSemaphorePropertiesKhrBuilder<'b> {
        ExternalSemaphorePropertiesKhrBuilder {
            raw: vks::VkExternalSemaphorePropertiesKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> ExternalSemaphorePropertiesKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn export_from_imported_handle_types<'m>(mut self, export_from_imported_handle_types: ExternalSemaphoreHandleTypeFlagsKhr) -> ExternalSemaphorePropertiesKhrBuilder<'b> {
        self.raw.exportFromImportedHandleTypes = export_from_imported_handle_types.bits();
        self
    }

    pub fn compatible_handle_types<'m>(mut self, compatible_handle_types: ExternalSemaphoreHandleTypeFlagsKhr) -> ExternalSemaphorePropertiesKhrBuilder<'b> {
        self.raw.compatibleHandleTypes = compatible_handle_types.bits();
        self
    }

    pub fn external_semaphore_features<'m>(mut self, external_semaphore_features: ExternalSemaphoreFeatureFlagsKhr) -> ExternalSemaphorePropertiesKhrBuilder<'b> {
        self.raw.externalSemaphoreFeatures = external_semaphore_features.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_export_from_imported_handle_types<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.exportFromImportedHandleTypes)
            .expect("ExternalSemaphorePropertiesKhr::export_from_imported_handle_types: error converting flags")
    }

    pub fn get_compatible_handle_types<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.compatibleHandleTypes)
            .expect("ExternalSemaphorePropertiesKhr::compatible_handle_types: error converting flags")
    }

    pub fn get_external_semaphore_features<'a>(&'a self) -> ExternalSemaphoreFeatureFlagsKhr {
        ExternalSemaphoreFeatureFlagsKhr::from_bits(self.raw.externalSemaphoreFeatures)
            .expect("ExternalSemaphorePropertiesKhr::external_semaphore_features: error converting flags")
    }

    pub fn build(self) -> ExternalSemaphorePropertiesKhr<'b> {
        ExternalSemaphorePropertiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExportSemaphoreCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExportSemaphoreCreateInfoKhr<'s> {
    raw: vks::VkExportSemaphoreCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExportSemaphoreCreateInfoKhr<'s> {
    pub fn builder<'b>() -> ExportSemaphoreCreateInfoKhrBuilder<'b> {
        ExportSemaphoreCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExportSemaphoreCreateInfoKHR) -> ExportSemaphoreCreateInfoKhr<'s> {
        ExportSemaphoreCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_types<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExportSemaphoreCreateInfoKhr::handle_types: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_types<'m>(&mut self, handle_types: ExternalSemaphoreHandleTypeFlagsKhr) {
        self.raw.handleTypes = handle_types.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExportSemaphoreCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<ExportSemaphoreCreateInfoKhr<'s>> for vks::VkExportSemaphoreCreateInfoKHR {
    fn from(f: ExportSemaphoreCreateInfoKhr<'s>) -> vks::VkExportSemaphoreCreateInfoKHR {
        f.raw
    }
}


/// A builder for `VkExportSemaphoreCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExportSemaphoreCreateInfoKhrBuilder<'b> {
    raw: vks::VkExportSemaphoreCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ExportSemaphoreCreateInfoKhrBuilder<'b> {
    pub fn new() -> ExportSemaphoreCreateInfoKhrBuilder<'b> {
        ExportSemaphoreCreateInfoKhrBuilder {
            raw: vks::VkExportSemaphoreCreateInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExportSemaphoreCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn handle_types<'m>(mut self, handle_types: ExternalSemaphoreHandleTypeFlagsKhr) -> ExportSemaphoreCreateInfoKhrBuilder<'b> {
        self.raw.handleTypes = handle_types.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_handle_types<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExportSemaphoreCreateInfoKhr::handle_types: error converting flags")
    }

    pub fn build(self) -> ExportSemaphoreCreateInfoKhr<'b> {
        ExportSemaphoreCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImportSemaphoreWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImportSemaphoreWin32HandleInfoKhr<'s> {
    raw: vks::VkImportSemaphoreWin32HandleInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImportSemaphoreWin32HandleInfoKhr<'s> {
    pub fn builder<'b>() -> ImportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        ImportSemaphoreWin32HandleInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImportSemaphoreWin32HandleInfoKHR) -> ImportSemaphoreWin32HandleInfoKhr<'s> {
        ImportSemaphoreWin32HandleInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn semaphore<'a>(&'a self) -> vks::VkSemaphore {
        self.raw.semaphore
    }

    pub fn flags<'a>(&'a self) -> SemaphoreImportFlagsKhr {
        SemaphoreImportFlagsKhr::from_bits(self.raw.flags)
            .expect("ImportSemaphoreWin32HandleInfoKhr::flags: error converting flags")
    }

    pub fn handle_type<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportSemaphoreWin32HandleInfoKhr::handle_type: error converting flags")
    }

    pub fn handle<'a>(&'a self) -> HANDLE {
        self.raw.handle.into()
    }

    pub fn name<'a>(&'a self) -> LPCWSTR {
        self.raw.name.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_semaphore<'m, H>(&mut self, semaphore: H)
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
    }

    pub fn set_flags<'m>(&mut self, flags: SemaphoreImportFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn set_handle<'m>(&mut self, handle: HANDLE) {
        self.raw.handle = handle.into();
    }

    pub fn set_name<'m>(&mut self, name: LPCWSTR) {
        self.raw.name = name.into();
    }

    pub fn as_raw(&self) -> &vks::VkImportSemaphoreWin32HandleInfoKHR {
        &self.raw
    }
}

impl<'s> From<ImportSemaphoreWin32HandleInfoKhr<'s>> for vks::VkImportSemaphoreWin32HandleInfoKHR {
    fn from(f: ImportSemaphoreWin32HandleInfoKhr<'s>) -> vks::VkImportSemaphoreWin32HandleInfoKHR {
        f.raw
    }
}


/// A builder for `VkImportSemaphoreWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImportSemaphoreWin32HandleInfoKhrBuilder<'b> {
    raw: vks::VkImportSemaphoreWin32HandleInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ImportSemaphoreWin32HandleInfoKhrBuilder<'b> {
    pub fn new() -> ImportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        ImportSemaphoreWin32HandleInfoKhrBuilder {
            raw: vks::VkImportSemaphoreWin32HandleInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn semaphore<'m, H>(mut self, semaphore: H) -> ImportSemaphoreWin32HandleInfoKhrBuilder<'b>
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
        self
    }

    pub fn flags<'m>(mut self, flags: SemaphoreImportFlagsKhr) -> ImportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) -> ImportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self
    }

    pub fn handle<'m>(mut self, handle: HANDLE) -> ImportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        self.raw.handle = handle.into();
        self
    }

    pub fn name<'m>(mut self, name: LPCWSTR) -> ImportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        self.raw.name = name.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_semaphore<'a>(&'a self) -> vks::VkSemaphore {
        self.raw.semaphore
    }

    pub fn get_flags<'a>(&'a self) -> SemaphoreImportFlagsKhr {
        SemaphoreImportFlagsKhr::from_bits(self.raw.flags)
            .expect("ImportSemaphoreWin32HandleInfoKhr::flags: error converting flags")
    }

    pub fn get_handle_type<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportSemaphoreWin32HandleInfoKhr::handle_type: error converting flags")
    }

    pub fn get_handle<'a>(&'a self) -> HANDLE {
        self.raw.handle.into()
    }

    pub fn get_name<'a>(&'a self) -> LPCWSTR {
        self.raw.name.into()
    }

    pub fn build(self) -> ImportSemaphoreWin32HandleInfoKhr<'b> {
        ImportSemaphoreWin32HandleInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExportSemaphoreWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExportSemaphoreWin32HandleInfoKhr<'s> {
    raw: vks::VkExportSemaphoreWin32HandleInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExportSemaphoreWin32HandleInfoKhr<'s> {
    pub fn builder<'b>() -> ExportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        ExportSemaphoreWin32HandleInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExportSemaphoreWin32HandleInfoKHR) -> ExportSemaphoreWin32HandleInfoKhr<'s> {
        ExportSemaphoreWin32HandleInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn attributes<'a>(&'a self) -> &'a SECURITY_ATTRIBUTES {
        unsafe { &*(self.raw.pAttributes as *const _) }
    }

    pub fn dw_access<'a>(&'a self) -> DWORD {
        self.raw.dwAccess.into()
    }

    pub fn name<'a>(&'a self) -> LPCWSTR {
        self.raw.name.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_attributes<'m, 'a>(&mut self, attributes: &'a SECURITY_ATTRIBUTES) {
        self.raw.pAttributes = attributes;
    }

    pub fn set_dw_access<'m>(&mut self, dw_access: DWORD) {
        self.raw.dwAccess = dw_access.into();
    }

    pub fn set_name<'m>(&mut self, name: LPCWSTR) {
        self.raw.name = name.into();
    }

    pub fn as_raw(&self) -> &vks::VkExportSemaphoreWin32HandleInfoKHR {
        &self.raw
    }
}

impl<'s> From<ExportSemaphoreWin32HandleInfoKhr<'s>> for vks::VkExportSemaphoreWin32HandleInfoKHR {
    fn from(f: ExportSemaphoreWin32HandleInfoKhr<'s>) -> vks::VkExportSemaphoreWin32HandleInfoKHR {
        f.raw
    }
}


/// A builder for `VkExportSemaphoreWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExportSemaphoreWin32HandleInfoKhrBuilder<'b> {
    raw: vks::VkExportSemaphoreWin32HandleInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ExportSemaphoreWin32HandleInfoKhrBuilder<'b> {
    pub fn new() -> ExportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        ExportSemaphoreWin32HandleInfoKhrBuilder {
            raw: vks::VkExportSemaphoreWin32HandleInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn attributes<'m, 'a>(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> ExportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        self.raw.pAttributes = attributes;
        self
    }

    pub fn dw_access<'m>(mut self, dw_access: DWORD) -> ExportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        self.raw.dwAccess = dw_access.into();
        self
    }

    pub fn name<'m>(mut self, name: LPCWSTR) -> ExportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        self.raw.name = name.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_attributes<'a>(&'a self) -> &'a SECURITY_ATTRIBUTES {
        unsafe { &*(self.raw.pAttributes as *const _) }
    }

    pub fn get_dw_access<'a>(&'a self) -> DWORD {
        self.raw.dwAccess.into()
    }

    pub fn get_name<'a>(&'a self) -> LPCWSTR {
        self.raw.name.into()
    }

    pub fn build(self) -> ExportSemaphoreWin32HandleInfoKhr<'b> {
        ExportSemaphoreWin32HandleInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkD3D12FenceSubmitInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct D3d12FenceSubmitInfoKHR<'s> {
    raw: vks::VkD3D12FenceSubmitInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> D3d12FenceSubmitInfoKHR<'s> {
    pub fn builder<'b>() -> D3d12FenceSubmitInfoKHRBuilder<'b> {
        D3d12FenceSubmitInfoKHRBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkD3D12FenceSubmitInfoKHR) -> D3d12FenceSubmitInfoKHR<'s> {
        D3d12FenceSubmitInfoKHR { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn wait_semaphore_values<'a>(&'a self) -> &'a [u64] {
        unsafe { slice::from_raw_parts(self.raw.pWaitSemaphoreValues as *const _, self.raw.waitSemaphoreValuesCount as usize) }
    }

    pub fn signal_semaphore_values<'a>(&'a self) -> &'a [u64] {
        unsafe { slice::from_raw_parts(self.raw.pSignalSemaphoreValues as *const _, self.raw.signalSemaphoreValuesCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_wait_semaphore_values<'m, 'a>(&mut self, wait_semaphore_values: &'a [u64])
            where 'a: 's {
        assert!(self.raw.waitSemaphoreValuesCount == 0 || self.raw.waitSemaphoreValuesCount == wait_semaphore_values.len() as _, 
            "count inconsistency found when specifying `D3d12FenceSubmitInfoKHR::wait_semaphore_values`.");
        self.raw.waitSemaphoreValuesCount = wait_semaphore_values.len() as _;
        self.raw.pWaitSemaphoreValues = wait_semaphore_values.as_ptr() as *const u64 as *const _;
    }

    pub fn set_signal_semaphore_values<'m, 'a>(&mut self, signal_semaphore_values: &'a [u64])
            where 'a: 's {
        assert!(self.raw.signalSemaphoreValuesCount == 0 || self.raw.signalSemaphoreValuesCount == signal_semaphore_values.len() as _, 
            "count inconsistency found when specifying `D3d12FenceSubmitInfoKHR::signal_semaphore_values`.");
        self.raw.signalSemaphoreValuesCount = signal_semaphore_values.len() as _;
        self.raw.pSignalSemaphoreValues = signal_semaphore_values.as_ptr() as *const u64 as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkD3D12FenceSubmitInfoKHR {
        &self.raw
    }
}

impl<'s> From<D3d12FenceSubmitInfoKHR<'s>> for vks::VkD3D12FenceSubmitInfoKHR {
    fn from(f: D3d12FenceSubmitInfoKHR<'s>) -> vks::VkD3D12FenceSubmitInfoKHR {
        f.raw
    }
}


/// A builder for `VkD3D12FenceSubmitInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct D3d12FenceSubmitInfoKHRBuilder<'b> {
    raw: vks::VkD3D12FenceSubmitInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> D3d12FenceSubmitInfoKHRBuilder<'b> {
    pub fn new() -> D3d12FenceSubmitInfoKHRBuilder<'b> {
        D3d12FenceSubmitInfoKHRBuilder {
            raw: vks::VkD3D12FenceSubmitInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> D3d12FenceSubmitInfoKHRBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn wait_semaphore_values<'m, 'a>(mut self, wait_semaphore_values: &'a [u64]) -> D3d12FenceSubmitInfoKHRBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.waitSemaphoreValuesCount == 0 || self.raw.waitSemaphoreValuesCount == wait_semaphore_values.len() as _, 
            "count inconsistency found when specifying `D3d12FenceSubmitInfoKHR::wait_semaphore_values`.");
        self.raw.waitSemaphoreValuesCount = wait_semaphore_values.len() as _;
        self.raw.pWaitSemaphoreValues = wait_semaphore_values.as_ptr() as *const u64 as *const _;
        self
    }

    pub fn signal_semaphore_values<'m, 'a>(mut self, signal_semaphore_values: &'a [u64]) -> D3d12FenceSubmitInfoKHRBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.signalSemaphoreValuesCount == 0 || self.raw.signalSemaphoreValuesCount == signal_semaphore_values.len() as _, 
            "count inconsistency found when specifying `D3d12FenceSubmitInfoKHR::signal_semaphore_values`.");
        self.raw.signalSemaphoreValuesCount = signal_semaphore_values.len() as _;
        self.raw.pSignalSemaphoreValues = signal_semaphore_values.as_ptr() as *const u64 as *const _;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_wait_semaphore_values<'a>(&'a self) -> &'a [u64] {
        unsafe { slice::from_raw_parts(self.raw.pWaitSemaphoreValues as *const _, self.raw.waitSemaphoreValuesCount as usize) }
    }

    pub fn get_signal_semaphore_values<'a>(&'a self) -> &'a [u64] {
        unsafe { slice::from_raw_parts(self.raw.pSignalSemaphoreValues as *const _, self.raw.signalSemaphoreValuesCount as usize) }
    }

    pub fn build(self) -> D3d12FenceSubmitInfoKHR<'b> {
        D3d12FenceSubmitInfoKHR {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSemaphoreGetWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SemaphoreGetWin32HandleInfoKhr<'s> {
    raw: vks::VkSemaphoreGetWin32HandleInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> SemaphoreGetWin32HandleInfoKhr<'s> {
    pub fn builder<'b>() -> SemaphoreGetWin32HandleInfoKhrBuilder<'b> {
        SemaphoreGetWin32HandleInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSemaphoreGetWin32HandleInfoKHR) -> SemaphoreGetWin32HandleInfoKhr<'s> {
        SemaphoreGetWin32HandleInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn semaphore<'a>(&'a self) -> vks::VkSemaphore {
        self.raw.semaphore
    }

    pub fn handle_type<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("SemaphoreGetWin32HandleInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_semaphore<'m, H>(&mut self, semaphore: H)
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSemaphoreGetWin32HandleInfoKHR {
        &self.raw
    }
}

impl<'s> From<SemaphoreGetWin32HandleInfoKhr<'s>> for vks::VkSemaphoreGetWin32HandleInfoKHR {
    fn from(f: SemaphoreGetWin32HandleInfoKhr<'s>) -> vks::VkSemaphoreGetWin32HandleInfoKHR {
        f.raw
    }
}


/// A builder for `VkSemaphoreGetWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SemaphoreGetWin32HandleInfoKhrBuilder<'b> {
    raw: vks::VkSemaphoreGetWin32HandleInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SemaphoreGetWin32HandleInfoKhrBuilder<'b> {
    pub fn new() -> SemaphoreGetWin32HandleInfoKhrBuilder<'b> {
        SemaphoreGetWin32HandleInfoKhrBuilder {
            raw: vks::VkSemaphoreGetWin32HandleInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> SemaphoreGetWin32HandleInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn semaphore<'m, H>(mut self, semaphore: H) -> SemaphoreGetWin32HandleInfoKhrBuilder<'b>
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) -> SemaphoreGetWin32HandleInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_semaphore<'a>(&'a self) -> vks::VkSemaphore {
        self.raw.semaphore
    }

    pub fn get_handle_type<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("SemaphoreGetWin32HandleInfoKhr::handle_type: error converting flags")
    }

    pub fn build(self) -> SemaphoreGetWin32HandleInfoKhr<'b> {
        SemaphoreGetWin32HandleInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImportSemaphoreFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImportSemaphoreFdInfoKhr<'s> {
    raw: vks::VkImportSemaphoreFdInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImportSemaphoreFdInfoKhr<'s> {
    pub fn builder<'b>() -> ImportSemaphoreFdInfoKhrBuilder<'b> {
        ImportSemaphoreFdInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImportSemaphoreFdInfoKHR) -> ImportSemaphoreFdInfoKhr<'s> {
        ImportSemaphoreFdInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn semaphore<'a>(&'a self) -> vks::VkSemaphore {
        self.raw.semaphore
    }

    pub fn flags<'a>(&'a self) -> SemaphoreImportFlagsKhr {
        SemaphoreImportFlagsKhr::from_bits(self.raw.flags)
            .expect("ImportSemaphoreFdInfoKhr::flags: error converting flags")
    }

    pub fn handle_type<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportSemaphoreFdInfoKhr::handle_type: error converting flags")
    }

    pub fn fd<'a>(&'a self) -> i32 {
        self.raw.fd.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_semaphore<'m, H>(&mut self, semaphore: H)
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
    }

    pub fn set_flags<'m>(&mut self, flags: SemaphoreImportFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn set_fd<'m>(&mut self, fd: i32) {
        self.raw.fd = fd.into();
    }

    pub fn as_raw(&self) -> &vks::VkImportSemaphoreFdInfoKHR {
        &self.raw
    }
}

impl<'s> From<ImportSemaphoreFdInfoKhr<'s>> for vks::VkImportSemaphoreFdInfoKHR {
    fn from(f: ImportSemaphoreFdInfoKhr<'s>) -> vks::VkImportSemaphoreFdInfoKHR {
        f.raw
    }
}


/// A builder for `VkImportSemaphoreFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImportSemaphoreFdInfoKhrBuilder<'b> {
    raw: vks::VkImportSemaphoreFdInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ImportSemaphoreFdInfoKhrBuilder<'b> {
    pub fn new() -> ImportSemaphoreFdInfoKhrBuilder<'b> {
        ImportSemaphoreFdInfoKhrBuilder {
            raw: vks::VkImportSemaphoreFdInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImportSemaphoreFdInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn semaphore<'m, H>(mut self, semaphore: H) -> ImportSemaphoreFdInfoKhrBuilder<'b>
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
        self
    }

    pub fn flags<'m>(mut self, flags: SemaphoreImportFlagsKhr) -> ImportSemaphoreFdInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) -> ImportSemaphoreFdInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self
    }

    pub fn fd<'m>(mut self, fd: i32) -> ImportSemaphoreFdInfoKhrBuilder<'b> {
        self.raw.fd = fd.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_semaphore<'a>(&'a self) -> vks::VkSemaphore {
        self.raw.semaphore
    }

    pub fn get_flags<'a>(&'a self) -> SemaphoreImportFlagsKhr {
        SemaphoreImportFlagsKhr::from_bits(self.raw.flags)
            .expect("ImportSemaphoreFdInfoKhr::flags: error converting flags")
    }

    pub fn get_handle_type<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportSemaphoreFdInfoKhr::handle_type: error converting flags")
    }

    pub fn get_fd<'a>(&'a self) -> i32 {
        self.raw.fd.into()
    }

    pub fn build(self) -> ImportSemaphoreFdInfoKhr<'b> {
        ImportSemaphoreFdInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSemaphoreGetFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SemaphoreGetFdInfoKhr<'s> {
    raw: vks::VkSemaphoreGetFdInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> SemaphoreGetFdInfoKhr<'s> {
    pub fn builder<'b>() -> SemaphoreGetFdInfoKhrBuilder<'b> {
        SemaphoreGetFdInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSemaphoreGetFdInfoKHR) -> SemaphoreGetFdInfoKhr<'s> {
        SemaphoreGetFdInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn semaphore<'a>(&'a self) -> vks::VkSemaphore {
        self.raw.semaphore
    }

    pub fn handle_type<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("SemaphoreGetFdInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_semaphore<'m, H>(&mut self, semaphore: H)
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSemaphoreGetFdInfoKHR {
        &self.raw
    }
}

impl<'s> From<SemaphoreGetFdInfoKhr<'s>> for vks::VkSemaphoreGetFdInfoKHR {
    fn from(f: SemaphoreGetFdInfoKhr<'s>) -> vks::VkSemaphoreGetFdInfoKHR {
        f.raw
    }
}


/// A builder for `VkSemaphoreGetFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SemaphoreGetFdInfoKhrBuilder<'b> {
    raw: vks::VkSemaphoreGetFdInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SemaphoreGetFdInfoKhrBuilder<'b> {
    pub fn new() -> SemaphoreGetFdInfoKhrBuilder<'b> {
        SemaphoreGetFdInfoKhrBuilder {
            raw: vks::VkSemaphoreGetFdInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> SemaphoreGetFdInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn semaphore<'m, H>(mut self, semaphore: H) -> SemaphoreGetFdInfoKhrBuilder<'b>
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) -> SemaphoreGetFdInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_semaphore<'a>(&'a self) -> vks::VkSemaphore {
        self.raw.semaphore
    }

    pub fn get_handle_type<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("SemaphoreGetFdInfoKhr::handle_type: error converting flags")
    }

    pub fn build(self) -> SemaphoreGetFdInfoKhr<'b> {
        SemaphoreGetFdInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceExternalFenceInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceExternalFenceInfoKhr<'s> {
    raw: vks::VkPhysicalDeviceExternalFenceInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceExternalFenceInfoKhr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceExternalFenceInfoKhrBuilder<'b> {
        PhysicalDeviceExternalFenceInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceExternalFenceInfoKHR) -> PhysicalDeviceExternalFenceInfoKhr<'s> {
        PhysicalDeviceExternalFenceInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_type<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("PhysicalDeviceExternalFenceInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceExternalFenceInfoKHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceExternalFenceInfoKhr<'s>> for vks::VkPhysicalDeviceExternalFenceInfoKHR {
    fn from(f: PhysicalDeviceExternalFenceInfoKhr<'s>) -> vks::VkPhysicalDeviceExternalFenceInfoKHR {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceExternalFenceInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceExternalFenceInfoKhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceExternalFenceInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PhysicalDeviceExternalFenceInfoKhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceExternalFenceInfoKhrBuilder<'b> {
        PhysicalDeviceExternalFenceInfoKhrBuilder {
            raw: vks::VkPhysicalDeviceExternalFenceInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PhysicalDeviceExternalFenceInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) -> PhysicalDeviceExternalFenceInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_handle_type<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("PhysicalDeviceExternalFenceInfoKhr::handle_type: error converting flags")
    }

    pub fn build(self) -> PhysicalDeviceExternalFenceInfoKhr<'b> {
        PhysicalDeviceExternalFenceInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExternalFencePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExternalFencePropertiesKhr<'s> {
    raw: vks::VkExternalFencePropertiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExternalFencePropertiesKhr<'s> {
    pub fn builder<'b>() -> ExternalFencePropertiesKhrBuilder<'b> {
        ExternalFencePropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExternalFencePropertiesKHR) -> ExternalFencePropertiesKhr<'s> {
        ExternalFencePropertiesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn export_from_imported_handle_types<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.exportFromImportedHandleTypes)
            .expect("ExternalFencePropertiesKhr::export_from_imported_handle_types: error converting flags")
    }

    pub fn compatible_handle_types<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.compatibleHandleTypes)
            .expect("ExternalFencePropertiesKhr::compatible_handle_types: error converting flags")
    }

    pub fn external_fence_features<'a>(&'a self) -> ExternalFenceFeatureFlagsKhr {
        ExternalFenceFeatureFlagsKhr::from_bits(self.raw.externalFenceFeatures)
            .expect("ExternalFencePropertiesKhr::external_fence_features: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_export_from_imported_handle_types<'m>(&mut self, export_from_imported_handle_types: ExternalFenceHandleTypeFlagsKhr) {
        self.raw.exportFromImportedHandleTypes = export_from_imported_handle_types.bits();
    }

    pub fn set_compatible_handle_types<'m>(&mut self, compatible_handle_types: ExternalFenceHandleTypeFlagsKhr) {
        self.raw.compatibleHandleTypes = compatible_handle_types.bits();
    }

    pub fn set_external_fence_features<'m>(&mut self, external_fence_features: ExternalFenceFeatureFlagsKhr) {
        self.raw.externalFenceFeatures = external_fence_features.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExternalFencePropertiesKHR {
        &self.raw
    }
}

impl<'s> From<ExternalFencePropertiesKhr<'s>> for vks::VkExternalFencePropertiesKHR {
    fn from(f: ExternalFencePropertiesKhr<'s>) -> vks::VkExternalFencePropertiesKHR {
        f.raw
    }
}


/// A builder for `VkExternalFencePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExternalFencePropertiesKhrBuilder<'b> {
    raw: vks::VkExternalFencePropertiesKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ExternalFencePropertiesKhrBuilder<'b> {
    pub fn new() -> ExternalFencePropertiesKhrBuilder<'b> {
        ExternalFencePropertiesKhrBuilder {
            raw: vks::VkExternalFencePropertiesKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> ExternalFencePropertiesKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn export_from_imported_handle_types<'m>(mut self, export_from_imported_handle_types: ExternalFenceHandleTypeFlagsKhr) -> ExternalFencePropertiesKhrBuilder<'b> {
        self.raw.exportFromImportedHandleTypes = export_from_imported_handle_types.bits();
        self
    }

    pub fn compatible_handle_types<'m>(mut self, compatible_handle_types: ExternalFenceHandleTypeFlagsKhr) -> ExternalFencePropertiesKhrBuilder<'b> {
        self.raw.compatibleHandleTypes = compatible_handle_types.bits();
        self
    }

    pub fn external_fence_features<'m>(mut self, external_fence_features: ExternalFenceFeatureFlagsKhr) -> ExternalFencePropertiesKhrBuilder<'b> {
        self.raw.externalFenceFeatures = external_fence_features.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_export_from_imported_handle_types<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.exportFromImportedHandleTypes)
            .expect("ExternalFencePropertiesKhr::export_from_imported_handle_types: error converting flags")
    }

    pub fn get_compatible_handle_types<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.compatibleHandleTypes)
            .expect("ExternalFencePropertiesKhr::compatible_handle_types: error converting flags")
    }

    pub fn get_external_fence_features<'a>(&'a self) -> ExternalFenceFeatureFlagsKhr {
        ExternalFenceFeatureFlagsKhr::from_bits(self.raw.externalFenceFeatures)
            .expect("ExternalFencePropertiesKhr::external_fence_features: error converting flags")
    }

    pub fn build(self) -> ExternalFencePropertiesKhr<'b> {
        ExternalFencePropertiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExportFenceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExportFenceCreateInfoKhr<'s> {
    raw: vks::VkExportFenceCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExportFenceCreateInfoKhr<'s> {
    pub fn builder<'b>() -> ExportFenceCreateInfoKhrBuilder<'b> {
        ExportFenceCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExportFenceCreateInfoKHR) -> ExportFenceCreateInfoKhr<'s> {
        ExportFenceCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_types<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExportFenceCreateInfoKhr::handle_types: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_types<'m>(&mut self, handle_types: ExternalFenceHandleTypeFlagsKhr) {
        self.raw.handleTypes = handle_types.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExportFenceCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<ExportFenceCreateInfoKhr<'s>> for vks::VkExportFenceCreateInfoKHR {
    fn from(f: ExportFenceCreateInfoKhr<'s>) -> vks::VkExportFenceCreateInfoKHR {
        f.raw
    }
}


/// A builder for `VkExportFenceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExportFenceCreateInfoKhrBuilder<'b> {
    raw: vks::VkExportFenceCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ExportFenceCreateInfoKhrBuilder<'b> {
    pub fn new() -> ExportFenceCreateInfoKhrBuilder<'b> {
        ExportFenceCreateInfoKhrBuilder {
            raw: vks::VkExportFenceCreateInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExportFenceCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn handle_types<'m>(mut self, handle_types: ExternalFenceHandleTypeFlagsKhr) -> ExportFenceCreateInfoKhrBuilder<'b> {
        self.raw.handleTypes = handle_types.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_handle_types<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExportFenceCreateInfoKhr::handle_types: error converting flags")
    }

    pub fn build(self) -> ExportFenceCreateInfoKhr<'b> {
        ExportFenceCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImportFenceWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImportFenceWin32HandleInfoKhr<'s> {
    raw: vks::VkImportFenceWin32HandleInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImportFenceWin32HandleInfoKhr<'s> {
    pub fn builder<'b>() -> ImportFenceWin32HandleInfoKhrBuilder<'b> {
        ImportFenceWin32HandleInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImportFenceWin32HandleInfoKHR) -> ImportFenceWin32HandleInfoKhr<'s> {
        ImportFenceWin32HandleInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn fence<'a>(&'a self) -> vks::VkFence {
        self.raw.fence
    }

    pub fn flags<'a>(&'a self) -> FenceImportFlagsKhr {
        FenceImportFlagsKhr::from_bits(self.raw.flags)
            .expect("ImportFenceWin32HandleInfoKhr::flags: error converting flags")
    }

    pub fn handle_type<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportFenceWin32HandleInfoKhr::handle_type: error converting flags")
    }

    pub fn handle<'a>(&'a self) -> HANDLE {
        self.raw.handle.into()
    }

    pub fn name<'a>(&'a self) -> LPCWSTR {
        self.raw.name.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_fence<'m, H>(&mut self, fence: H)
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
    }

    pub fn set_flags<'m>(&mut self, flags: FenceImportFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn set_handle<'m>(&mut self, handle: HANDLE) {
        self.raw.handle = handle.into();
    }

    pub fn set_name<'m>(&mut self, name: LPCWSTR) {
        self.raw.name = name.into();
    }

    pub fn as_raw(&self) -> &vks::VkImportFenceWin32HandleInfoKHR {
        &self.raw
    }
}

impl<'s> From<ImportFenceWin32HandleInfoKhr<'s>> for vks::VkImportFenceWin32HandleInfoKHR {
    fn from(f: ImportFenceWin32HandleInfoKhr<'s>) -> vks::VkImportFenceWin32HandleInfoKHR {
        f.raw
    }
}


/// A builder for `VkImportFenceWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImportFenceWin32HandleInfoKhrBuilder<'b> {
    raw: vks::VkImportFenceWin32HandleInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ImportFenceWin32HandleInfoKhrBuilder<'b> {
    pub fn new() -> ImportFenceWin32HandleInfoKhrBuilder<'b> {
        ImportFenceWin32HandleInfoKhrBuilder {
            raw: vks::VkImportFenceWin32HandleInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImportFenceWin32HandleInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn fence<'m, H>(mut self, fence: H) -> ImportFenceWin32HandleInfoKhrBuilder<'b>
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
        self
    }

    pub fn flags<'m>(mut self, flags: FenceImportFlagsKhr) -> ImportFenceWin32HandleInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) -> ImportFenceWin32HandleInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self
    }

    pub fn handle<'m>(mut self, handle: HANDLE) -> ImportFenceWin32HandleInfoKhrBuilder<'b> {
        self.raw.handle = handle.into();
        self
    }

    pub fn name<'m>(mut self, name: LPCWSTR) -> ImportFenceWin32HandleInfoKhrBuilder<'b> {
        self.raw.name = name.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_fence<'a>(&'a self) -> vks::VkFence {
        self.raw.fence
    }

    pub fn get_flags<'a>(&'a self) -> FenceImportFlagsKhr {
        FenceImportFlagsKhr::from_bits(self.raw.flags)
            .expect("ImportFenceWin32HandleInfoKhr::flags: error converting flags")
    }

    pub fn get_handle_type<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportFenceWin32HandleInfoKhr::handle_type: error converting flags")
    }

    pub fn get_handle<'a>(&'a self) -> HANDLE {
        self.raw.handle.into()
    }

    pub fn get_name<'a>(&'a self) -> LPCWSTR {
        self.raw.name.into()
    }

    pub fn build(self) -> ImportFenceWin32HandleInfoKhr<'b> {
        ImportFenceWin32HandleInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExportFenceWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExportFenceWin32HandleInfoKhr<'s> {
    raw: vks::VkExportFenceWin32HandleInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExportFenceWin32HandleInfoKhr<'s> {
    pub fn builder<'b>() -> ExportFenceWin32HandleInfoKhrBuilder<'b> {
        ExportFenceWin32HandleInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExportFenceWin32HandleInfoKHR) -> ExportFenceWin32HandleInfoKhr<'s> {
        ExportFenceWin32HandleInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn attributes<'a>(&'a self) -> &'a SECURITY_ATTRIBUTES {
        unsafe { &*(self.raw.pAttributes as *const _) }
    }

    pub fn dw_access<'a>(&'a self) -> DWORD {
        self.raw.dwAccess.into()
    }

    pub fn name<'a>(&'a self) -> LPCWSTR {
        self.raw.name.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_attributes<'m, 'a>(&mut self, attributes: &'a SECURITY_ATTRIBUTES) {
        self.raw.pAttributes = attributes;
    }

    pub fn set_dw_access<'m>(&mut self, dw_access: DWORD) {
        self.raw.dwAccess = dw_access.into();
    }

    pub fn set_name<'m>(&mut self, name: LPCWSTR) {
        self.raw.name = name.into();
    }

    pub fn as_raw(&self) -> &vks::VkExportFenceWin32HandleInfoKHR {
        &self.raw
    }
}

impl<'s> From<ExportFenceWin32HandleInfoKhr<'s>> for vks::VkExportFenceWin32HandleInfoKHR {
    fn from(f: ExportFenceWin32HandleInfoKhr<'s>) -> vks::VkExportFenceWin32HandleInfoKHR {
        f.raw
    }
}


/// A builder for `VkExportFenceWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExportFenceWin32HandleInfoKhrBuilder<'b> {
    raw: vks::VkExportFenceWin32HandleInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ExportFenceWin32HandleInfoKhrBuilder<'b> {
    pub fn new() -> ExportFenceWin32HandleInfoKhrBuilder<'b> {
        ExportFenceWin32HandleInfoKhrBuilder {
            raw: vks::VkExportFenceWin32HandleInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExportFenceWin32HandleInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn attributes<'m, 'a>(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> ExportFenceWin32HandleInfoKhrBuilder<'b> {
        self.raw.pAttributes = attributes;
        self
    }

    pub fn dw_access<'m>(mut self, dw_access: DWORD) -> ExportFenceWin32HandleInfoKhrBuilder<'b> {
        self.raw.dwAccess = dw_access.into();
        self
    }

    pub fn name<'m>(mut self, name: LPCWSTR) -> ExportFenceWin32HandleInfoKhrBuilder<'b> {
        self.raw.name = name.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_attributes<'a>(&'a self) -> &'a SECURITY_ATTRIBUTES {
        unsafe { &*(self.raw.pAttributes as *const _) }
    }

    pub fn get_dw_access<'a>(&'a self) -> DWORD {
        self.raw.dwAccess.into()
    }

    pub fn get_name<'a>(&'a self) -> LPCWSTR {
        self.raw.name.into()
    }

    pub fn build(self) -> ExportFenceWin32HandleInfoKhr<'b> {
        ExportFenceWin32HandleInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkFenceGetWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct FenceGetWin32HandleInfoKhr<'s> {
    raw: vks::VkFenceGetWin32HandleInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> FenceGetWin32HandleInfoKhr<'s> {
    pub fn builder<'b>() -> FenceGetWin32HandleInfoKhrBuilder<'b> {
        FenceGetWin32HandleInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkFenceGetWin32HandleInfoKHR) -> FenceGetWin32HandleInfoKhr<'s> {
        FenceGetWin32HandleInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn fence<'a>(&'a self) -> vks::VkFence {
        self.raw.fence
    }

    pub fn handle_type<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("FenceGetWin32HandleInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_fence<'m, H>(&mut self, fence: H)
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkFenceGetWin32HandleInfoKHR {
        &self.raw
    }
}

impl<'s> From<FenceGetWin32HandleInfoKhr<'s>> for vks::VkFenceGetWin32HandleInfoKHR {
    fn from(f: FenceGetWin32HandleInfoKhr<'s>) -> vks::VkFenceGetWin32HandleInfoKHR {
        f.raw
    }
}


/// A builder for `VkFenceGetWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct FenceGetWin32HandleInfoKhrBuilder<'b> {
    raw: vks::VkFenceGetWin32HandleInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> FenceGetWin32HandleInfoKhrBuilder<'b> {
    pub fn new() -> FenceGetWin32HandleInfoKhrBuilder<'b> {
        FenceGetWin32HandleInfoKhrBuilder {
            raw: vks::VkFenceGetWin32HandleInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> FenceGetWin32HandleInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn fence<'m, H>(mut self, fence: H) -> FenceGetWin32HandleInfoKhrBuilder<'b>
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) -> FenceGetWin32HandleInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_fence<'a>(&'a self) -> vks::VkFence {
        self.raw.fence
    }

    pub fn get_handle_type<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("FenceGetWin32HandleInfoKhr::handle_type: error converting flags")
    }

    pub fn build(self) -> FenceGetWin32HandleInfoKhr<'b> {
        FenceGetWin32HandleInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImportFenceFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImportFenceFdInfoKhr<'s> {
    raw: vks::VkImportFenceFdInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImportFenceFdInfoKhr<'s> {
    pub fn builder<'b>() -> ImportFenceFdInfoKhrBuilder<'b> {
        ImportFenceFdInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImportFenceFdInfoKHR) -> ImportFenceFdInfoKhr<'s> {
        ImportFenceFdInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn fence<'a>(&'a self) -> vks::VkFence {
        self.raw.fence
    }

    pub fn flags<'a>(&'a self) -> FenceImportFlagsKhr {
        FenceImportFlagsKhr::from_bits(self.raw.flags)
            .expect("ImportFenceFdInfoKhr::flags: error converting flags")
    }

    pub fn handle_type<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportFenceFdInfoKhr::handle_type: error converting flags")
    }

    pub fn fd<'a>(&'a self) -> i32 {
        self.raw.fd.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_fence<'m, H>(&mut self, fence: H)
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
    }

    pub fn set_flags<'m>(&mut self, flags: FenceImportFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn set_fd<'m>(&mut self, fd: i32) {
        self.raw.fd = fd.into();
    }

    pub fn as_raw(&self) -> &vks::VkImportFenceFdInfoKHR {
        &self.raw
    }
}

impl<'s> From<ImportFenceFdInfoKhr<'s>> for vks::VkImportFenceFdInfoKHR {
    fn from(f: ImportFenceFdInfoKhr<'s>) -> vks::VkImportFenceFdInfoKHR {
        f.raw
    }
}


/// A builder for `VkImportFenceFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImportFenceFdInfoKhrBuilder<'b> {
    raw: vks::VkImportFenceFdInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ImportFenceFdInfoKhrBuilder<'b> {
    pub fn new() -> ImportFenceFdInfoKhrBuilder<'b> {
        ImportFenceFdInfoKhrBuilder {
            raw: vks::VkImportFenceFdInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImportFenceFdInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn fence<'m, H>(mut self, fence: H) -> ImportFenceFdInfoKhrBuilder<'b>
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
        self
    }

    pub fn flags<'m>(mut self, flags: FenceImportFlagsKhr) -> ImportFenceFdInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) -> ImportFenceFdInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self
    }

    pub fn fd<'m>(mut self, fd: i32) -> ImportFenceFdInfoKhrBuilder<'b> {
        self.raw.fd = fd.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_fence<'a>(&'a self) -> vks::VkFence {
        self.raw.fence
    }

    pub fn get_flags<'a>(&'a self) -> FenceImportFlagsKhr {
        FenceImportFlagsKhr::from_bits(self.raw.flags)
            .expect("ImportFenceFdInfoKhr::flags: error converting flags")
    }

    pub fn get_handle_type<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportFenceFdInfoKhr::handle_type: error converting flags")
    }

    pub fn get_fd<'a>(&'a self) -> i32 {
        self.raw.fd.into()
    }

    pub fn build(self) -> ImportFenceFdInfoKhr<'b> {
        ImportFenceFdInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkFenceGetFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct FenceGetFdInfoKhr<'s> {
    raw: vks::VkFenceGetFdInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> FenceGetFdInfoKhr<'s> {
    pub fn builder<'b>() -> FenceGetFdInfoKhrBuilder<'b> {
        FenceGetFdInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkFenceGetFdInfoKHR) -> FenceGetFdInfoKhr<'s> {
        FenceGetFdInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn fence<'a>(&'a self) -> vks::VkFence {
        self.raw.fence
    }

    pub fn handle_type<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("FenceGetFdInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_fence<'m, H>(&mut self, fence: H)
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkFenceGetFdInfoKHR {
        &self.raw
    }
}

impl<'s> From<FenceGetFdInfoKhr<'s>> for vks::VkFenceGetFdInfoKHR {
    fn from(f: FenceGetFdInfoKhr<'s>) -> vks::VkFenceGetFdInfoKHR {
        f.raw
    }
}


/// A builder for `VkFenceGetFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct FenceGetFdInfoKhrBuilder<'b> {
    raw: vks::VkFenceGetFdInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> FenceGetFdInfoKhrBuilder<'b> {
    pub fn new() -> FenceGetFdInfoKhrBuilder<'b> {
        FenceGetFdInfoKhrBuilder {
            raw: vks::VkFenceGetFdInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> FenceGetFdInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn fence<'m, H>(mut self, fence: H) -> FenceGetFdInfoKhrBuilder<'b>
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) -> FenceGetFdInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_fence<'a>(&'a self) -> vks::VkFence {
        self.raw.fence
    }

    pub fn get_handle_type<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("FenceGetFdInfoKhr::handle_type: error converting flags")
    }

    pub fn build(self) -> FenceGetFdInfoKhr<'b> {
        FenceGetFdInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceMultiviewFeaturesKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceMultiviewFeaturesKhx<'s> {
    raw: vks::VkPhysicalDeviceMultiviewFeaturesKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> PhysicalDeviceMultiviewFeaturesKhx<'s> {
    pub fn builder<'b>() -> PhysicalDeviceMultiviewFeaturesKhxBuilder<'b> {
        PhysicalDeviceMultiviewFeaturesKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceMultiviewFeaturesKHX) -> PhysicalDeviceMultiviewFeaturesKhx<'s> {
        PhysicalDeviceMultiviewFeaturesKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn multiview<'a>(&'a self) -> bool {
        self.raw.multiview != 0
    }

    pub fn multiview_geometry_shader<'a>(&'a self) -> bool {
        self.raw.multiviewGeometryShader != 0
    }

    pub fn multiview_tessellation_shader<'a>(&'a self) -> bool {
        self.raw.multiviewTessellationShader != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_multiview<'m>(&mut self, multiview: bool) {
        self.raw.multiview = multiview as u32;
    }

    pub fn set_multiview_geometry_shader<'m>(&mut self, multiview_geometry_shader: bool) {
        self.raw.multiviewGeometryShader = multiview_geometry_shader as u32;
    }

    pub fn set_multiview_tessellation_shader<'m>(&mut self, multiview_tessellation_shader: bool) {
        self.raw.multiviewTessellationShader = multiview_tessellation_shader as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceMultiviewFeaturesKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<PhysicalDeviceMultiviewFeaturesKhx<'s>> for vks::VkPhysicalDeviceMultiviewFeaturesKHX {
    fn from(f: PhysicalDeviceMultiviewFeaturesKhx<'s>) -> vks::VkPhysicalDeviceMultiviewFeaturesKHX {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceMultiviewFeaturesKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceMultiviewFeaturesKhxBuilder<'b> {
    raw: vks::VkPhysicalDeviceMultiviewFeaturesKHX,
    _p: PhantomData<&'b ()>, 
}

#[cfg(feature = "experimental")]
impl<'b> PhysicalDeviceMultiviewFeaturesKhxBuilder<'b> {
    pub fn new() -> PhysicalDeviceMultiviewFeaturesKhxBuilder<'b> {
        PhysicalDeviceMultiviewFeaturesKhxBuilder {
            raw: vks::VkPhysicalDeviceMultiviewFeaturesKHX::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceMultiviewFeaturesKhxBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn multiview<'m>(mut self, multiview: bool) -> PhysicalDeviceMultiviewFeaturesKhxBuilder<'b> {
        self.raw.multiview = multiview as u32;
        self
    }

    pub fn multiview_geometry_shader<'m>(mut self, multiview_geometry_shader: bool) -> PhysicalDeviceMultiviewFeaturesKhxBuilder<'b> {
        self.raw.multiviewGeometryShader = multiview_geometry_shader as u32;
        self
    }

    pub fn multiview_tessellation_shader<'m>(mut self, multiview_tessellation_shader: bool) -> PhysicalDeviceMultiviewFeaturesKhxBuilder<'b> {
        self.raw.multiviewTessellationShader = multiview_tessellation_shader as u32;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_multiview<'a>(&'a self) -> bool {
        self.raw.multiview != 0
    }

    pub fn get_multiview_geometry_shader<'a>(&'a self) -> bool {
        self.raw.multiviewGeometryShader != 0
    }

    pub fn get_multiview_tessellation_shader<'a>(&'a self) -> bool {
        self.raw.multiviewTessellationShader != 0
    }

    pub fn build(self) -> PhysicalDeviceMultiviewFeaturesKhx<'b> {
        PhysicalDeviceMultiviewFeaturesKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceMultiviewPropertiesKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceMultiviewPropertiesKhx<'s> {
    raw: vks::VkPhysicalDeviceMultiviewPropertiesKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> PhysicalDeviceMultiviewPropertiesKhx<'s> {
    pub fn builder<'b>() -> PhysicalDeviceMultiviewPropertiesKhxBuilder<'b> {
        PhysicalDeviceMultiviewPropertiesKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceMultiviewPropertiesKHX) -> PhysicalDeviceMultiviewPropertiesKhx<'s> {
        PhysicalDeviceMultiviewPropertiesKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn max_multiview_view_count<'a>(&'a self) -> u32 {
        self.raw.maxMultiviewViewCount.into()
    }

    pub fn max_multiview_instance_index<'a>(&'a self) -> u32 {
        self.raw.maxMultiviewInstanceIndex.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_max_multiview_view_count<'m>(&mut self, max_multiview_view_count: u32) {
        self.raw.maxMultiviewViewCount = max_multiview_view_count.into();
    }

    pub fn set_max_multiview_instance_index<'m>(&mut self, max_multiview_instance_index: u32) {
        self.raw.maxMultiviewInstanceIndex = max_multiview_instance_index.into();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceMultiviewPropertiesKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<PhysicalDeviceMultiviewPropertiesKhx<'s>> for vks::VkPhysicalDeviceMultiviewPropertiesKHX {
    fn from(f: PhysicalDeviceMultiviewPropertiesKhx<'s>) -> vks::VkPhysicalDeviceMultiviewPropertiesKHX {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceMultiviewPropertiesKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceMultiviewPropertiesKhxBuilder<'b> {
    raw: vks::VkPhysicalDeviceMultiviewPropertiesKHX,
    _p: PhantomData<&'b ()>, 
}

#[cfg(feature = "experimental")]
impl<'b> PhysicalDeviceMultiviewPropertiesKhxBuilder<'b> {
    pub fn new() -> PhysicalDeviceMultiviewPropertiesKhxBuilder<'b> {
        PhysicalDeviceMultiviewPropertiesKhxBuilder {
            raw: vks::VkPhysicalDeviceMultiviewPropertiesKHX::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceMultiviewPropertiesKhxBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn max_multiview_view_count<'m>(mut self, max_multiview_view_count: u32) -> PhysicalDeviceMultiviewPropertiesKhxBuilder<'b> {
        self.raw.maxMultiviewViewCount = max_multiview_view_count.into();
        self
    }

    pub fn max_multiview_instance_index<'m>(mut self, max_multiview_instance_index: u32) -> PhysicalDeviceMultiviewPropertiesKhxBuilder<'b> {
        self.raw.maxMultiviewInstanceIndex = max_multiview_instance_index.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_max_multiview_view_count<'a>(&'a self) -> u32 {
        self.raw.maxMultiviewViewCount.into()
    }

    pub fn get_max_multiview_instance_index<'a>(&'a self) -> u32 {
        self.raw.maxMultiviewInstanceIndex.into()
    }

    pub fn build(self) -> PhysicalDeviceMultiviewPropertiesKhx<'b> {
        PhysicalDeviceMultiviewPropertiesKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSurfaceCapabilities2EXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SurfaceCapabilities2Ext<'s> {
    raw: vks::VkSurfaceCapabilities2EXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> SurfaceCapabilities2Ext<'s> {
    pub fn builder<'b>() -> SurfaceCapabilities2ExtBuilder<'b> {
        SurfaceCapabilities2ExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSurfaceCapabilities2EXT) -> SurfaceCapabilities2Ext<'s> {
        SurfaceCapabilities2Ext { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn min_image_count<'a>(&'a self) -> u32 {
        self.raw.minImageCount.into()
    }

    pub fn max_image_count<'a>(&'a self) -> u32 {
        self.raw.maxImageCount.into()
    }

    pub fn current_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.currentExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn current_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.currentExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn min_image_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.minImageExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn min_image_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.minImageExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn max_image_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.maxImageExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn max_image_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.maxImageExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn max_image_array_layers<'a>(&'a self) -> u32 {
        self.raw.maxImageArrayLayers.into()
    }

    pub fn supported_transforms<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.supportedTransforms)
            .expect("SurfaceCapabilities2Ext::supported_transforms: error converting flags")
    }

    pub fn current_transform<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.currentTransform)
            .expect("SurfaceCapabilities2Ext::current_transform: error converting flags")
    }

    pub fn supported_composite_alpha<'a>(&'a self) -> CompositeAlphaFlagsKhr {
        CompositeAlphaFlagsKhr::from_bits(self.raw.supportedCompositeAlpha)
            .expect("SurfaceCapabilities2Ext::supported_composite_alpha: error converting flags")
    }

    pub fn supported_usage_flags<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.supportedUsageFlags)
            .expect("SurfaceCapabilities2Ext::supported_usage_flags: error converting flags")
    }

    pub fn supported_surface_counters<'a>(&'a self) -> SurfaceCounterFlagsExt {
        SurfaceCounterFlagsExt::from_bits(self.raw.supportedSurfaceCounters)
            .expect("SurfaceCapabilities2Ext::supported_surface_counters: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_min_image_count<'m>(&mut self, min_image_count: u32) {
        self.raw.minImageCount = min_image_count.into();
    }

    pub fn set_max_image_count<'m>(&mut self, max_image_count: u32) {
        self.raw.maxImageCount = max_image_count.into();
    }

    pub fn set_current_extent<'m>(&mut self, current_extent: Extent2d) {
        self.raw.currentExtent = current_extent.raw;
    }

    pub fn set_min_image_extent<'m>(&mut self, min_image_extent: Extent2d) {
        self.raw.minImageExtent = min_image_extent.raw;
    }

    pub fn set_max_image_extent<'m>(&mut self, max_image_extent: Extent2d) {
        self.raw.maxImageExtent = max_image_extent.raw;
    }

    pub fn set_max_image_array_layers<'m>(&mut self, max_image_array_layers: u32) {
        self.raw.maxImageArrayLayers = max_image_array_layers.into();
    }

    pub fn set_supported_transforms<'m>(&mut self, supported_transforms: SurfaceTransformFlagsKhr) {
        self.raw.supportedTransforms = supported_transforms.bits();
    }

    pub fn set_current_transform<'m>(&mut self, current_transform: SurfaceTransformFlagsKhr) {
        self.raw.currentTransform = current_transform.bits();
    }

    pub fn set_supported_composite_alpha<'m>(&mut self, supported_composite_alpha: CompositeAlphaFlagsKhr) {
        self.raw.supportedCompositeAlpha = supported_composite_alpha.bits();
    }

    pub fn set_supported_usage_flags<'m>(&mut self, supported_usage_flags: ImageUsageFlags) {
        self.raw.supportedUsageFlags = supported_usage_flags.bits();
    }

    pub fn set_supported_surface_counters<'m>(&mut self, supported_surface_counters: SurfaceCounterFlagsExt) {
        self.raw.supportedSurfaceCounters = supported_surface_counters.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSurfaceCapabilities2EXT {
        &self.raw
    }
}

impl<'s> From<SurfaceCapabilities2Ext<'s>> for vks::VkSurfaceCapabilities2EXT {
    fn from(f: SurfaceCapabilities2Ext<'s>) -> vks::VkSurfaceCapabilities2EXT {
        f.raw
    }
}


/// A builder for `VkSurfaceCapabilities2EXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SurfaceCapabilities2ExtBuilder<'b> {
    raw: vks::VkSurfaceCapabilities2EXT,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SurfaceCapabilities2ExtBuilder<'b> {
    pub fn new() -> SurfaceCapabilities2ExtBuilder<'b> {
        SurfaceCapabilities2ExtBuilder {
            raw: vks::VkSurfaceCapabilities2EXT::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn min_image_count<'m>(mut self, min_image_count: u32) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.minImageCount = min_image_count.into();
        self
    }

    pub fn max_image_count<'m>(mut self, max_image_count: u32) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.maxImageCount = max_image_count.into();
        self
    }

    pub fn current_extent<'m>(mut self, current_extent: Extent2d) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.currentExtent = current_extent.raw;
        self
    }

    pub fn min_image_extent<'m>(mut self, min_image_extent: Extent2d) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.minImageExtent = min_image_extent.raw;
        self
    }

    pub fn max_image_extent<'m>(mut self, max_image_extent: Extent2d) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.maxImageExtent = max_image_extent.raw;
        self
    }

    pub fn max_image_array_layers<'m>(mut self, max_image_array_layers: u32) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.maxImageArrayLayers = max_image_array_layers.into();
        self
    }

    pub fn supported_transforms<'m>(mut self, supported_transforms: SurfaceTransformFlagsKhr) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.supportedTransforms = supported_transforms.bits();
        self
    }

    pub fn current_transform<'m>(mut self, current_transform: SurfaceTransformFlagsKhr) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.currentTransform = current_transform.bits();
        self
    }

    pub fn supported_composite_alpha<'m>(mut self, supported_composite_alpha: CompositeAlphaFlagsKhr) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.supportedCompositeAlpha = supported_composite_alpha.bits();
        self
    }

    pub fn supported_usage_flags<'m>(mut self, supported_usage_flags: ImageUsageFlags) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.supportedUsageFlags = supported_usage_flags.bits();
        self
    }

    pub fn supported_surface_counters<'m>(mut self, supported_surface_counters: SurfaceCounterFlagsExt) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.supportedSurfaceCounters = supported_surface_counters.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_min_image_count<'a>(&'a self) -> u32 {
        self.raw.minImageCount.into()
    }

    pub fn get_max_image_count<'a>(&'a self) -> u32 {
        self.raw.maxImageCount.into()
    }

    pub fn get_current_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.currentExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn get_current_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.currentExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn get_min_image_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.minImageExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn get_min_image_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.minImageExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn get_max_image_extent<'a>(&'a self) -> &'a Extent2d {
        unsafe { &*(&self.raw.maxImageExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn get_max_image_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.maxImageExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn get_max_image_array_layers<'a>(&'a self) -> u32 {
        self.raw.maxImageArrayLayers.into()
    }

    pub fn get_supported_transforms<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.supportedTransforms)
            .expect("SurfaceCapabilities2Ext::supported_transforms: error converting flags")
    }

    pub fn get_current_transform<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.currentTransform)
            .expect("SurfaceCapabilities2Ext::current_transform: error converting flags")
    }

    pub fn get_supported_composite_alpha<'a>(&'a self) -> CompositeAlphaFlagsKhr {
        CompositeAlphaFlagsKhr::from_bits(self.raw.supportedCompositeAlpha)
            .expect("SurfaceCapabilities2Ext::supported_composite_alpha: error converting flags")
    }

    pub fn get_supported_usage_flags<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.supportedUsageFlags)
            .expect("SurfaceCapabilities2Ext::supported_usage_flags: error converting flags")
    }

    pub fn get_supported_surface_counters<'a>(&'a self) -> SurfaceCounterFlagsExt {
        SurfaceCounterFlagsExt::from_bits(self.raw.supportedSurfaceCounters)
            .expect("SurfaceCapabilities2Ext::supported_surface_counters: error converting flags")
    }

    pub fn build(self) -> SurfaceCapabilities2Ext<'b> {
        SurfaceCapabilities2Ext {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDisplayPowerInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplayPowerInfoExt<'s> {
    raw: vks::VkDisplayPowerInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> DisplayPowerInfoExt<'s> {
    pub fn builder<'b>() -> DisplayPowerInfoExtBuilder<'b> {
        DisplayPowerInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplayPowerInfoEXT) -> DisplayPowerInfoExt<'s> {
        DisplayPowerInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn power_state<'a>(&'a self) -> DisplayPowerStateExt {
        self.raw.powerState.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_power_state<'m>(&mut self, power_state: DisplayPowerStateExt) {
        self.raw.powerState = power_state.into();
    }

    pub fn as_raw(&self) -> &vks::VkDisplayPowerInfoEXT {
        &self.raw
    }
}

impl<'s> From<DisplayPowerInfoExt<'s>> for vks::VkDisplayPowerInfoEXT {
    fn from(f: DisplayPowerInfoExt<'s>) -> vks::VkDisplayPowerInfoEXT {
        f.raw
    }
}


/// A builder for `VkDisplayPowerInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplayPowerInfoExtBuilder<'b> {
    raw: vks::VkDisplayPowerInfoEXT,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DisplayPowerInfoExtBuilder<'b> {
    pub fn new() -> DisplayPowerInfoExtBuilder<'b> {
        DisplayPowerInfoExtBuilder {
            raw: vks::VkDisplayPowerInfoEXT::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DisplayPowerInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn power_state<'m>(mut self, power_state: DisplayPowerStateExt) -> DisplayPowerInfoExtBuilder<'b> {
        self.raw.powerState = power_state.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_power_state<'a>(&'a self) -> DisplayPowerStateExt {
        self.raw.powerState.into()
    }

    pub fn build(self) -> DisplayPowerInfoExt<'b> {
        DisplayPowerInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceEventInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceEventInfoExt<'s> {
    raw: vks::VkDeviceEventInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> DeviceEventInfoExt<'s> {
    pub fn builder<'b>() -> DeviceEventInfoExtBuilder<'b> {
        DeviceEventInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceEventInfoEXT) -> DeviceEventInfoExt<'s> {
        DeviceEventInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn device_event<'a>(&'a self) -> DeviceEventTypeExt {
        self.raw.deviceEvent.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_device_event<'m>(&mut self, device_event: DeviceEventTypeExt) {
        self.raw.deviceEvent = device_event.into();
    }

    pub fn as_raw(&self) -> &vks::VkDeviceEventInfoEXT {
        &self.raw
    }
}

impl<'s> From<DeviceEventInfoExt<'s>> for vks::VkDeviceEventInfoEXT {
    fn from(f: DeviceEventInfoExt<'s>) -> vks::VkDeviceEventInfoEXT {
        f.raw
    }
}


/// A builder for `VkDeviceEventInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DeviceEventInfoExtBuilder<'b> {
    raw: vks::VkDeviceEventInfoEXT,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DeviceEventInfoExtBuilder<'b> {
    pub fn new() -> DeviceEventInfoExtBuilder<'b> {
        DeviceEventInfoExtBuilder {
            raw: vks::VkDeviceEventInfoEXT::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceEventInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn device_event<'m>(mut self, device_event: DeviceEventTypeExt) -> DeviceEventInfoExtBuilder<'b> {
        self.raw.deviceEvent = device_event.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_device_event<'a>(&'a self) -> DeviceEventTypeExt {
        self.raw.deviceEvent.into()
    }

    pub fn build(self) -> DeviceEventInfoExt<'b> {
        DeviceEventInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDisplayEventInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplayEventInfoExt<'s> {
    raw: vks::VkDisplayEventInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> DisplayEventInfoExt<'s> {
    pub fn builder<'b>() -> DisplayEventInfoExtBuilder<'b> {
        DisplayEventInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplayEventInfoEXT) -> DisplayEventInfoExt<'s> {
        DisplayEventInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn display_event<'a>(&'a self) -> DisplayEventTypeExt {
        self.raw.displayEvent.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_display_event<'m>(&mut self, display_event: DisplayEventTypeExt) {
        self.raw.displayEvent = display_event.into();
    }

    pub fn as_raw(&self) -> &vks::VkDisplayEventInfoEXT {
        &self.raw
    }
}

impl<'s> From<DisplayEventInfoExt<'s>> for vks::VkDisplayEventInfoEXT {
    fn from(f: DisplayEventInfoExt<'s>) -> vks::VkDisplayEventInfoEXT {
        f.raw
    }
}


/// A builder for `VkDisplayEventInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplayEventInfoExtBuilder<'b> {
    raw: vks::VkDisplayEventInfoEXT,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DisplayEventInfoExtBuilder<'b> {
    pub fn new() -> DisplayEventInfoExtBuilder<'b> {
        DisplayEventInfoExtBuilder {
            raw: vks::VkDisplayEventInfoEXT::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DisplayEventInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn display_event<'m>(mut self, display_event: DisplayEventTypeExt) -> DisplayEventInfoExtBuilder<'b> {
        self.raw.displayEvent = display_event.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_display_event<'a>(&'a self) -> DisplayEventTypeExt {
        self.raw.displayEvent.into()
    }

    pub fn build(self) -> DisplayEventInfoExt<'b> {
        DisplayEventInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSwapchainCounterCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SwapchainCounterCreateInfoExt<'s> {
    raw: vks::VkSwapchainCounterCreateInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> SwapchainCounterCreateInfoExt<'s> {
    pub fn builder<'b>() -> SwapchainCounterCreateInfoExtBuilder<'b> {
        SwapchainCounterCreateInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSwapchainCounterCreateInfoEXT) -> SwapchainCounterCreateInfoExt<'s> {
        SwapchainCounterCreateInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn surface_counters<'a>(&'a self) -> SurfaceCounterFlagsExt {
        SurfaceCounterFlagsExt::from_bits(self.raw.surfaceCounters)
            .expect("SwapchainCounterCreateInfoExt::surface_counters: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_surface_counters<'m>(&mut self, surface_counters: SurfaceCounterFlagsExt) {
        self.raw.surfaceCounters = surface_counters.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSwapchainCounterCreateInfoEXT {
        &self.raw
    }
}

impl<'s> From<SwapchainCounterCreateInfoExt<'s>> for vks::VkSwapchainCounterCreateInfoEXT {
    fn from(f: SwapchainCounterCreateInfoExt<'s>) -> vks::VkSwapchainCounterCreateInfoEXT {
        f.raw
    }
}


/// A builder for `VkSwapchainCounterCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SwapchainCounterCreateInfoExtBuilder<'b> {
    raw: vks::VkSwapchainCounterCreateInfoEXT,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SwapchainCounterCreateInfoExtBuilder<'b> {
    pub fn new() -> SwapchainCounterCreateInfoExtBuilder<'b> {
        SwapchainCounterCreateInfoExtBuilder {
            raw: vks::VkSwapchainCounterCreateInfoEXT::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> SwapchainCounterCreateInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn surface_counters<'m>(mut self, surface_counters: SurfaceCounterFlagsExt) -> SwapchainCounterCreateInfoExtBuilder<'b> {
        self.raw.surfaceCounters = surface_counters.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_surface_counters<'a>(&'a self) -> SurfaceCounterFlagsExt {
        SurfaceCounterFlagsExt::from_bits(self.raw.surfaceCounters)
            .expect("SwapchainCounterCreateInfoExt::surface_counters: error converting flags")
    }

    pub fn build(self) -> SwapchainCounterCreateInfoExt<'b> {
        SwapchainCounterCreateInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMemoryAllocateFlagsInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryAllocateFlagsInfoKhx<'s> {
    raw: vks::VkMemoryAllocateFlagsInfoKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> MemoryAllocateFlagsInfoKhx<'s> {
    pub fn builder<'b>() -> MemoryAllocateFlagsInfoKhxBuilder<'b> {
        MemoryAllocateFlagsInfoKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryAllocateFlagsInfoKHX) -> MemoryAllocateFlagsInfoKhx<'s> {
        MemoryAllocateFlagsInfoKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> MemoryAllocateFlagsKhx {
        MemoryAllocateFlagsKhx::from_bits(self.raw.flags)
            .expect("MemoryAllocateFlagsInfoKhx::flags: error converting flags")
    }

    pub fn device_mask<'a>(&'a self) -> u32 {
        self.raw.deviceMask.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: MemoryAllocateFlagsKhx) {
        self.raw.flags = flags.bits();
    }

    pub fn set_device_mask<'m>(&mut self, device_mask: u32) {
        self.raw.deviceMask = device_mask.into();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryAllocateFlagsInfoKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<MemoryAllocateFlagsInfoKhx<'s>> for vks::VkMemoryAllocateFlagsInfoKHX {
    fn from(f: MemoryAllocateFlagsInfoKhx<'s>) -> vks::VkMemoryAllocateFlagsInfoKHX {
        f.raw
    }
}


/// A builder for `VkMemoryAllocateFlagsInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct MemoryAllocateFlagsInfoKhxBuilder<'b> {
    raw: vks::VkMemoryAllocateFlagsInfoKHX,
    _p: PhantomData<&'b ()>, 
}

#[cfg(feature = "experimental")]
impl<'b> MemoryAllocateFlagsInfoKhxBuilder<'b> {
    pub fn new() -> MemoryAllocateFlagsInfoKhxBuilder<'b> {
        MemoryAllocateFlagsInfoKhxBuilder {
            raw: vks::VkMemoryAllocateFlagsInfoKHX::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> MemoryAllocateFlagsInfoKhxBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: MemoryAllocateFlagsKhx) -> MemoryAllocateFlagsInfoKhxBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn device_mask<'m>(mut self, device_mask: u32) -> MemoryAllocateFlagsInfoKhxBuilder<'b> {
        self.raw.deviceMask = device_mask.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> MemoryAllocateFlagsKhx {
        MemoryAllocateFlagsKhx::from_bits(self.raw.flags)
            .expect("MemoryAllocateFlagsInfoKhx::flags: error converting flags")
    }

    pub fn get_device_mask<'a>(&'a self) -> u32 {
        self.raw.deviceMask.into()
    }

    pub fn build(self) -> MemoryAllocateFlagsInfoKhx<'b> {
        MemoryAllocateFlagsInfoKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceGroupSubmitInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceGroupSubmitInfoKhx<'s> {
    raw: vks::VkDeviceGroupSubmitInfoKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> DeviceGroupSubmitInfoKhx<'s> {
    pub fn builder<'b>() -> DeviceGroupSubmitInfoKhxBuilder<'b> {
        DeviceGroupSubmitInfoKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceGroupSubmitInfoKHX) -> DeviceGroupSubmitInfoKhx<'s> {
        DeviceGroupSubmitInfoKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn wait_semaphore_device_indices<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pWaitSemaphoreDeviceIndices as *const _, self.raw.waitSemaphoreCount as usize) }
    }

    pub fn command_buffer_device_masks<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pCommandBufferDeviceMasks as *const _, self.raw.commandBufferCount as usize) }
    }

    pub fn signal_semaphore_device_indices<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pSignalSemaphoreDeviceIndices as *const _, self.raw.signalSemaphoreCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_wait_semaphore_device_indices<'m, 'a>(&mut self, wait_semaphore_device_indices: &'a [u32])
            where 'a: 's {
        assert!(self.raw.waitSemaphoreCount == 0 || self.raw.waitSemaphoreCount == wait_semaphore_device_indices.len() as _, 
            "count inconsistency found when specifying `DeviceGroupSubmitInfoKhx::wait_semaphore_device_indices`.");
        self.raw.waitSemaphoreCount = wait_semaphore_device_indices.len() as _;
        self.raw.pWaitSemaphoreDeviceIndices = wait_semaphore_device_indices.as_ptr() as *const u32 as *const _;
    }

    pub fn set_command_buffer_device_masks<'m, 'a>(&mut self, command_buffer_device_masks: &'a [u32])
            where 'a: 's {
        assert!(self.raw.commandBufferCount == 0 || self.raw.commandBufferCount == command_buffer_device_masks.len() as _, 
            "count inconsistency found when specifying `DeviceGroupSubmitInfoKhx::command_buffer_device_masks`.");
        self.raw.commandBufferCount = command_buffer_device_masks.len() as _;
        self.raw.pCommandBufferDeviceMasks = command_buffer_device_masks.as_ptr() as *const u32 as *const _;
    }

    pub fn set_signal_semaphore_device_indices<'m, 'a>(&mut self, signal_semaphore_device_indices: &'a [u32])
            where 'a: 's {
        assert!(self.raw.signalSemaphoreCount == 0 || self.raw.signalSemaphoreCount == signal_semaphore_device_indices.len() as _, 
            "count inconsistency found when specifying `DeviceGroupSubmitInfoKhx::signal_semaphore_device_indices`.");
        self.raw.signalSemaphoreCount = signal_semaphore_device_indices.len() as _;
        self.raw.pSignalSemaphoreDeviceIndices = signal_semaphore_device_indices.as_ptr() as *const u32 as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkDeviceGroupSubmitInfoKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<DeviceGroupSubmitInfoKhx<'s>> for vks::VkDeviceGroupSubmitInfoKHX {
    fn from(f: DeviceGroupSubmitInfoKhx<'s>) -> vks::VkDeviceGroupSubmitInfoKHX {
        f.raw
    }
}


/// A builder for `VkDeviceGroupSubmitInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct DeviceGroupSubmitInfoKhxBuilder<'b> {
    raw: vks::VkDeviceGroupSubmitInfoKHX,
    _p: PhantomData<&'b ()>, 
}

#[cfg(feature = "experimental")]
impl<'b> DeviceGroupSubmitInfoKhxBuilder<'b> {
    pub fn new() -> DeviceGroupSubmitInfoKhxBuilder<'b> {
        DeviceGroupSubmitInfoKhxBuilder {
            raw: vks::VkDeviceGroupSubmitInfoKHX::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceGroupSubmitInfoKhxBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn wait_semaphore_device_indices<'m, 'a>(mut self, wait_semaphore_device_indices: &'a [u32]) -> DeviceGroupSubmitInfoKhxBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.waitSemaphoreCount == 0 || self.raw.waitSemaphoreCount == wait_semaphore_device_indices.len() as _, 
            "count inconsistency found when specifying `DeviceGroupSubmitInfoKhx::wait_semaphore_device_indices`.");
        self.raw.waitSemaphoreCount = wait_semaphore_device_indices.len() as _;
        self.raw.pWaitSemaphoreDeviceIndices = wait_semaphore_device_indices.as_ptr() as *const u32 as *const _;
        self
    }

    pub fn command_buffer_device_masks<'m, 'a>(mut self, command_buffer_device_masks: &'a [u32]) -> DeviceGroupSubmitInfoKhxBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.commandBufferCount == 0 || self.raw.commandBufferCount == command_buffer_device_masks.len() as _, 
            "count inconsistency found when specifying `DeviceGroupSubmitInfoKhx::command_buffer_device_masks`.");
        self.raw.commandBufferCount = command_buffer_device_masks.len() as _;
        self.raw.pCommandBufferDeviceMasks = command_buffer_device_masks.as_ptr() as *const u32 as *const _;
        self
    }

    pub fn signal_semaphore_device_indices<'m, 'a>(mut self, signal_semaphore_device_indices: &'a [u32]) -> DeviceGroupSubmitInfoKhxBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.signalSemaphoreCount == 0 || self.raw.signalSemaphoreCount == signal_semaphore_device_indices.len() as _, 
            "count inconsistency found when specifying `DeviceGroupSubmitInfoKhx::signal_semaphore_device_indices`.");
        self.raw.signalSemaphoreCount = signal_semaphore_device_indices.len() as _;
        self.raw.pSignalSemaphoreDeviceIndices = signal_semaphore_device_indices.as_ptr() as *const u32 as *const _;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_wait_semaphore_device_indices<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pWaitSemaphoreDeviceIndices as *const _, self.raw.waitSemaphoreCount as usize) }
    }

    pub fn get_command_buffer_device_masks<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pCommandBufferDeviceMasks as *const _, self.raw.commandBufferCount as usize) }
    }

    pub fn get_signal_semaphore_device_indices<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pSignalSemaphoreDeviceIndices as *const _, self.raw.signalSemaphoreCount as usize) }
    }

    pub fn build(self) -> DeviceGroupSubmitInfoKhx<'b> {
        DeviceGroupSubmitInfoKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceGroupBindSparseInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceGroupBindSparseInfoKhx<'s> {
    raw: vks::VkDeviceGroupBindSparseInfoKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> DeviceGroupBindSparseInfoKhx<'s> {
    pub fn builder<'b>() -> DeviceGroupBindSparseInfoKhxBuilder<'b> {
        DeviceGroupBindSparseInfoKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceGroupBindSparseInfoKHX) -> DeviceGroupBindSparseInfoKhx<'s> {
        DeviceGroupBindSparseInfoKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn resource_device_index<'a>(&'a self) -> u32 {
        self.raw.resourceDeviceIndex.into()
    }

    pub fn memory_device_index<'a>(&'a self) -> u32 {
        self.raw.memoryDeviceIndex.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_resource_device_index<'m>(&mut self, resource_device_index: u32) {
        self.raw.resourceDeviceIndex = resource_device_index.into();
    }

    pub fn set_memory_device_index<'m>(&mut self, memory_device_index: u32) {
        self.raw.memoryDeviceIndex = memory_device_index.into();
    }

    pub fn as_raw(&self) -> &vks::VkDeviceGroupBindSparseInfoKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<DeviceGroupBindSparseInfoKhx<'s>> for vks::VkDeviceGroupBindSparseInfoKHX {
    fn from(f: DeviceGroupBindSparseInfoKhx<'s>) -> vks::VkDeviceGroupBindSparseInfoKHX {
        f.raw
    }
}


/// A builder for `VkDeviceGroupBindSparseInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct DeviceGroupBindSparseInfoKhxBuilder<'b> {
    raw: vks::VkDeviceGroupBindSparseInfoKHX,
    _p: PhantomData<&'b ()>, 
}

#[cfg(feature = "experimental")]
impl<'b> DeviceGroupBindSparseInfoKhxBuilder<'b> {
    pub fn new() -> DeviceGroupBindSparseInfoKhxBuilder<'b> {
        DeviceGroupBindSparseInfoKhxBuilder {
            raw: vks::VkDeviceGroupBindSparseInfoKHX::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceGroupBindSparseInfoKhxBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn resource_device_index<'m>(mut self, resource_device_index: u32) -> DeviceGroupBindSparseInfoKhxBuilder<'b> {
        self.raw.resourceDeviceIndex = resource_device_index.into();
        self
    }

    pub fn memory_device_index<'m>(mut self, memory_device_index: u32) -> DeviceGroupBindSparseInfoKhxBuilder<'b> {
        self.raw.memoryDeviceIndex = memory_device_index.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_resource_device_index<'a>(&'a self) -> u32 {
        self.raw.resourceDeviceIndex.into()
    }

    pub fn get_memory_device_index<'a>(&'a self) -> u32 {
        self.raw.memoryDeviceIndex.into()
    }

    pub fn build(self) -> DeviceGroupBindSparseInfoKhx<'b> {
        DeviceGroupBindSparseInfoKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceGroupPresentCapabilitiesKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceGroupPresentCapabilitiesKhx<'s> {
    raw: vks::VkDeviceGroupPresentCapabilitiesKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> DeviceGroupPresentCapabilitiesKhx<'s> {
    pub fn builder<'b>() -> DeviceGroupPresentCapabilitiesKhxBuilder<'b> {
        DeviceGroupPresentCapabilitiesKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceGroupPresentCapabilitiesKHX) -> DeviceGroupPresentCapabilitiesKhx<'s> {
        DeviceGroupPresentCapabilitiesKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn present_mask<'a>(&'a self) -> &[u32] {
        unsafe { slice::from_raw_parts(&self.raw.presentMask as *const _, vks::VK_MAX_DEVICE_GROUP_SIZE_KHX as usize) }
    }

    pub fn modes<'a>(&'a self) -> DeviceGroupPresentModeFlagsKhx {
        DeviceGroupPresentModeFlagsKhx::from_bits(self.raw.modes)
            .expect("DeviceGroupPresentCapabilitiesKhx::modes: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_present_mask<'m>(&mut self, present_mask: [u32; vks::VK_MAX_DEVICE_GROUP_SIZE_KHX]) {
        self.raw.presentMask = present_mask;
    }

    pub fn set_modes<'m>(&mut self, modes: DeviceGroupPresentModeFlagsKhx) {
        self.raw.modes = modes.bits();
    }

    pub fn as_raw(&self) -> &vks::VkDeviceGroupPresentCapabilitiesKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<DeviceGroupPresentCapabilitiesKhx<'s>> for vks::VkDeviceGroupPresentCapabilitiesKHX {
    fn from(f: DeviceGroupPresentCapabilitiesKhx<'s>) -> vks::VkDeviceGroupPresentCapabilitiesKHX {
        f.raw
    }
}


/// A builder for `VkDeviceGroupPresentCapabilitiesKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct DeviceGroupPresentCapabilitiesKhxBuilder<'b> {
    raw: vks::VkDeviceGroupPresentCapabilitiesKHX,
    _p: PhantomData<&'b ()>, 
}

#[cfg(feature = "experimental")]
impl<'b> DeviceGroupPresentCapabilitiesKhxBuilder<'b> {
    pub fn new() -> DeviceGroupPresentCapabilitiesKhxBuilder<'b> {
        DeviceGroupPresentCapabilitiesKhxBuilder {
            raw: vks::VkDeviceGroupPresentCapabilitiesKHX::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceGroupPresentCapabilitiesKhxBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn present_mask<'m>(mut self, present_mask: [u32; vks::VK_MAX_DEVICE_GROUP_SIZE_KHX]) -> DeviceGroupPresentCapabilitiesKhxBuilder<'b> {
        self.raw.presentMask = present_mask;
        self
    }

    pub fn modes<'m>(mut self, modes: DeviceGroupPresentModeFlagsKhx) -> DeviceGroupPresentCapabilitiesKhxBuilder<'b> {
        self.raw.modes = modes.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_present_mask<'a>(&'a self) -> &[u32] {
        unsafe { slice::from_raw_parts(&self.raw.presentMask as *const _, vks::VK_MAX_DEVICE_GROUP_SIZE_KHX as usize) }
    }

    pub fn get_modes<'a>(&'a self) -> DeviceGroupPresentModeFlagsKhx {
        DeviceGroupPresentModeFlagsKhx::from_bits(self.raw.modes)
            .expect("DeviceGroupPresentCapabilitiesKhx::modes: error converting flags")
    }

    pub fn build(self) -> DeviceGroupPresentCapabilitiesKhx<'b> {
        DeviceGroupPresentCapabilitiesKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImageSwapchainCreateInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageSwapchainCreateInfoKhx<'s> {
    raw: vks::VkImageSwapchainCreateInfoKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> ImageSwapchainCreateInfoKhx<'s> {
    pub fn builder<'b>() -> ImageSwapchainCreateInfoKhxBuilder<'b> {
        ImageSwapchainCreateInfoKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageSwapchainCreateInfoKHX) -> ImageSwapchainCreateInfoKhx<'s> {
        ImageSwapchainCreateInfoKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn swapchain<'a>(&'a self) -> vks::VkSwapchainKHR {
        self.raw.swapchain
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_swapchain<'m, H>(&mut self, swapchain: H)
            where H: Handle<Target=SwapchainKhrHandle> {
        self.raw.swapchain = swapchain.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkImageSwapchainCreateInfoKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<ImageSwapchainCreateInfoKhx<'s>> for vks::VkImageSwapchainCreateInfoKHX {
    fn from(f: ImageSwapchainCreateInfoKhx<'s>) -> vks::VkImageSwapchainCreateInfoKHX {
        f.raw
    }
}


/// A builder for `VkImageSwapchainCreateInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct ImageSwapchainCreateInfoKhxBuilder<'b> {
    raw: vks::VkImageSwapchainCreateInfoKHX,
    _p: PhantomData<&'b ()>, 
}

#[cfg(feature = "experimental")]
impl<'b> ImageSwapchainCreateInfoKhxBuilder<'b> {
    pub fn new() -> ImageSwapchainCreateInfoKhxBuilder<'b> {
        ImageSwapchainCreateInfoKhxBuilder {
            raw: vks::VkImageSwapchainCreateInfoKHX::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImageSwapchainCreateInfoKhxBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn swapchain<'m, H>(mut self, swapchain: H) -> ImageSwapchainCreateInfoKhxBuilder<'b>
            where H: Handle<Target=SwapchainKhrHandle> {
        self.raw.swapchain = swapchain.handle().0;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_swapchain<'a>(&'a self) -> vks::VkSwapchainKHR {
        self.raw.swapchain
    }

    pub fn build(self) -> ImageSwapchainCreateInfoKhx<'b> {
        ImageSwapchainCreateInfoKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkBindImageMemorySwapchainInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct BindImageMemorySwapchainInfoKhx<'s> {
    raw: vks::VkBindImageMemorySwapchainInfoKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> BindImageMemorySwapchainInfoKhx<'s> {
    pub fn builder<'b>() -> BindImageMemorySwapchainInfoKhxBuilder<'b> {
        BindImageMemorySwapchainInfoKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkBindImageMemorySwapchainInfoKHX) -> BindImageMemorySwapchainInfoKhx<'s> {
        BindImageMemorySwapchainInfoKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn swapchain<'a>(&'a self) -> vks::VkSwapchainKHR {
        self.raw.swapchain
    }

    pub fn image_index<'a>(&'a self) -> u32 {
        self.raw.imageIndex.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_swapchain<'m, H>(&mut self, swapchain: H)
            where H: Handle<Target=SwapchainKhrHandle> {
        self.raw.swapchain = swapchain.handle().0;
    }

    pub fn set_image_index<'m>(&mut self, image_index: u32) {
        self.raw.imageIndex = image_index.into();
    }

    pub fn as_raw(&self) -> &vks::VkBindImageMemorySwapchainInfoKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<BindImageMemorySwapchainInfoKhx<'s>> for vks::VkBindImageMemorySwapchainInfoKHX {
    fn from(f: BindImageMemorySwapchainInfoKhx<'s>) -> vks::VkBindImageMemorySwapchainInfoKHX {
        f.raw
    }
}


/// A builder for `VkBindImageMemorySwapchainInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct BindImageMemorySwapchainInfoKhxBuilder<'b> {
    raw: vks::VkBindImageMemorySwapchainInfoKHX,
    _p: PhantomData<&'b ()>, 
}

#[cfg(feature = "experimental")]
impl<'b> BindImageMemorySwapchainInfoKhxBuilder<'b> {
    pub fn new() -> BindImageMemorySwapchainInfoKhxBuilder<'b> {
        BindImageMemorySwapchainInfoKhxBuilder {
            raw: vks::VkBindImageMemorySwapchainInfoKHX::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> BindImageMemorySwapchainInfoKhxBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn swapchain<'m, H>(mut self, swapchain: H) -> BindImageMemorySwapchainInfoKhxBuilder<'b>
            where H: Handle<Target=SwapchainKhrHandle> {
        self.raw.swapchain = swapchain.handle().0;
        self
    }

    pub fn image_index<'m>(mut self, image_index: u32) -> BindImageMemorySwapchainInfoKhxBuilder<'b> {
        self.raw.imageIndex = image_index.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_swapchain<'a>(&'a self) -> vks::VkSwapchainKHR {
        self.raw.swapchain
    }

    pub fn get_image_index<'a>(&'a self) -> u32 {
        self.raw.imageIndex.into()
    }

    pub fn build(self) -> BindImageMemorySwapchainInfoKhx<'b> {
        BindImageMemorySwapchainInfoKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkAcquireNextImageInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct AcquireNextImageInfoKhx<'s> {
    raw: vks::VkAcquireNextImageInfoKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> AcquireNextImageInfoKhx<'s> {
    pub fn builder<'b>() -> AcquireNextImageInfoKhxBuilder<'b> {
        AcquireNextImageInfoKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkAcquireNextImageInfoKHX) -> AcquireNextImageInfoKhx<'s> {
        AcquireNextImageInfoKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn swapchain<'a>(&'a self) -> vks::VkSwapchainKHR {
        self.raw.swapchain
    }

    pub fn timeout<'a>(&'a self) -> u64 {
        self.raw.timeout.into()
    }

    pub fn semaphore<'a>(&'a self) -> vks::VkSemaphore {
        self.raw.semaphore
    }

    pub fn fence<'a>(&'a self) -> vks::VkFence {
        self.raw.fence
    }

    pub fn device_mask<'a>(&'a self) -> u32 {
        self.raw.deviceMask.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_swapchain<'m, H>(&mut self, swapchain: H)
            where H: Handle<Target=SwapchainKhrHandle> {
        self.raw.swapchain = swapchain.handle().0;
    }

    pub fn set_timeout<'m>(&mut self, timeout: u64) {
        self.raw.timeout = timeout.into();
    }

    pub fn set_semaphore<'m, H>(&mut self, semaphore: H)
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
    }

    pub fn set_fence<'m, H>(&mut self, fence: H)
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
    }

    pub fn set_device_mask<'m>(&mut self, device_mask: u32) {
        self.raw.deviceMask = device_mask.into();
    }

    pub fn as_raw(&self) -> &vks::VkAcquireNextImageInfoKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<AcquireNextImageInfoKhx<'s>> for vks::VkAcquireNextImageInfoKHX {
    fn from(f: AcquireNextImageInfoKhx<'s>) -> vks::VkAcquireNextImageInfoKHX {
        f.raw
    }
}


/// A builder for `VkAcquireNextImageInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct AcquireNextImageInfoKhxBuilder<'b> {
    raw: vks::VkAcquireNextImageInfoKHX,
    _p: PhantomData<&'b ()>, 
}

#[cfg(feature = "experimental")]
impl<'b> AcquireNextImageInfoKhxBuilder<'b> {
    pub fn new() -> AcquireNextImageInfoKhxBuilder<'b> {
        AcquireNextImageInfoKhxBuilder {
            raw: vks::VkAcquireNextImageInfoKHX::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> AcquireNextImageInfoKhxBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn swapchain<'m, H>(mut self, swapchain: H) -> AcquireNextImageInfoKhxBuilder<'b>
            where H: Handle<Target=SwapchainKhrHandle> {
        self.raw.swapchain = swapchain.handle().0;
        self
    }

    pub fn timeout<'m>(mut self, timeout: u64) -> AcquireNextImageInfoKhxBuilder<'b> {
        self.raw.timeout = timeout.into();
        self
    }

    pub fn semaphore<'m, H>(mut self, semaphore: H) -> AcquireNextImageInfoKhxBuilder<'b>
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
        self
    }

    pub fn fence<'m, H>(mut self, fence: H) -> AcquireNextImageInfoKhxBuilder<'b>
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
        self
    }

    pub fn device_mask<'m>(mut self, device_mask: u32) -> AcquireNextImageInfoKhxBuilder<'b> {
        self.raw.deviceMask = device_mask.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_swapchain<'a>(&'a self) -> vks::VkSwapchainKHR {
        self.raw.swapchain
    }

    pub fn get_timeout<'a>(&'a self) -> u64 {
        self.raw.timeout.into()
    }

    pub fn get_semaphore<'a>(&'a self) -> vks::VkSemaphore {
        self.raw.semaphore
    }

    pub fn get_fence<'a>(&'a self) -> vks::VkFence {
        self.raw.fence
    }

    pub fn get_device_mask<'a>(&'a self) -> u32 {
        self.raw.deviceMask.into()
    }

    pub fn build(self) -> AcquireNextImageInfoKhx<'b> {
        AcquireNextImageInfoKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceGroupDeviceCreateInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceGroupDeviceCreateInfoKhx<'s> {
    raw: vks::VkDeviceGroupDeviceCreateInfoKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> DeviceGroupDeviceCreateInfoKhx<'s> {
    pub fn builder<'b>() -> DeviceGroupDeviceCreateInfoKhxBuilder<'b> {
        DeviceGroupDeviceCreateInfoKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceGroupDeviceCreateInfoKHX) -> DeviceGroupDeviceCreateInfoKhx<'s> {
        DeviceGroupDeviceCreateInfoKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn physical_devices<'a>(&'a self) -> &'a [vks::VkPhysicalDevice] {
        unsafe { slice::from_raw_parts(self.raw.pPhysicalDevices as *const _, self.raw.physicalDeviceCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_physical_devices<'m, 'a>(&mut self, physical_devices: &'a [PhysicalDeviceHandle])
            where 'a: 's {
        assert!(self.raw.physicalDeviceCount == 0 || self.raw.physicalDeviceCount == physical_devices.len() as _, 
            "count inconsistency found when specifying `DeviceGroupDeviceCreateInfoKhx::physical_devices`.");
        self.raw.physicalDeviceCount = physical_devices.len() as _;
        self.raw.pPhysicalDevices = physical_devices.as_ptr() as *const vks::VkPhysicalDevice;
    }

    pub fn as_raw(&self) -> &vks::VkDeviceGroupDeviceCreateInfoKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<DeviceGroupDeviceCreateInfoKhx<'s>> for vks::VkDeviceGroupDeviceCreateInfoKHX {
    fn from(f: DeviceGroupDeviceCreateInfoKhx<'s>) -> vks::VkDeviceGroupDeviceCreateInfoKHX {
        f.raw
    }
}


/// A builder for `VkDeviceGroupDeviceCreateInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct DeviceGroupDeviceCreateInfoKhxBuilder<'b> {
    raw: vks::VkDeviceGroupDeviceCreateInfoKHX,
    _p: PhantomData<&'b ()>, 
}

#[cfg(feature = "experimental")]
impl<'b> DeviceGroupDeviceCreateInfoKhxBuilder<'b> {
    pub fn new() -> DeviceGroupDeviceCreateInfoKhxBuilder<'b> {
        DeviceGroupDeviceCreateInfoKhxBuilder {
            raw: vks::VkDeviceGroupDeviceCreateInfoKHX::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceGroupDeviceCreateInfoKhxBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn physical_devices<'m, 'a>(mut self, physical_devices: &'a [PhysicalDeviceHandle]) -> DeviceGroupDeviceCreateInfoKhxBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.physicalDeviceCount == 0 || self.raw.physicalDeviceCount == physical_devices.len() as _, 
            "count inconsistency found when specifying `DeviceGroupDeviceCreateInfoKhx::physical_devices`.");
        self.raw.physicalDeviceCount = physical_devices.len() as _;
        self.raw.pPhysicalDevices = physical_devices.as_ptr() as *const vks::VkPhysicalDevice;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_physical_devices<'a>(&'a self) -> &'a [vks::VkPhysicalDevice] {
        unsafe { slice::from_raw_parts(self.raw.pPhysicalDevices as *const _, self.raw.physicalDeviceCount as usize) }
    }

    pub fn build(self) -> DeviceGroupDeviceCreateInfoKhx<'b> {
        DeviceGroupDeviceCreateInfoKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceGroupSwapchainCreateInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceGroupSwapchainCreateInfoKhx<'s> {
    raw: vks::VkDeviceGroupSwapchainCreateInfoKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> DeviceGroupSwapchainCreateInfoKhx<'s> {
    pub fn builder<'b>() -> DeviceGroupSwapchainCreateInfoKhxBuilder<'b> {
        DeviceGroupSwapchainCreateInfoKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceGroupSwapchainCreateInfoKHX) -> DeviceGroupSwapchainCreateInfoKhx<'s> {
        DeviceGroupSwapchainCreateInfoKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn modes<'a>(&'a self) -> DeviceGroupPresentModeFlagsKhx {
        DeviceGroupPresentModeFlagsKhx::from_bits(self.raw.modes)
            .expect("DeviceGroupSwapchainCreateInfoKhx::modes: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_modes<'m>(&mut self, modes: DeviceGroupPresentModeFlagsKhx) {
        self.raw.modes = modes.bits();
    }

    pub fn as_raw(&self) -> &vks::VkDeviceGroupSwapchainCreateInfoKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<DeviceGroupSwapchainCreateInfoKhx<'s>> for vks::VkDeviceGroupSwapchainCreateInfoKHX {
    fn from(f: DeviceGroupSwapchainCreateInfoKhx<'s>) -> vks::VkDeviceGroupSwapchainCreateInfoKHX {
        f.raw
    }
}


/// A builder for `VkDeviceGroupSwapchainCreateInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct DeviceGroupSwapchainCreateInfoKhxBuilder<'b> {
    raw: vks::VkDeviceGroupSwapchainCreateInfoKHX,
    _p: PhantomData<&'b ()>, 
}

#[cfg(feature = "experimental")]
impl<'b> DeviceGroupSwapchainCreateInfoKhxBuilder<'b> {
    pub fn new() -> DeviceGroupSwapchainCreateInfoKhxBuilder<'b> {
        DeviceGroupSwapchainCreateInfoKhxBuilder {
            raw: vks::VkDeviceGroupSwapchainCreateInfoKHX::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceGroupSwapchainCreateInfoKhxBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn modes<'m>(mut self, modes: DeviceGroupPresentModeFlagsKhx) -> DeviceGroupSwapchainCreateInfoKhxBuilder<'b> {
        self.raw.modes = modes.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_modes<'a>(&'a self) -> DeviceGroupPresentModeFlagsKhx {
        DeviceGroupPresentModeFlagsKhx::from_bits(self.raw.modes)
            .expect("DeviceGroupSwapchainCreateInfoKhx::modes: error converting flags")
    }

    pub fn build(self) -> DeviceGroupSwapchainCreateInfoKhx<'b> {
        DeviceGroupSwapchainCreateInfoKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDescriptorUpdateTemplateEntryKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DescriptorUpdateTemplateEntryKhr {
    raw: vks::VkDescriptorUpdateTemplateEntryKHR,
}

impl DescriptorUpdateTemplateEntryKhr {
    pub fn builder() -> DescriptorUpdateTemplateEntryKhrBuilder {
        DescriptorUpdateTemplateEntryKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDescriptorUpdateTemplateEntryKHR) -> DescriptorUpdateTemplateEntryKhr {
        DescriptorUpdateTemplateEntryKhr { raw, }
    }

    pub fn dst_binding<'a>(&'a self) -> u32 {
        self.raw.dstBinding.into()
    }

    pub fn dst_array_element<'a>(&'a self) -> u32 {
        self.raw.dstArrayElement.into()
    }

    pub fn descriptor_count<'a>(&'a self) -> u32 {
        self.raw.descriptorCount.into()
    }

    pub fn descriptor_type<'a>(&'a self) -> DescriptorType {
        self.raw.descriptorType.into()
    }

    pub fn offset<'a>(&'a self) -> usize {
        self.raw.offset.into()
    }

    pub fn stride<'a>(&'a self) -> usize {
        self.raw.stride.into()
    }

    pub fn set_dst_binding<'m>(&mut self, dst_binding: u32) {
        self.raw.dstBinding = dst_binding.into();
    }

    pub fn set_dst_array_element<'m>(&mut self, dst_array_element: u32) {
        self.raw.dstArrayElement = dst_array_element.into();
    }

    pub fn set_descriptor_count<'m>(&mut self, descriptor_count: u32) {
        self.raw.descriptorCount = descriptor_count.into();
    }

    pub fn set_descriptor_type<'m>(&mut self, descriptor_type: DescriptorType) {
        self.raw.descriptorType = descriptor_type.into();
    }

    pub fn set_offset<'m>(&mut self, offset: usize) {
        self.raw.offset = offset.into();
    }

    pub fn set_stride<'m>(&mut self, stride: usize) {
        self.raw.stride = stride.into();
    }

    pub fn as_raw(&self) -> &vks::VkDescriptorUpdateTemplateEntryKHR {
        &self.raw
    }
}

impl From<DescriptorUpdateTemplateEntryKhr> for vks::VkDescriptorUpdateTemplateEntryKHR {
    fn from(f: DescriptorUpdateTemplateEntryKhr) -> vks::VkDescriptorUpdateTemplateEntryKHR {
        f.raw
    }
}


/// A builder for `VkDescriptorUpdateTemplateEntryKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DescriptorUpdateTemplateEntryKhrBuilder {
    raw: vks::VkDescriptorUpdateTemplateEntryKHR,
}

impl DescriptorUpdateTemplateEntryKhrBuilder {
    pub fn new() -> DescriptorUpdateTemplateEntryKhrBuilder {
        DescriptorUpdateTemplateEntryKhrBuilder {
            raw: vks::VkDescriptorUpdateTemplateEntryKHR::default(),
        }
    }

    pub fn dst_binding<'m>(mut self, dst_binding: u32) -> DescriptorUpdateTemplateEntryKhrBuilder {
        self.raw.dstBinding = dst_binding.into();
        self
    }

    pub fn dst_array_element<'m>(mut self, dst_array_element: u32) -> DescriptorUpdateTemplateEntryKhrBuilder {
        self.raw.dstArrayElement = dst_array_element.into();
        self
    }

    pub fn descriptor_count<'m>(mut self, descriptor_count: u32) -> DescriptorUpdateTemplateEntryKhrBuilder {
        self.raw.descriptorCount = descriptor_count.into();
        self
    }

    pub fn descriptor_type<'m>(mut self, descriptor_type: DescriptorType) -> DescriptorUpdateTemplateEntryKhrBuilder {
        self.raw.descriptorType = descriptor_type.into();
        self
    }

    pub fn offset<'m>(mut self, offset: usize) -> DescriptorUpdateTemplateEntryKhrBuilder {
        self.raw.offset = offset.into();
        self
    }

    pub fn stride<'m>(mut self, stride: usize) -> DescriptorUpdateTemplateEntryKhrBuilder {
        self.raw.stride = stride.into();
        self
    }

    pub fn get_dst_binding<'a>(&'a self) -> u32 {
        self.raw.dstBinding.into()
    }

    pub fn get_dst_array_element<'a>(&'a self) -> u32 {
        self.raw.dstArrayElement.into()
    }

    pub fn get_descriptor_count<'a>(&'a self) -> u32 {
        self.raw.descriptorCount.into()
    }

    pub fn get_descriptor_type<'a>(&'a self) -> DescriptorType {
        self.raw.descriptorType.into()
    }

    pub fn get_offset<'a>(&'a self) -> usize {
        self.raw.offset.into()
    }

    pub fn get_stride<'a>(&'a self) -> usize {
        self.raw.stride.into()
    }

    pub fn build(self) -> DescriptorUpdateTemplateEntryKhr {
        DescriptorUpdateTemplateEntryKhr {
            raw: self.raw,
        }
    }
}


/// A `VkDescriptorUpdateTemplateCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DescriptorUpdateTemplateCreateInfoKhr<'s> {
    raw: vks::VkDescriptorUpdateTemplateCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> DescriptorUpdateTemplateCreateInfoKhr<'s> {
    pub fn builder<'b>() -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b> {
        DescriptorUpdateTemplateCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDescriptorUpdateTemplateCreateInfoKHR) -> DescriptorUpdateTemplateCreateInfoKhr<'s> {
        DescriptorUpdateTemplateCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> DescriptorUpdateTemplateCreateFlagsKhr {
        DescriptorUpdateTemplateCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("DescriptorUpdateTemplateCreateInfoKhr::flags: error converting flags")
    }

    pub fn descriptor_update_entries<'a>(&'a self) -> &'a [DescriptorUpdateTemplateEntryKhr] {
        unsafe { slice::from_raw_parts(self.raw.pDescriptorUpdateEntries as *const _, self.raw.descriptorUpdateEntryCount as usize) }
    }

    pub fn template_type<'a>(&'a self) -> DescriptorUpdateTemplateTypeKhr {
        self.raw.templateType.into()
    }

    pub fn descriptor_set_layout<'a>(&'a self) -> vks::VkDescriptorSetLayout {
        self.raw.descriptorSetLayout
    }

    pub fn pipeline_bind_point<'a>(&'a self) -> PipelineBindPoint {
        self.raw.pipelineBindPoint.into()
    }

    pub fn pipeline_layout<'a>(&'a self) -> vks::VkPipelineLayout {
        self.raw.pipelineLayout
    }

    pub fn set<'a>(&'a self) -> u32 {
        self.raw.set.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: DescriptorUpdateTemplateCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub fn set_descriptor_update_entries<'m, 'a>(&mut self, descriptor_update_entries: &'a [DescriptorUpdateTemplateEntryKhr])
            where 'a: 's {
        assert!(self.raw.descriptorUpdateEntryCount == 0 || self.raw.descriptorUpdateEntryCount == descriptor_update_entries.len() as _, 
            "count inconsistency found when specifying `DescriptorUpdateTemplateCreateInfoKhr::descriptor_update_entries`.");
        self.raw.descriptorUpdateEntryCount = descriptor_update_entries.len() as _;
        self.raw.pDescriptorUpdateEntries = descriptor_update_entries.as_ptr() as *const vks::VkDescriptorUpdateTemplateEntryKHR;
    }

    pub fn set_template_type<'m>(&mut self, template_type: DescriptorUpdateTemplateTypeKhr) {
        self.raw.templateType = template_type.into();
    }

    pub fn set_descriptor_set_layout<'m, H>(&mut self, descriptor_set_layout: H)
            where H: Handle<Target=DescriptorSetLayoutHandle> {
        self.raw.descriptorSetLayout = descriptor_set_layout.handle().0;
    }

    pub fn set_pipeline_bind_point<'m>(&mut self, pipeline_bind_point: PipelineBindPoint) {
        self.raw.pipelineBindPoint = pipeline_bind_point.into();
    }

    pub fn set_pipeline_layout<'m, H>(&mut self, pipeline_layout: H)
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.pipelineLayout = pipeline_layout.handle().0;
    }

    pub fn set_set<'m>(&mut self, set: u32) {
        self.raw.set = set.into();
    }

    pub fn as_raw(&self) -> &vks::VkDescriptorUpdateTemplateCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<DescriptorUpdateTemplateCreateInfoKhr<'s>> for vks::VkDescriptorUpdateTemplateCreateInfoKHR {
    fn from(f: DescriptorUpdateTemplateCreateInfoKhr<'s>) -> vks::VkDescriptorUpdateTemplateCreateInfoKHR {
        f.raw
    }
}


/// A builder for `VkDescriptorUpdateTemplateCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DescriptorUpdateTemplateCreateInfoKhrBuilder<'b> {
    raw: vks::VkDescriptorUpdateTemplateCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b> {
    pub fn new() -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b> {
        DescriptorUpdateTemplateCreateInfoKhrBuilder {
            raw: vks::VkDescriptorUpdateTemplateCreateInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: DescriptorUpdateTemplateCreateFlagsKhr) -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn descriptor_update_entries<'m, 'a>(mut self, descriptor_update_entries: &'a [DescriptorUpdateTemplateEntryKhr]) -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.descriptorUpdateEntryCount == 0 || self.raw.descriptorUpdateEntryCount == descriptor_update_entries.len() as _, 
            "count inconsistency found when specifying `DescriptorUpdateTemplateCreateInfoKhr::descriptor_update_entries`.");
        self.raw.descriptorUpdateEntryCount = descriptor_update_entries.len() as _;
        self.raw.pDescriptorUpdateEntries = descriptor_update_entries.as_ptr() as *const vks::VkDescriptorUpdateTemplateEntryKHR;
        self
    }

    pub fn template_type<'m>(mut self, template_type: DescriptorUpdateTemplateTypeKhr) -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b> {
        self.raw.templateType = template_type.into();
        self
    }

    pub fn descriptor_set_layout<'m, H>(mut self, descriptor_set_layout: H) -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b>
            where H: Handle<Target=DescriptorSetLayoutHandle> {
        self.raw.descriptorSetLayout = descriptor_set_layout.handle().0;
        self
    }

    pub fn pipeline_bind_point<'m>(mut self, pipeline_bind_point: PipelineBindPoint) -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b> {
        self.raw.pipelineBindPoint = pipeline_bind_point.into();
        self
    }

    pub fn pipeline_layout<'m, H>(mut self, pipeline_layout: H) -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b>
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.pipelineLayout = pipeline_layout.handle().0;
        self
    }

    pub fn set<'m>(mut self, set: u32) -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b> {
        self.raw.set = set.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> DescriptorUpdateTemplateCreateFlagsKhr {
        DescriptorUpdateTemplateCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("DescriptorUpdateTemplateCreateInfoKhr::flags: error converting flags")
    }

    pub fn get_descriptor_update_entries<'a>(&'a self) -> &'a [DescriptorUpdateTemplateEntryKhr] {
        unsafe { slice::from_raw_parts(self.raw.pDescriptorUpdateEntries as *const _, self.raw.descriptorUpdateEntryCount as usize) }
    }

    pub fn get_template_type<'a>(&'a self) -> DescriptorUpdateTemplateTypeKhr {
        self.raw.templateType.into()
    }

    pub fn get_descriptor_set_layout<'a>(&'a self) -> vks::VkDescriptorSetLayout {
        self.raw.descriptorSetLayout
    }

    pub fn get_pipeline_bind_point<'a>(&'a self) -> PipelineBindPoint {
        self.raw.pipelineBindPoint.into()
    }

    pub fn get_pipeline_layout<'a>(&'a self) -> vks::VkPipelineLayout {
        self.raw.pipelineLayout
    }

    pub fn get_set<'a>(&'a self) -> u32 {
        self.raw.set.into()
    }

    pub fn build(self) -> DescriptorUpdateTemplateCreateInfoKhr<'b> {
        DescriptorUpdateTemplateCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkXYColorEXT`.
///
/// Chromaticity coordinate
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct XYColorExt {
    raw: vks::VkXYColorEXT,
}

impl XYColorExt {
    pub fn builder() -> XYColorExtBuilder {
        XYColorExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkXYColorEXT) -> XYColorExt {
        XYColorExt { raw, }
    }

    pub fn x<'a>(&'a self) -> f32 {
        self.raw.x.into()
    }

    pub fn y<'a>(&'a self) -> f32 {
        self.raw.y.into()
    }

    pub fn set_x<'m>(&mut self, x: f32) {
        self.raw.x = x.into();
    }

    pub fn set_y<'m>(&mut self, y: f32) {
        self.raw.y = y.into();
    }

    pub fn as_raw(&self) -> &vks::VkXYColorEXT {
        &self.raw
    }
}

impl From<XYColorExt> for vks::VkXYColorEXT {
    fn from(f: XYColorExt) -> vks::VkXYColorEXT {
        f.raw
    }
}


/// A builder for `VkXYColorEXT`.
///
/// Chromaticity coordinate
#[derive(Debug, Clone, Default)]
pub struct XYColorExtBuilder {
    raw: vks::VkXYColorEXT,
}

impl XYColorExtBuilder {
    pub fn new() -> XYColorExtBuilder {
        XYColorExtBuilder {
            raw: vks::VkXYColorEXT::default(),
        }
    }

    pub fn x<'m>(mut self, x: f32) -> XYColorExtBuilder {
        self.raw.x = x.into();
        self
    }

    pub fn y<'m>(mut self, y: f32) -> XYColorExtBuilder {
        self.raw.y = y.into();
        self
    }

    pub fn get_x<'a>(&'a self) -> f32 {
        self.raw.x.into()
    }

    pub fn get_y<'a>(&'a self) -> f32 {
        self.raw.y.into()
    }

    pub fn build(self) -> XYColorExt {
        XYColorExt {
            raw: self.raw,
        }
    }
}


/// A `VkHdrMetadataEXT`.
///
///  From CTA 861.3
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct HdrMetadataExt<'s> {
    raw: vks::VkHdrMetadataEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> HdrMetadataExt<'s> {
    pub fn builder<'b>() -> HdrMetadataExtBuilder<'b> {
        HdrMetadataExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkHdrMetadataEXT) -> HdrMetadataExt<'s> {
        HdrMetadataExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn display_primary_red<'a>(&'a self) -> &'a XYColorExt {
        unsafe { &*(&self.raw.displayPrimaryRed as *const vks::VkXYColorEXT as *const XYColorExt) }
    }

    pub fn display_primary_red_mut<'a>(&'a mut self) -> &'a mut XYColorExt {
        unsafe { &mut *(&mut self.raw.displayPrimaryRed as *mut  vks::VkXYColorEXT as *mut XYColorExt) }
    }

    pub fn display_primary_green<'a>(&'a self) -> &'a XYColorExt {
        unsafe { &*(&self.raw.displayPrimaryGreen as *const vks::VkXYColorEXT as *const XYColorExt) }
    }

    pub fn display_primary_green_mut<'a>(&'a mut self) -> &'a mut XYColorExt {
        unsafe { &mut *(&mut self.raw.displayPrimaryGreen as *mut  vks::VkXYColorEXT as *mut XYColorExt) }
    }

    pub fn display_primary_blue<'a>(&'a self) -> &'a XYColorExt {
        unsafe { &*(&self.raw.displayPrimaryBlue as *const vks::VkXYColorEXT as *const XYColorExt) }
    }

    pub fn display_primary_blue_mut<'a>(&'a mut self) -> &'a mut XYColorExt {
        unsafe { &mut *(&mut self.raw.displayPrimaryBlue as *mut  vks::VkXYColorEXT as *mut XYColorExt) }
    }

    pub fn white_point<'a>(&'a self) -> &'a XYColorExt {
        unsafe { &*(&self.raw.whitePoint as *const vks::VkXYColorEXT as *const XYColorExt) }
    }

    pub fn white_point_mut<'a>(&'a mut self) -> &'a mut XYColorExt {
        unsafe { &mut *(&mut self.raw.whitePoint as *mut  vks::VkXYColorEXT as *mut XYColorExt) }
    }

    pub fn max_luminance<'a>(&'a self) -> f32 {
        self.raw.maxLuminance.into()
    }

    pub fn min_luminance<'a>(&'a self) -> f32 {
        self.raw.minLuminance.into()
    }

    pub fn max_content_light_level<'a>(&'a self) -> f32 {
        self.raw.maxContentLightLevel.into()
    }

    pub fn max_frame_average_light_level<'a>(&'a self) -> f32 {
        self.raw.maxFrameAverageLightLevel.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_display_primary_red<'m>(&mut self, display_primary_red: XYColorExt) {
        self.raw.displayPrimaryRed = display_primary_red.raw;
    }

    pub fn set_display_primary_green<'m>(&mut self, display_primary_green: XYColorExt) {
        self.raw.displayPrimaryGreen = display_primary_green.raw;
    }

    pub fn set_display_primary_blue<'m>(&mut self, display_primary_blue: XYColorExt) {
        self.raw.displayPrimaryBlue = display_primary_blue.raw;
    }

    pub fn set_white_point<'m>(&mut self, white_point: XYColorExt) {
        self.raw.whitePoint = white_point.raw;
    }

    pub fn set_max_luminance<'m>(&mut self, max_luminance: f32) {
        self.raw.maxLuminance = max_luminance.into();
    }

    pub fn set_min_luminance<'m>(&mut self, min_luminance: f32) {
        self.raw.minLuminance = min_luminance.into();
    }

    pub fn set_max_content_light_level<'m>(&mut self, max_content_light_level: f32) {
        self.raw.maxContentLightLevel = max_content_light_level.into();
    }

    pub fn set_max_frame_average_light_level<'m>(&mut self, max_frame_average_light_level: f32) {
        self.raw.maxFrameAverageLightLevel = max_frame_average_light_level.into();
    }

    pub fn as_raw(&self) -> &vks::VkHdrMetadataEXT {
        &self.raw
    }
}

impl<'s> From<HdrMetadataExt<'s>> for vks::VkHdrMetadataEXT {
    fn from(f: HdrMetadataExt<'s>) -> vks::VkHdrMetadataEXT {
        f.raw
    }
}


/// A builder for `VkHdrMetadataEXT`.
///
///  From CTA 861.3
#[derive(Debug, Clone, Default)]
pub struct HdrMetadataExtBuilder<'b> {
    raw: vks::VkHdrMetadataEXT,
    _p: PhantomData<&'b ()>, 
}

impl<'b> HdrMetadataExtBuilder<'b> {
    pub fn new() -> HdrMetadataExtBuilder<'b> {
        HdrMetadataExtBuilder {
            raw: vks::VkHdrMetadataEXT::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> HdrMetadataExtBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn display_primary_red<'m>(mut self, display_primary_red: XYColorExt) -> HdrMetadataExtBuilder<'b> {
        self.raw.displayPrimaryRed = display_primary_red.raw;
        self
    }

    pub fn display_primary_green<'m>(mut self, display_primary_green: XYColorExt) -> HdrMetadataExtBuilder<'b> {
        self.raw.displayPrimaryGreen = display_primary_green.raw;
        self
    }

    pub fn display_primary_blue<'m>(mut self, display_primary_blue: XYColorExt) -> HdrMetadataExtBuilder<'b> {
        self.raw.displayPrimaryBlue = display_primary_blue.raw;
        self
    }

    pub fn white_point<'m>(mut self, white_point: XYColorExt) -> HdrMetadataExtBuilder<'b> {
        self.raw.whitePoint = white_point.raw;
        self
    }

    pub fn max_luminance<'m>(mut self, max_luminance: f32) -> HdrMetadataExtBuilder<'b> {
        self.raw.maxLuminance = max_luminance.into();
        self
    }

    pub fn min_luminance<'m>(mut self, min_luminance: f32) -> HdrMetadataExtBuilder<'b> {
        self.raw.minLuminance = min_luminance.into();
        self
    }

    pub fn max_content_light_level<'m>(mut self, max_content_light_level: f32) -> HdrMetadataExtBuilder<'b> {
        self.raw.maxContentLightLevel = max_content_light_level.into();
        self
    }

    pub fn max_frame_average_light_level<'m>(mut self, max_frame_average_light_level: f32) -> HdrMetadataExtBuilder<'b> {
        self.raw.maxFrameAverageLightLevel = max_frame_average_light_level.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_display_primary_red<'a>(&'a self) -> &'a XYColorExt {
        unsafe { &*(&self.raw.displayPrimaryRed as *const vks::VkXYColorEXT as *const XYColorExt) }
    }

    pub fn get_display_primary_red_mut<'a>(&'a mut self) -> &'a mut XYColorExt {
        unsafe { &mut *(&mut self.raw.displayPrimaryRed as *mut  vks::VkXYColorEXT as *mut XYColorExt) }
    }

    pub fn get_display_primary_green<'a>(&'a self) -> &'a XYColorExt {
        unsafe { &*(&self.raw.displayPrimaryGreen as *const vks::VkXYColorEXT as *const XYColorExt) }
    }

    pub fn get_display_primary_green_mut<'a>(&'a mut self) -> &'a mut XYColorExt {
        unsafe { &mut *(&mut self.raw.displayPrimaryGreen as *mut  vks::VkXYColorEXT as *mut XYColorExt) }
    }

    pub fn get_display_primary_blue<'a>(&'a self) -> &'a XYColorExt {
        unsafe { &*(&self.raw.displayPrimaryBlue as *const vks::VkXYColorEXT as *const XYColorExt) }
    }

    pub fn get_display_primary_blue_mut<'a>(&'a mut self) -> &'a mut XYColorExt {
        unsafe { &mut *(&mut self.raw.displayPrimaryBlue as *mut  vks::VkXYColorEXT as *mut XYColorExt) }
    }

    pub fn get_white_point<'a>(&'a self) -> &'a XYColorExt {
        unsafe { &*(&self.raw.whitePoint as *const vks::VkXYColorEXT as *const XYColorExt) }
    }

    pub fn get_white_point_mut<'a>(&'a mut self) -> &'a mut XYColorExt {
        unsafe { &mut *(&mut self.raw.whitePoint as *mut  vks::VkXYColorEXT as *mut XYColorExt) }
    }

    pub fn get_max_luminance<'a>(&'a self) -> f32 {
        self.raw.maxLuminance.into()
    }

    pub fn get_min_luminance<'a>(&'a self) -> f32 {
        self.raw.minLuminance.into()
    }

    pub fn get_max_content_light_level<'a>(&'a self) -> f32 {
        self.raw.maxContentLightLevel.into()
    }

    pub fn get_max_frame_average_light_level<'a>(&'a self) -> f32 {
        self.raw.maxFrameAverageLightLevel.into()
    }

    pub fn build(self) -> HdrMetadataExt<'b> {
        HdrMetadataExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkRefreshCycleDurationGOOGLE`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct RefreshCycleDurationGoogle {
    raw: vks::VkRefreshCycleDurationGOOGLE,
}

impl RefreshCycleDurationGoogle {
    pub fn builder() -> RefreshCycleDurationGoogleBuilder {
        RefreshCycleDurationGoogleBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkRefreshCycleDurationGOOGLE) -> RefreshCycleDurationGoogle {
        RefreshCycleDurationGoogle { raw, }
    }

    pub fn refresh_duration<'a>(&'a self) -> u64 {
        self.raw.refreshDuration.into()
    }

    pub fn set_refresh_duration<'m>(&mut self, refresh_duration: u64) {
        self.raw.refreshDuration = refresh_duration.into();
    }

    pub fn as_raw(&self) -> &vks::VkRefreshCycleDurationGOOGLE {
        &self.raw
    }
}

impl From<RefreshCycleDurationGoogle> for vks::VkRefreshCycleDurationGOOGLE {
    fn from(f: RefreshCycleDurationGoogle) -> vks::VkRefreshCycleDurationGOOGLE {
        f.raw
    }
}


/// A builder for `VkRefreshCycleDurationGOOGLE`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct RefreshCycleDurationGoogleBuilder {
    raw: vks::VkRefreshCycleDurationGOOGLE,
}

impl RefreshCycleDurationGoogleBuilder {
    pub fn new() -> RefreshCycleDurationGoogleBuilder {
        RefreshCycleDurationGoogleBuilder {
            raw: vks::VkRefreshCycleDurationGOOGLE::default(),
        }
    }

    pub fn refresh_duration<'m>(mut self, refresh_duration: u64) -> RefreshCycleDurationGoogleBuilder {
        self.raw.refreshDuration = refresh_duration.into();
        self
    }

    pub fn get_refresh_duration<'a>(&'a self) -> u64 {
        self.raw.refreshDuration.into()
    }

    pub fn build(self) -> RefreshCycleDurationGoogle {
        RefreshCycleDurationGoogle {
            raw: self.raw,
        }
    }
}


/// A `VkPastPresentationTimingGOOGLE`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PastPresentationTimingGoogle {
    raw: vks::VkPastPresentationTimingGOOGLE,
}

impl PastPresentationTimingGoogle {
    pub fn builder() -> PastPresentationTimingGoogleBuilder {
        PastPresentationTimingGoogleBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPastPresentationTimingGOOGLE) -> PastPresentationTimingGoogle {
        PastPresentationTimingGoogle { raw, }
    }

    pub fn present_id<'a>(&'a self) -> u32 {
        self.raw.presentID.into()
    }

    pub fn desired_present_time<'a>(&'a self) -> u64 {
        self.raw.desiredPresentTime.into()
    }

    pub fn actual_present_time<'a>(&'a self) -> u64 {
        self.raw.actualPresentTime.into()
    }

    pub fn earliest_present_time<'a>(&'a self) -> u64 {
        self.raw.earliestPresentTime.into()
    }

    pub fn present_margin<'a>(&'a self) -> u64 {
        self.raw.presentMargin.into()
    }

    pub fn set_present_id<'m>(&mut self, present_id: u32) {
        self.raw.presentID = present_id.into();
    }

    pub fn set_desired_present_time<'m>(&mut self, desired_present_time: u64) {
        self.raw.desiredPresentTime = desired_present_time.into();
    }

    pub fn set_actual_present_time<'m>(&mut self, actual_present_time: u64) {
        self.raw.actualPresentTime = actual_present_time.into();
    }

    pub fn set_earliest_present_time<'m>(&mut self, earliest_present_time: u64) {
        self.raw.earliestPresentTime = earliest_present_time.into();
    }

    pub fn set_present_margin<'m>(&mut self, present_margin: u64) {
        self.raw.presentMargin = present_margin.into();
    }

    pub fn as_raw(&self) -> &vks::VkPastPresentationTimingGOOGLE {
        &self.raw
    }
}

impl From<PastPresentationTimingGoogle> for vks::VkPastPresentationTimingGOOGLE {
    fn from(f: PastPresentationTimingGoogle) -> vks::VkPastPresentationTimingGOOGLE {
        f.raw
    }
}


/// A builder for `VkPastPresentationTimingGOOGLE`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PastPresentationTimingGoogleBuilder {
    raw: vks::VkPastPresentationTimingGOOGLE,
}

impl PastPresentationTimingGoogleBuilder {
    pub fn new() -> PastPresentationTimingGoogleBuilder {
        PastPresentationTimingGoogleBuilder {
            raw: vks::VkPastPresentationTimingGOOGLE::default(),
        }
    }

    pub fn present_id<'m>(mut self, present_id: u32) -> PastPresentationTimingGoogleBuilder {
        self.raw.presentID = present_id.into();
        self
    }

    pub fn desired_present_time<'m>(mut self, desired_present_time: u64) -> PastPresentationTimingGoogleBuilder {
        self.raw.desiredPresentTime = desired_present_time.into();
        self
    }

    pub fn actual_present_time<'m>(mut self, actual_present_time: u64) -> PastPresentationTimingGoogleBuilder {
        self.raw.actualPresentTime = actual_present_time.into();
        self
    }

    pub fn earliest_present_time<'m>(mut self, earliest_present_time: u64) -> PastPresentationTimingGoogleBuilder {
        self.raw.earliestPresentTime = earliest_present_time.into();
        self
    }

    pub fn present_margin<'m>(mut self, present_margin: u64) -> PastPresentationTimingGoogleBuilder {
        self.raw.presentMargin = present_margin.into();
        self
    }

    pub fn get_present_id<'a>(&'a self) -> u32 {
        self.raw.presentID.into()
    }

    pub fn get_desired_present_time<'a>(&'a self) -> u64 {
        self.raw.desiredPresentTime.into()
    }

    pub fn get_actual_present_time<'a>(&'a self) -> u64 {
        self.raw.actualPresentTime.into()
    }

    pub fn get_earliest_present_time<'a>(&'a self) -> u64 {
        self.raw.earliestPresentTime.into()
    }

    pub fn get_present_margin<'a>(&'a self) -> u64 {
        self.raw.presentMargin.into()
    }

    pub fn build(self) -> PastPresentationTimingGoogle {
        PastPresentationTimingGoogle {
            raw: self.raw,
        }
    }
}


/// A `VkPresentTimesInfoGOOGLE`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PresentTimesInfoGoogle<'s> {
    raw: vks::VkPresentTimesInfoGOOGLE,
    _p: PhantomData<&'s ()>,
}

impl<'s> PresentTimesInfoGoogle<'s> {
    pub fn builder<'b>() -> PresentTimesInfoGoogleBuilder<'b> {
        PresentTimesInfoGoogleBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPresentTimesInfoGOOGLE) -> PresentTimesInfoGoogle<'s> {
        PresentTimesInfoGoogle { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn times<'a>(&'a self) -> &'a [PresentTimeGoogle] {
        unsafe { slice::from_raw_parts(self.raw.pTimes as *const _, self.raw.swapchainCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_times<'m, 'a>(&mut self, times: &'a [PresentTimeGoogle])
            where 'a: 's {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == times.len() as _, 
            "count inconsistency found when specifying `PresentTimesInfoGoogle::times`.");
        self.raw.swapchainCount = times.len() as _;
        self.raw.pTimes = times.as_ptr() as *const vks::VkPresentTimeGOOGLE;
    }

    pub fn as_raw(&self) -> &vks::VkPresentTimesInfoGOOGLE {
        &self.raw
    }
}

impl<'s> From<PresentTimesInfoGoogle<'s>> for vks::VkPresentTimesInfoGOOGLE {
    fn from(f: PresentTimesInfoGoogle<'s>) -> vks::VkPresentTimesInfoGOOGLE {
        f.raw
    }
}


/// A builder for `VkPresentTimesInfoGOOGLE`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PresentTimesInfoGoogleBuilder<'b> {
    raw: vks::VkPresentTimesInfoGOOGLE,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PresentTimesInfoGoogleBuilder<'b> {
    pub fn new() -> PresentTimesInfoGoogleBuilder<'b> {
        PresentTimesInfoGoogleBuilder {
            raw: vks::VkPresentTimesInfoGOOGLE::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PresentTimesInfoGoogleBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn times<'m, 'a>(mut self, times: &'a [PresentTimeGoogle]) -> PresentTimesInfoGoogleBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == times.len() as _, 
            "count inconsistency found when specifying `PresentTimesInfoGoogle::times`.");
        self.raw.swapchainCount = times.len() as _;
        self.raw.pTimes = times.as_ptr() as *const vks::VkPresentTimeGOOGLE;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_times<'a>(&'a self) -> &'a [PresentTimeGoogle] {
        unsafe { slice::from_raw_parts(self.raw.pTimes as *const _, self.raw.swapchainCount as usize) }
    }

    pub fn build(self) -> PresentTimesInfoGoogle<'b> {
        PresentTimesInfoGoogle {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPresentTimeGOOGLE`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PresentTimeGoogle {
    raw: vks::VkPresentTimeGOOGLE,
}

impl PresentTimeGoogle {
    pub fn builder() -> PresentTimeGoogleBuilder {
        PresentTimeGoogleBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPresentTimeGOOGLE) -> PresentTimeGoogle {
        PresentTimeGoogle { raw, }
    }

    pub fn present_id<'a>(&'a self) -> u32 {
        self.raw.presentID.into()
    }

    pub fn desired_present_time<'a>(&'a self) -> u64 {
        self.raw.desiredPresentTime.into()
    }

    pub fn set_present_id<'m>(&mut self, present_id: u32) {
        self.raw.presentID = present_id.into();
    }

    pub fn set_desired_present_time<'m>(&mut self, desired_present_time: u64) {
        self.raw.desiredPresentTime = desired_present_time.into();
    }

    pub fn as_raw(&self) -> &vks::VkPresentTimeGOOGLE {
        &self.raw
    }
}

impl From<PresentTimeGoogle> for vks::VkPresentTimeGOOGLE {
    fn from(f: PresentTimeGoogle) -> vks::VkPresentTimeGOOGLE {
        f.raw
    }
}


/// A builder for `VkPresentTimeGOOGLE`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PresentTimeGoogleBuilder {
    raw: vks::VkPresentTimeGOOGLE,
}

impl PresentTimeGoogleBuilder {
    pub fn new() -> PresentTimeGoogleBuilder {
        PresentTimeGoogleBuilder {
            raw: vks::VkPresentTimeGOOGLE::default(),
        }
    }

    pub fn present_id<'m>(mut self, present_id: u32) -> PresentTimeGoogleBuilder {
        self.raw.presentID = present_id.into();
        self
    }

    pub fn desired_present_time<'m>(mut self, desired_present_time: u64) -> PresentTimeGoogleBuilder {
        self.raw.desiredPresentTime = desired_present_time.into();
        self
    }

    pub fn get_present_id<'a>(&'a self) -> u32 {
        self.raw.presentID.into()
    }

    pub fn get_desired_present_time<'a>(&'a self) -> u64 {
        self.raw.desiredPresentTime.into()
    }

    pub fn build(self) -> PresentTimeGoogle {
        PresentTimeGoogle {
            raw: self.raw,
        }
    }
}


/// A `VkIOSSurfaceCreateInfoMVK`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct IosSurfaceCreateInfoMvk<'s> {
    raw: vks::VkIOSSurfaceCreateInfoMVK,
    _p: PhantomData<&'s ()>,
}

impl<'s> IosSurfaceCreateInfoMvk<'s> {
    pub fn builder<'b>() -> IosSurfaceCreateInfoMvkBuilder<'b> {
        IosSurfaceCreateInfoMvkBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkIOSSurfaceCreateInfoMVK) -> IosSurfaceCreateInfoMvk<'s> {
        IosSurfaceCreateInfoMvk { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> IosSurfaceCreateFlagsMvk {
        IosSurfaceCreateFlagsMvk::from_bits(self.raw.flags)
            .expect("IosSurfaceCreateInfoMvk::flags: error converting flags")
    }

    pub fn view<'a>(&'a self) -> *const c_void {
        self.raw.pView
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: IosSurfaceCreateFlagsMvk) {
        self.raw.flags = flags.bits();
    }

    pub unsafe fn set_view<'m>(&mut self, view: *const c_void) {
        self.raw.pView = view;
    }

    pub fn as_raw(&self) -> &vks::VkIOSSurfaceCreateInfoMVK {
        &self.raw
    }
}

impl<'s> From<IosSurfaceCreateInfoMvk<'s>> for vks::VkIOSSurfaceCreateInfoMVK {
    fn from(f: IosSurfaceCreateInfoMvk<'s>) -> vks::VkIOSSurfaceCreateInfoMVK {
        f.raw
    }
}


/// A builder for `VkIOSSurfaceCreateInfoMVK`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct IosSurfaceCreateInfoMvkBuilder<'b> {
    raw: vks::VkIOSSurfaceCreateInfoMVK,
    _p: PhantomData<&'b ()>, 
}

impl<'b> IosSurfaceCreateInfoMvkBuilder<'b> {
    pub fn new() -> IosSurfaceCreateInfoMvkBuilder<'b> {
        IosSurfaceCreateInfoMvkBuilder {
            raw: vks::VkIOSSurfaceCreateInfoMVK::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> IosSurfaceCreateInfoMvkBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: IosSurfaceCreateFlagsMvk) -> IosSurfaceCreateInfoMvkBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub unsafe fn view<'m>(mut self, view: *const c_void) -> IosSurfaceCreateInfoMvkBuilder<'b> {
        self.raw.pView = view;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> IosSurfaceCreateFlagsMvk {
        IosSurfaceCreateFlagsMvk::from_bits(self.raw.flags)
            .expect("IosSurfaceCreateInfoMvk::flags: error converting flags")
    }

    pub fn get_view<'a>(&'a self) -> *const c_void {
        self.raw.pView
    }

    pub fn build(self) -> IosSurfaceCreateInfoMvk<'b> {
        IosSurfaceCreateInfoMvk {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMacOSSurfaceCreateInfoMVK`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MacOsSurfaceCreateInfoMvk<'s> {
    raw: vks::VkMacOSSurfaceCreateInfoMVK,
    _p: PhantomData<&'s ()>,
}

impl<'s> MacOsSurfaceCreateInfoMvk<'s> {
    pub fn builder<'b>() -> MacOsSurfaceCreateInfoMvkBuilder<'b> {
        MacOsSurfaceCreateInfoMvkBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMacOSSurfaceCreateInfoMVK) -> MacOsSurfaceCreateInfoMvk<'s> {
        MacOsSurfaceCreateInfoMvk { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> MacOsSurfaceCreateFlagsMvk {
        MacOsSurfaceCreateFlagsMvk::from_bits(self.raw.flags)
            .expect("MacOsSurfaceCreateInfoMvk::flags: error converting flags")
    }

    pub fn view<'a>(&'a self) -> *const c_void {
        self.raw.pView
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: MacOsSurfaceCreateFlagsMvk) {
        self.raw.flags = flags.bits();
    }

    pub unsafe fn set_view<'m>(&mut self, view: *const c_void) {
        self.raw.pView = view;
    }

    pub fn as_raw(&self) -> &vks::VkMacOSSurfaceCreateInfoMVK {
        &self.raw
    }
}

impl<'s> From<MacOsSurfaceCreateInfoMvk<'s>> for vks::VkMacOSSurfaceCreateInfoMVK {
    fn from(f: MacOsSurfaceCreateInfoMvk<'s>) -> vks::VkMacOSSurfaceCreateInfoMVK {
        f.raw
    }
}


/// A builder for `VkMacOSSurfaceCreateInfoMVK`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MacOsSurfaceCreateInfoMvkBuilder<'b> {
    raw: vks::VkMacOSSurfaceCreateInfoMVK,
    _p: PhantomData<&'b ()>, 
}

impl<'b> MacOsSurfaceCreateInfoMvkBuilder<'b> {
    pub fn new() -> MacOsSurfaceCreateInfoMvkBuilder<'b> {
        MacOsSurfaceCreateInfoMvkBuilder {
            raw: vks::VkMacOSSurfaceCreateInfoMVK::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> MacOsSurfaceCreateInfoMvkBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: MacOsSurfaceCreateFlagsMvk) -> MacOsSurfaceCreateInfoMvkBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub unsafe fn view<'m>(mut self, view: *const c_void) -> MacOsSurfaceCreateInfoMvkBuilder<'b> {
        self.raw.pView = view;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> MacOsSurfaceCreateFlagsMvk {
        MacOsSurfaceCreateFlagsMvk::from_bits(self.raw.flags)
            .expect("MacOsSurfaceCreateInfoMvk::flags: error converting flags")
    }

    pub fn get_view<'a>(&'a self) -> *const c_void {
        self.raw.pView
    }

    pub fn build(self) -> MacOsSurfaceCreateInfoMvk<'b> {
        MacOsSurfaceCreateInfoMvk {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkViewportWScalingNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ViewportWScalingNv {
    raw: vks::VkViewportWScalingNV,
}

impl ViewportWScalingNv {
    pub fn builder() -> ViewportWScalingNvBuilder {
        ViewportWScalingNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkViewportWScalingNV) -> ViewportWScalingNv {
        ViewportWScalingNv { raw, }
    }

    pub fn xcoeff<'a>(&'a self) -> f32 {
        self.raw.xcoeff.into()
    }

    pub fn ycoeff<'a>(&'a self) -> f32 {
        self.raw.ycoeff.into()
    }

    pub fn set_xcoeff<'m>(&mut self, xcoeff: f32) {
        self.raw.xcoeff = xcoeff.into();
    }

    pub fn set_ycoeff<'m>(&mut self, ycoeff: f32) {
        self.raw.ycoeff = ycoeff.into();
    }

    pub fn as_raw(&self) -> &vks::VkViewportWScalingNV {
        &self.raw
    }
}

impl From<ViewportWScalingNv> for vks::VkViewportWScalingNV {
    fn from(f: ViewportWScalingNv) -> vks::VkViewportWScalingNV {
        f.raw
    }
}


/// A builder for `VkViewportWScalingNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ViewportWScalingNvBuilder {
    raw: vks::VkViewportWScalingNV,
}

impl ViewportWScalingNvBuilder {
    pub fn new() -> ViewportWScalingNvBuilder {
        ViewportWScalingNvBuilder {
            raw: vks::VkViewportWScalingNV::default(),
        }
    }

    pub fn xcoeff<'m>(mut self, xcoeff: f32) -> ViewportWScalingNvBuilder {
        self.raw.xcoeff = xcoeff.into();
        self
    }

    pub fn ycoeff<'m>(mut self, ycoeff: f32) -> ViewportWScalingNvBuilder {
        self.raw.ycoeff = ycoeff.into();
        self
    }

    pub fn get_xcoeff<'a>(&'a self) -> f32 {
        self.raw.xcoeff.into()
    }

    pub fn get_ycoeff<'a>(&'a self) -> f32 {
        self.raw.ycoeff.into()
    }

    pub fn build(self) -> ViewportWScalingNv {
        ViewportWScalingNv {
            raw: self.raw,
        }
    }
}


/// A `VkPipelineViewportWScalingStateCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineViewportWScalingStateCreateInfoNv<'s> {
    raw: vks::VkPipelineViewportWScalingStateCreateInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineViewportWScalingStateCreateInfoNv<'s> {
    pub fn builder<'b>() -> PipelineViewportWScalingStateCreateInfoNvBuilder<'b> {
        PipelineViewportWScalingStateCreateInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineViewportWScalingStateCreateInfoNV) -> PipelineViewportWScalingStateCreateInfoNv<'s> {
        PipelineViewportWScalingStateCreateInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn viewport_wscaling_enable<'a>(&'a self) -> bool {
        self.raw.viewportWScalingEnable != 0
    }

    pub fn viewport_wscalings<'a>(&'a self) -> &'a [ViewportWScalingNv] {
        unsafe { slice::from_raw_parts(self.raw.pViewportWScalings as *const _, self.raw.viewportCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_viewport_wscaling_enable<'m>(&mut self, viewport_wscaling_enable: bool) {
        self.raw.viewportWScalingEnable = viewport_wscaling_enable as u32;
    }

    pub fn set_viewport_wscalings<'m, 'a>(&mut self, viewport_wscalings: &'a [ViewportWScalingNv])
            where 'a: 's {
        assert!(self.raw.viewportCount == 0 || self.raw.viewportCount == viewport_wscalings.len() as _, 
            "count inconsistency found when specifying `PipelineViewportWScalingStateCreateInfoNv::viewport_wscalings`.");
        self.raw.viewportCount = viewport_wscalings.len() as _;
        self.raw.pViewportWScalings = viewport_wscalings.as_ptr() as *const vks::VkViewportWScalingNV;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineViewportWScalingStateCreateInfoNV {
        &self.raw
    }
}

impl<'s> From<PipelineViewportWScalingStateCreateInfoNv<'s>> for vks::VkPipelineViewportWScalingStateCreateInfoNV {
    fn from(f: PipelineViewportWScalingStateCreateInfoNv<'s>) -> vks::VkPipelineViewportWScalingStateCreateInfoNV {
        f.raw
    }
}


/// A builder for `VkPipelineViewportWScalingStateCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineViewportWScalingStateCreateInfoNvBuilder<'b> {
    raw: vks::VkPipelineViewportWScalingStateCreateInfoNV,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineViewportWScalingStateCreateInfoNvBuilder<'b> {
    pub fn new() -> PipelineViewportWScalingStateCreateInfoNvBuilder<'b> {
        PipelineViewportWScalingStateCreateInfoNvBuilder {
            raw: vks::VkPipelineViewportWScalingStateCreateInfoNV::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineViewportWScalingStateCreateInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn viewport_wscaling_enable<'m>(mut self, viewport_wscaling_enable: bool) -> PipelineViewportWScalingStateCreateInfoNvBuilder<'b> {
        self.raw.viewportWScalingEnable = viewport_wscaling_enable as u32;
        self
    }

    pub fn viewport_wscalings<'m, 'a>(mut self, viewport_wscalings: &'a [ViewportWScalingNv]) -> PipelineViewportWScalingStateCreateInfoNvBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.viewportCount == 0 || self.raw.viewportCount == viewport_wscalings.len() as _, 
            "count inconsistency found when specifying `PipelineViewportWScalingStateCreateInfoNv::viewport_wscalings`.");
        self.raw.viewportCount = viewport_wscalings.len() as _;
        self.raw.pViewportWScalings = viewport_wscalings.as_ptr() as *const vks::VkViewportWScalingNV;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_viewport_wscaling_enable<'a>(&'a self) -> bool {
        self.raw.viewportWScalingEnable != 0
    }

    pub fn get_viewport_wscalings<'a>(&'a self) -> &'a [ViewportWScalingNv] {
        unsafe { slice::from_raw_parts(self.raw.pViewportWScalings as *const _, self.raw.viewportCount as usize) }
    }

    pub fn build(self) -> PipelineViewportWScalingStateCreateInfoNv<'b> {
        PipelineViewportWScalingStateCreateInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkViewportSwizzleNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ViewportSwizzleNv {
    raw: vks::VkViewportSwizzleNV,
}

impl ViewportSwizzleNv {
    pub fn builder() -> ViewportSwizzleNvBuilder {
        ViewportSwizzleNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkViewportSwizzleNV) -> ViewportSwizzleNv {
        ViewportSwizzleNv { raw, }
    }

    pub fn x<'a>(&'a self) -> ViewportCoordinateSwizzleNv {
        self.raw.x.into()
    }

    pub fn y<'a>(&'a self) -> ViewportCoordinateSwizzleNv {
        self.raw.y.into()
    }

    pub fn z<'a>(&'a self) -> ViewportCoordinateSwizzleNv {
        self.raw.z.into()
    }

    pub fn w<'a>(&'a self) -> ViewportCoordinateSwizzleNv {
        self.raw.w.into()
    }

    pub fn set_x<'m>(&mut self, x: ViewportCoordinateSwizzleNv) {
        self.raw.x = x.into();
    }

    pub fn set_y<'m>(&mut self, y: ViewportCoordinateSwizzleNv) {
        self.raw.y = y.into();
    }

    pub fn set_z<'m>(&mut self, z: ViewportCoordinateSwizzleNv) {
        self.raw.z = z.into();
    }

    pub fn set_w<'m>(&mut self, w: ViewportCoordinateSwizzleNv) {
        self.raw.w = w.into();
    }

    pub fn as_raw(&self) -> &vks::VkViewportSwizzleNV {
        &self.raw
    }
}

impl From<ViewportSwizzleNv> for vks::VkViewportSwizzleNV {
    fn from(f: ViewportSwizzleNv) -> vks::VkViewportSwizzleNV {
        f.raw
    }
}


/// A builder for `VkViewportSwizzleNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ViewportSwizzleNvBuilder {
    raw: vks::VkViewportSwizzleNV,
}

impl ViewportSwizzleNvBuilder {
    pub fn new() -> ViewportSwizzleNvBuilder {
        ViewportSwizzleNvBuilder {
            raw: vks::VkViewportSwizzleNV::default(),
        }
    }

    pub fn x<'m>(mut self, x: ViewportCoordinateSwizzleNv) -> ViewportSwizzleNvBuilder {
        self.raw.x = x.into();
        self
    }

    pub fn y<'m>(mut self, y: ViewportCoordinateSwizzleNv) -> ViewportSwizzleNvBuilder {
        self.raw.y = y.into();
        self
    }

    pub fn z<'m>(mut self, z: ViewportCoordinateSwizzleNv) -> ViewportSwizzleNvBuilder {
        self.raw.z = z.into();
        self
    }

    pub fn w<'m>(mut self, w: ViewportCoordinateSwizzleNv) -> ViewportSwizzleNvBuilder {
        self.raw.w = w.into();
        self
    }

    pub fn get_x<'a>(&'a self) -> ViewportCoordinateSwizzleNv {
        self.raw.x.into()
    }

    pub fn get_y<'a>(&'a self) -> ViewportCoordinateSwizzleNv {
        self.raw.y.into()
    }

    pub fn get_z<'a>(&'a self) -> ViewportCoordinateSwizzleNv {
        self.raw.z.into()
    }

    pub fn get_w<'a>(&'a self) -> ViewportCoordinateSwizzleNv {
        self.raw.w.into()
    }

    pub fn build(self) -> ViewportSwizzleNv {
        ViewportSwizzleNv {
            raw: self.raw,
        }
    }
}


/// A `VkPipelineViewportSwizzleStateCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineViewportSwizzleStateCreateInfoNv<'s> {
    raw: vks::VkPipelineViewportSwizzleStateCreateInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineViewportSwizzleStateCreateInfoNv<'s> {
    pub fn builder<'b>() -> PipelineViewportSwizzleStateCreateInfoNvBuilder<'b> {
        PipelineViewportSwizzleStateCreateInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineViewportSwizzleStateCreateInfoNV) -> PipelineViewportSwizzleStateCreateInfoNv<'s> {
        PipelineViewportSwizzleStateCreateInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineViewportSwizzleStateCreateFlagsNv {
        PipelineViewportSwizzleStateCreateFlagsNv::from_bits(self.raw.flags)
            .expect("PipelineViewportSwizzleStateCreateInfoNv::flags: error converting flags")
    }

    pub fn viewport_swizzles<'a>(&'a self) -> &'a [ViewportSwizzleNv] {
        unsafe { slice::from_raw_parts(self.raw.pViewportSwizzles as *const _, self.raw.viewportCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineViewportSwizzleStateCreateFlagsNv) {
        self.raw.flags = flags.bits();
    }

    pub fn set_viewport_swizzles<'m, 'a>(&mut self, viewport_swizzles: &'a [ViewportSwizzleNv])
            where 'a: 's {
        assert!(self.raw.viewportCount == 0 || self.raw.viewportCount == viewport_swizzles.len() as _, 
            "count inconsistency found when specifying `PipelineViewportSwizzleStateCreateInfoNv::viewport_swizzles`.");
        self.raw.viewportCount = viewport_swizzles.len() as _;
        self.raw.pViewportSwizzles = viewport_swizzles.as_ptr() as *const vks::VkViewportSwizzleNV;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineViewportSwizzleStateCreateInfoNV {
        &self.raw
    }
}

impl<'s> From<PipelineViewportSwizzleStateCreateInfoNv<'s>> for vks::VkPipelineViewportSwizzleStateCreateInfoNV {
    fn from(f: PipelineViewportSwizzleStateCreateInfoNv<'s>) -> vks::VkPipelineViewportSwizzleStateCreateInfoNV {
        f.raw
    }
}


/// A builder for `VkPipelineViewportSwizzleStateCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineViewportSwizzleStateCreateInfoNvBuilder<'b> {
    raw: vks::VkPipelineViewportSwizzleStateCreateInfoNV,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineViewportSwizzleStateCreateInfoNvBuilder<'b> {
    pub fn new() -> PipelineViewportSwizzleStateCreateInfoNvBuilder<'b> {
        PipelineViewportSwizzleStateCreateInfoNvBuilder {
            raw: vks::VkPipelineViewportSwizzleStateCreateInfoNV::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineViewportSwizzleStateCreateInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineViewportSwizzleStateCreateFlagsNv) -> PipelineViewportSwizzleStateCreateInfoNvBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn viewport_swizzles<'m, 'a>(mut self, viewport_swizzles: &'a [ViewportSwizzleNv]) -> PipelineViewportSwizzleStateCreateInfoNvBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.viewportCount == 0 || self.raw.viewportCount == viewport_swizzles.len() as _, 
            "count inconsistency found when specifying `PipelineViewportSwizzleStateCreateInfoNv::viewport_swizzles`.");
        self.raw.viewportCount = viewport_swizzles.len() as _;
        self.raw.pViewportSwizzles = viewport_swizzles.as_ptr() as *const vks::VkViewportSwizzleNV;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> PipelineViewportSwizzleStateCreateFlagsNv {
        PipelineViewportSwizzleStateCreateFlagsNv::from_bits(self.raw.flags)
            .expect("PipelineViewportSwizzleStateCreateInfoNv::flags: error converting flags")
    }

    pub fn get_viewport_swizzles<'a>(&'a self) -> &'a [ViewportSwizzleNv] {
        unsafe { slice::from_raw_parts(self.raw.pViewportSwizzles as *const _, self.raw.viewportCount as usize) }
    }

    pub fn build(self) -> PipelineViewportSwizzleStateCreateInfoNv<'b> {
        PipelineViewportSwizzleStateCreateInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceDiscardRectanglePropertiesEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceDiscardRectanglePropertiesExt<'s> {
    raw: vks::VkPhysicalDeviceDiscardRectanglePropertiesEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceDiscardRectanglePropertiesExt<'s> {
    pub fn builder<'b>() -> PhysicalDeviceDiscardRectanglePropertiesExtBuilder<'b> {
        PhysicalDeviceDiscardRectanglePropertiesExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceDiscardRectanglePropertiesEXT) -> PhysicalDeviceDiscardRectanglePropertiesExt<'s> {
        PhysicalDeviceDiscardRectanglePropertiesExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn max_discard_rectangles<'a>(&'a self) -> u32 {
        self.raw.maxDiscardRectangles.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_max_discard_rectangles<'m>(&mut self, max_discard_rectangles: u32) {
        self.raw.maxDiscardRectangles = max_discard_rectangles.into();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceDiscardRectanglePropertiesEXT {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceDiscardRectanglePropertiesExt<'s>> for vks::VkPhysicalDeviceDiscardRectanglePropertiesEXT {
    fn from(f: PhysicalDeviceDiscardRectanglePropertiesExt<'s>) -> vks::VkPhysicalDeviceDiscardRectanglePropertiesEXT {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceDiscardRectanglePropertiesEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceDiscardRectanglePropertiesExtBuilder<'b> {
    raw: vks::VkPhysicalDeviceDiscardRectanglePropertiesEXT,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PhysicalDeviceDiscardRectanglePropertiesExtBuilder<'b> {
    pub fn new() -> PhysicalDeviceDiscardRectanglePropertiesExtBuilder<'b> {
        PhysicalDeviceDiscardRectanglePropertiesExtBuilder {
            raw: vks::VkPhysicalDeviceDiscardRectanglePropertiesEXT::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceDiscardRectanglePropertiesExtBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn max_discard_rectangles<'m>(mut self, max_discard_rectangles: u32) -> PhysicalDeviceDiscardRectanglePropertiesExtBuilder<'b> {
        self.raw.maxDiscardRectangles = max_discard_rectangles.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_max_discard_rectangles<'a>(&'a self) -> u32 {
        self.raw.maxDiscardRectangles.into()
    }

    pub fn build(self) -> PhysicalDeviceDiscardRectanglePropertiesExt<'b> {
        PhysicalDeviceDiscardRectanglePropertiesExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineDiscardRectangleStateCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineDiscardRectangleStateCreateInfoExt<'s> {
    raw: vks::VkPipelineDiscardRectangleStateCreateInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineDiscardRectangleStateCreateInfoExt<'s> {
    pub fn builder<'b>() -> PipelineDiscardRectangleStateCreateInfoExtBuilder<'b> {
        PipelineDiscardRectangleStateCreateInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineDiscardRectangleStateCreateInfoEXT) -> PipelineDiscardRectangleStateCreateInfoExt<'s> {
        PipelineDiscardRectangleStateCreateInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineDiscardRectangleStateCreateFlagsExt {
        PipelineDiscardRectangleStateCreateFlagsExt::from_bits(self.raw.flags)
            .expect("PipelineDiscardRectangleStateCreateInfoExt::flags: error converting flags")
    }

    pub fn discard_rectangle_mode<'a>(&'a self) -> DiscardRectangleModeExt {
        self.raw.discardRectangleMode.into()
    }

    pub fn discard_rectangles<'a>(&'a self) -> &'a [Rect2d] {
        unsafe { slice::from_raw_parts(self.raw.pDiscardRectangles as *const _, self.raw.discardRectangleCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineDiscardRectangleStateCreateFlagsExt) {
        self.raw.flags = flags.bits();
    }

    pub fn set_discard_rectangle_mode<'m>(&mut self, discard_rectangle_mode: DiscardRectangleModeExt) {
        self.raw.discardRectangleMode = discard_rectangle_mode.into();
    }

    pub fn set_discard_rectangles<'m, 'a>(&mut self, discard_rectangles: &'a [Rect2d])
            where 'a: 's {
        assert!(self.raw.discardRectangleCount == 0 || self.raw.discardRectangleCount == discard_rectangles.len() as _, 
            "count inconsistency found when specifying `PipelineDiscardRectangleStateCreateInfoExt::discard_rectangles`.");
        self.raw.discardRectangleCount = discard_rectangles.len() as _;
        self.raw.pDiscardRectangles = discard_rectangles.as_ptr() as *const vks::VkRect2D;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineDiscardRectangleStateCreateInfoEXT {
        &self.raw
    }
}

impl<'s> From<PipelineDiscardRectangleStateCreateInfoExt<'s>> for vks::VkPipelineDiscardRectangleStateCreateInfoEXT {
    fn from(f: PipelineDiscardRectangleStateCreateInfoExt<'s>) -> vks::VkPipelineDiscardRectangleStateCreateInfoEXT {
        f.raw
    }
}


/// A builder for `VkPipelineDiscardRectangleStateCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineDiscardRectangleStateCreateInfoExtBuilder<'b> {
    raw: vks::VkPipelineDiscardRectangleStateCreateInfoEXT,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineDiscardRectangleStateCreateInfoExtBuilder<'b> {
    pub fn new() -> PipelineDiscardRectangleStateCreateInfoExtBuilder<'b> {
        PipelineDiscardRectangleStateCreateInfoExtBuilder {
            raw: vks::VkPipelineDiscardRectangleStateCreateInfoEXT::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineDiscardRectangleStateCreateInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineDiscardRectangleStateCreateFlagsExt) -> PipelineDiscardRectangleStateCreateInfoExtBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn discard_rectangle_mode<'m>(mut self, discard_rectangle_mode: DiscardRectangleModeExt) -> PipelineDiscardRectangleStateCreateInfoExtBuilder<'b> {
        self.raw.discardRectangleMode = discard_rectangle_mode.into();
        self
    }

    pub fn discard_rectangles<'m, 'a>(mut self, discard_rectangles: &'a [Rect2d]) -> PipelineDiscardRectangleStateCreateInfoExtBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.discardRectangleCount == 0 || self.raw.discardRectangleCount == discard_rectangles.len() as _, 
            "count inconsistency found when specifying `PipelineDiscardRectangleStateCreateInfoExt::discard_rectangles`.");
        self.raw.discardRectangleCount = discard_rectangles.len() as _;
        self.raw.pDiscardRectangles = discard_rectangles.as_ptr() as *const vks::VkRect2D;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> PipelineDiscardRectangleStateCreateFlagsExt {
        PipelineDiscardRectangleStateCreateFlagsExt::from_bits(self.raw.flags)
            .expect("PipelineDiscardRectangleStateCreateInfoExt::flags: error converting flags")
    }

    pub fn get_discard_rectangle_mode<'a>(&'a self) -> DiscardRectangleModeExt {
        self.raw.discardRectangleMode.into()
    }

    pub fn get_discard_rectangles<'a>(&'a self) -> &'a [Rect2d] {
        unsafe { slice::from_raw_parts(self.raw.pDiscardRectangles as *const _, self.raw.discardRectangleCount as usize) }
    }

    pub fn build(self) -> PipelineDiscardRectangleStateCreateInfoExt<'b> {
        PipelineDiscardRectangleStateCreateInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx<'s> {
    raw: vks::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx<'s> {
    pub fn builder<'b>() -> PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxBuilder<'b> {
        PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) -> PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx<'s> {
        PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn per_view_position_all_components<'a>(&'a self) -> bool {
        self.raw.perViewPositionAllComponents != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_per_view_position_all_components<'m>(&mut self, per_view_position_all_components: bool) {
        self.raw.perViewPositionAllComponents = per_view_position_all_components as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx<'s>> for vks::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    fn from(f: PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx<'s>) -> vks::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxBuilder<'b> {
    raw: vks::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX,
    _p: PhantomData<&'b ()>, 
}

#[cfg(feature = "experimental")]
impl<'b> PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxBuilder<'b> {
    pub fn new() -> PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxBuilder<'b> {
        PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxBuilder {
            raw: vks::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn per_view_position_all_components<'m>(mut self, per_view_position_all_components: bool) -> PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxBuilder<'b> {
        self.raw.perViewPositionAllComponents = per_view_position_all_components as u32;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_per_view_position_all_components<'a>(&'a self) -> bool {
        self.raw.perViewPositionAllComponents != 0
    }

    pub fn build(self) -> PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx<'b> {
        PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceSurfaceInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceSurfaceInfo2Khr<'s> {
    raw: vks::VkPhysicalDeviceSurfaceInfo2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceSurfaceInfo2Khr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceSurfaceInfo2KhrBuilder<'b> {
        PhysicalDeviceSurfaceInfo2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceSurfaceInfo2KHR) -> PhysicalDeviceSurfaceInfo2Khr<'s> {
        PhysicalDeviceSurfaceInfo2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn surface<'a>(&'a self) -> vks::VkSurfaceKHR {
        self.raw.surface
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_surface<'m, H>(&mut self, surface: H)
            where H: Handle<Target=SurfaceKhrHandle> {
        self.raw.surface = surface.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceSurfaceInfo2KHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceSurfaceInfo2Khr<'s>> for vks::VkPhysicalDeviceSurfaceInfo2KHR {
    fn from(f: PhysicalDeviceSurfaceInfo2Khr<'s>) -> vks::VkPhysicalDeviceSurfaceInfo2KHR {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceSurfaceInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceSurfaceInfo2KhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceSurfaceInfo2KHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PhysicalDeviceSurfaceInfo2KhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceSurfaceInfo2KhrBuilder<'b> {
        PhysicalDeviceSurfaceInfo2KhrBuilder {
            raw: vks::VkPhysicalDeviceSurfaceInfo2KHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PhysicalDeviceSurfaceInfo2KhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn surface<'m, H>(mut self, surface: H) -> PhysicalDeviceSurfaceInfo2KhrBuilder<'b>
            where H: Handle<Target=SurfaceKhrHandle> {
        self.raw.surface = surface.handle().0;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_surface<'a>(&'a self) -> vks::VkSurfaceKHR {
        self.raw.surface
    }

    pub fn build(self) -> PhysicalDeviceSurfaceInfo2Khr<'b> {
        PhysicalDeviceSurfaceInfo2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSurfaceCapabilities2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SurfaceCapabilities2Khr<'s> {
    raw: vks::VkSurfaceCapabilities2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> SurfaceCapabilities2Khr<'s> {
    pub fn builder<'b>() -> SurfaceCapabilities2KhrBuilder<'b> {
        SurfaceCapabilities2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSurfaceCapabilities2KHR) -> SurfaceCapabilities2Khr<'s> {
        SurfaceCapabilities2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn surface_capabilities<'a>(&'a self) -> &'a SurfaceCapabilitiesKhr {
        unsafe { &*(&self.raw.surfaceCapabilities as *const vks::VkSurfaceCapabilitiesKHR as *const SurfaceCapabilitiesKhr) }
    }

    pub fn surface_capabilities_mut<'a>(&'a mut self) -> &'a mut SurfaceCapabilitiesKhr {
        unsafe { &mut *(&mut self.raw.surfaceCapabilities as *mut  vks::VkSurfaceCapabilitiesKHR as *mut SurfaceCapabilitiesKhr) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_surface_capabilities<'m>(&mut self, surface_capabilities: SurfaceCapabilitiesKhr) {
        self.raw.surfaceCapabilities = surface_capabilities.raw;
    }

    pub fn as_raw(&self) -> &vks::VkSurfaceCapabilities2KHR {
        &self.raw
    }
}

impl<'s> From<SurfaceCapabilities2Khr<'s>> for vks::VkSurfaceCapabilities2KHR {
    fn from(f: SurfaceCapabilities2Khr<'s>) -> vks::VkSurfaceCapabilities2KHR {
        f.raw
    }
}


/// A builder for `VkSurfaceCapabilities2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SurfaceCapabilities2KhrBuilder<'b> {
    raw: vks::VkSurfaceCapabilities2KHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SurfaceCapabilities2KhrBuilder<'b> {
    pub fn new() -> SurfaceCapabilities2KhrBuilder<'b> {
        SurfaceCapabilities2KhrBuilder {
            raw: vks::VkSurfaceCapabilities2KHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> SurfaceCapabilities2KhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn surface_capabilities<'m>(mut self, surface_capabilities: SurfaceCapabilitiesKhr) -> SurfaceCapabilities2KhrBuilder<'b> {
        self.raw.surfaceCapabilities = surface_capabilities.raw;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_surface_capabilities<'a>(&'a self) -> &'a SurfaceCapabilitiesKhr {
        unsafe { &*(&self.raw.surfaceCapabilities as *const vks::VkSurfaceCapabilitiesKHR as *const SurfaceCapabilitiesKhr) }
    }

    pub fn get_surface_capabilities_mut<'a>(&'a mut self) -> &'a mut SurfaceCapabilitiesKhr {
        unsafe { &mut *(&mut self.raw.surfaceCapabilities as *mut  vks::VkSurfaceCapabilitiesKHR as *mut SurfaceCapabilitiesKhr) }
    }

    pub fn build(self) -> SurfaceCapabilities2Khr<'b> {
        SurfaceCapabilities2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSurfaceFormat2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SurfaceFormat2Khr<'s> {
    raw: vks::VkSurfaceFormat2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> SurfaceFormat2Khr<'s> {
    pub fn builder<'b>() -> SurfaceFormat2KhrBuilder<'b> {
        SurfaceFormat2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSurfaceFormat2KHR) -> SurfaceFormat2Khr<'s> {
        SurfaceFormat2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn surface_format<'a>(&'a self) -> &'a SurfaceFormatKhr {
        unsafe { &*(&self.raw.surfaceFormat as *const vks::VkSurfaceFormatKHR as *const SurfaceFormatKhr) }
    }

    pub fn surface_format_mut<'a>(&'a mut self) -> &'a mut SurfaceFormatKhr {
        unsafe { &mut *(&mut self.raw.surfaceFormat as *mut  vks::VkSurfaceFormatKHR as *mut SurfaceFormatKhr) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_surface_format<'m>(&mut self, surface_format: SurfaceFormatKhr) {
        self.raw.surfaceFormat = surface_format.raw;
    }

    pub fn as_raw(&self) -> &vks::VkSurfaceFormat2KHR {
        &self.raw
    }
}

impl<'s> From<SurfaceFormat2Khr<'s>> for vks::VkSurfaceFormat2KHR {
    fn from(f: SurfaceFormat2Khr<'s>) -> vks::VkSurfaceFormat2KHR {
        f.raw
    }
}


/// A builder for `VkSurfaceFormat2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SurfaceFormat2KhrBuilder<'b> {
    raw: vks::VkSurfaceFormat2KHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SurfaceFormat2KhrBuilder<'b> {
    pub fn new() -> SurfaceFormat2KhrBuilder<'b> {
        SurfaceFormat2KhrBuilder {
            raw: vks::VkSurfaceFormat2KHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> SurfaceFormat2KhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn surface_format<'m>(mut self, surface_format: SurfaceFormatKhr) -> SurfaceFormat2KhrBuilder<'b> {
        self.raw.surfaceFormat = surface_format.raw;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_surface_format<'a>(&'a self) -> &'a SurfaceFormatKhr {
        unsafe { &*(&self.raw.surfaceFormat as *const vks::VkSurfaceFormatKHR as *const SurfaceFormatKhr) }
    }

    pub fn get_surface_format_mut<'a>(&'a mut self) -> &'a mut SurfaceFormatKhr {
        unsafe { &mut *(&mut self.raw.surfaceFormat as *mut  vks::VkSurfaceFormatKHR as *mut SurfaceFormatKhr) }
    }

    pub fn build(self) -> SurfaceFormat2Khr<'b> {
        SurfaceFormat2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSharedPresentSurfaceCapabilitiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SharedPresentSurfaceCapabilitiesKhr<'s> {
    raw: vks::VkSharedPresentSurfaceCapabilitiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> SharedPresentSurfaceCapabilitiesKhr<'s> {
    pub fn builder<'b>() -> SharedPresentSurfaceCapabilitiesKhrBuilder<'b> {
        SharedPresentSurfaceCapabilitiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSharedPresentSurfaceCapabilitiesKHR) -> SharedPresentSurfaceCapabilitiesKhr<'s> {
        SharedPresentSurfaceCapabilitiesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn shared_present_supported_usage_flags<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.sharedPresentSupportedUsageFlags)
            .expect("SharedPresentSurfaceCapabilitiesKhr::shared_present_supported_usage_flags: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_shared_present_supported_usage_flags<'m>(&mut self, shared_present_supported_usage_flags: ImageUsageFlags) {
        self.raw.sharedPresentSupportedUsageFlags = shared_present_supported_usage_flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSharedPresentSurfaceCapabilitiesKHR {
        &self.raw
    }
}

impl<'s> From<SharedPresentSurfaceCapabilitiesKhr<'s>> for vks::VkSharedPresentSurfaceCapabilitiesKHR {
    fn from(f: SharedPresentSurfaceCapabilitiesKhr<'s>) -> vks::VkSharedPresentSurfaceCapabilitiesKHR {
        f.raw
    }
}


/// A builder for `VkSharedPresentSurfaceCapabilitiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SharedPresentSurfaceCapabilitiesKhrBuilder<'b> {
    raw: vks::VkSharedPresentSurfaceCapabilitiesKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SharedPresentSurfaceCapabilitiesKhrBuilder<'b> {
    pub fn new() -> SharedPresentSurfaceCapabilitiesKhrBuilder<'b> {
        SharedPresentSurfaceCapabilitiesKhrBuilder {
            raw: vks::VkSharedPresentSurfaceCapabilitiesKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> SharedPresentSurfaceCapabilitiesKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn shared_present_supported_usage_flags<'m>(mut self, shared_present_supported_usage_flags: ImageUsageFlags) -> SharedPresentSurfaceCapabilitiesKhrBuilder<'b> {
        self.raw.sharedPresentSupportedUsageFlags = shared_present_supported_usage_flags.bits();
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_shared_present_supported_usage_flags<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.sharedPresentSupportedUsageFlags)
            .expect("SharedPresentSurfaceCapabilitiesKhr::shared_present_supported_usage_flags: error converting flags")
    }

    pub fn build(self) -> SharedPresentSurfaceCapabilitiesKhr<'b> {
        SharedPresentSurfaceCapabilitiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDevice16BitStorageFeaturesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDevice16BitStorageFeaturesKhr<'s> {
    raw: vks::VkPhysicalDevice16BitStorageFeaturesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDevice16BitStorageFeaturesKhr<'s> {
    pub fn builder<'b>() -> PhysicalDevice16BitStorageFeaturesKhrBuilder<'b> {
        PhysicalDevice16BitStorageFeaturesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDevice16BitStorageFeaturesKHR) -> PhysicalDevice16BitStorageFeaturesKhr<'s> {
        PhysicalDevice16BitStorageFeaturesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn storage_buffer_16_bit_access<'a>(&'a self) -> bool {
        self.raw.storageBuffer16BitAccess != 0
    }

    pub fn uniform_and_storage_buffer_16_bit_access<'a>(&'a self) -> bool {
        self.raw.uniformAndStorageBuffer16BitAccess != 0
    }

    pub fn storage_push_constant_16<'a>(&'a self) -> bool {
        self.raw.storagePushConstant16 != 0
    }

    pub fn storage_input_output_16<'a>(&'a self) -> bool {
        self.raw.storageInputOutput16 != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_storage_buffer_16_bit_access<'m>(&mut self, storage_buffer_16_bit_access: bool) {
        self.raw.storageBuffer16BitAccess = storage_buffer_16_bit_access as u32;
    }

    pub fn set_uniform_and_storage_buffer_16_bit_access<'m>(&mut self, uniform_and_storage_buffer_16_bit_access: bool) {
        self.raw.uniformAndStorageBuffer16BitAccess = uniform_and_storage_buffer_16_bit_access as u32;
    }

    pub fn set_storage_push_constant_16<'m>(&mut self, storage_push_constant_16: bool) {
        self.raw.storagePushConstant16 = storage_push_constant_16 as u32;
    }

    pub fn set_storage_input_output_16<'m>(&mut self, storage_input_output_16: bool) {
        self.raw.storageInputOutput16 = storage_input_output_16 as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDevice16BitStorageFeaturesKHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDevice16BitStorageFeaturesKhr<'s>> for vks::VkPhysicalDevice16BitStorageFeaturesKHR {
    fn from(f: PhysicalDevice16BitStorageFeaturesKhr<'s>) -> vks::VkPhysicalDevice16BitStorageFeaturesKHR {
        f.raw
    }
}


/// A builder for `VkPhysicalDevice16BitStorageFeaturesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDevice16BitStorageFeaturesKhrBuilder<'b> {
    raw: vks::VkPhysicalDevice16BitStorageFeaturesKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PhysicalDevice16BitStorageFeaturesKhrBuilder<'b> {
    pub fn new() -> PhysicalDevice16BitStorageFeaturesKhrBuilder<'b> {
        PhysicalDevice16BitStorageFeaturesKhrBuilder {
            raw: vks::VkPhysicalDevice16BitStorageFeaturesKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDevice16BitStorageFeaturesKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn storage_buffer_16_bit_access<'m>(mut self, storage_buffer_16_bit_access: bool) -> PhysicalDevice16BitStorageFeaturesKhrBuilder<'b> {
        self.raw.storageBuffer16BitAccess = storage_buffer_16_bit_access as u32;
        self
    }

    pub fn uniform_and_storage_buffer_16_bit_access<'m>(mut self, uniform_and_storage_buffer_16_bit_access: bool) -> PhysicalDevice16BitStorageFeaturesKhrBuilder<'b> {
        self.raw.uniformAndStorageBuffer16BitAccess = uniform_and_storage_buffer_16_bit_access as u32;
        self
    }

    pub fn storage_push_constant_16<'m>(mut self, storage_push_constant_16: bool) -> PhysicalDevice16BitStorageFeaturesKhrBuilder<'b> {
        self.raw.storagePushConstant16 = storage_push_constant_16 as u32;
        self
    }

    pub fn storage_input_output_16<'m>(mut self, storage_input_output_16: bool) -> PhysicalDevice16BitStorageFeaturesKhrBuilder<'b> {
        self.raw.storageInputOutput16 = storage_input_output_16 as u32;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_storage_buffer_16_bit_access<'a>(&'a self) -> bool {
        self.raw.storageBuffer16BitAccess != 0
    }

    pub fn get_uniform_and_storage_buffer_16_bit_access<'a>(&'a self) -> bool {
        self.raw.uniformAndStorageBuffer16BitAccess != 0
    }

    pub fn get_storage_push_constant_16<'a>(&'a self) -> bool {
        self.raw.storagePushConstant16 != 0
    }

    pub fn get_storage_input_output_16<'a>(&'a self) -> bool {
        self.raw.storageInputOutput16 != 0
    }

    pub fn build(self) -> PhysicalDevice16BitStorageFeaturesKhr<'b> {
        PhysicalDevice16BitStorageFeaturesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkBufferMemoryRequirementsInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct BufferMemoryRequirementsInfo2Khr<'s> {
    raw: vks::VkBufferMemoryRequirementsInfo2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> BufferMemoryRequirementsInfo2Khr<'s> {
    pub fn builder<'b>() -> BufferMemoryRequirementsInfo2KhrBuilder<'b> {
        BufferMemoryRequirementsInfo2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkBufferMemoryRequirementsInfo2KHR) -> BufferMemoryRequirementsInfo2Khr<'s> {
        BufferMemoryRequirementsInfo2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_buffer<'m, H>(&mut self, buffer: H)
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkBufferMemoryRequirementsInfo2KHR {
        &self.raw
    }
}

impl<'s> From<BufferMemoryRequirementsInfo2Khr<'s>> for vks::VkBufferMemoryRequirementsInfo2KHR {
    fn from(f: BufferMemoryRequirementsInfo2Khr<'s>) -> vks::VkBufferMemoryRequirementsInfo2KHR {
        f.raw
    }
}


/// A builder for `VkBufferMemoryRequirementsInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct BufferMemoryRequirementsInfo2KhrBuilder<'b> {
    raw: vks::VkBufferMemoryRequirementsInfo2KHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> BufferMemoryRequirementsInfo2KhrBuilder<'b> {
    pub fn new() -> BufferMemoryRequirementsInfo2KhrBuilder<'b> {
        BufferMemoryRequirementsInfo2KhrBuilder {
            raw: vks::VkBufferMemoryRequirementsInfo2KHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> BufferMemoryRequirementsInfo2KhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn buffer<'m, H>(mut self, buffer: H) -> BufferMemoryRequirementsInfo2KhrBuilder<'b>
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn build(self) -> BufferMemoryRequirementsInfo2Khr<'b> {
        BufferMemoryRequirementsInfo2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImageMemoryRequirementsInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageMemoryRequirementsInfo2Khr<'s> {
    raw: vks::VkImageMemoryRequirementsInfo2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImageMemoryRequirementsInfo2Khr<'s> {
    pub fn builder<'b>() -> ImageMemoryRequirementsInfo2KhrBuilder<'b> {
        ImageMemoryRequirementsInfo2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageMemoryRequirementsInfo2KHR) -> ImageMemoryRequirementsInfo2Khr<'s> {
        ImageMemoryRequirementsInfo2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_image<'m, H>(&mut self, image: H)
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkImageMemoryRequirementsInfo2KHR {
        &self.raw
    }
}

impl<'s> From<ImageMemoryRequirementsInfo2Khr<'s>> for vks::VkImageMemoryRequirementsInfo2KHR {
    fn from(f: ImageMemoryRequirementsInfo2Khr<'s>) -> vks::VkImageMemoryRequirementsInfo2KHR {
        f.raw
    }
}


/// A builder for `VkImageMemoryRequirementsInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageMemoryRequirementsInfo2KhrBuilder<'b> {
    raw: vks::VkImageMemoryRequirementsInfo2KHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ImageMemoryRequirementsInfo2KhrBuilder<'b> {
    pub fn new() -> ImageMemoryRequirementsInfo2KhrBuilder<'b> {
        ImageMemoryRequirementsInfo2KhrBuilder {
            raw: vks::VkImageMemoryRequirementsInfo2KHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImageMemoryRequirementsInfo2KhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn image<'m, H>(mut self, image: H) -> ImageMemoryRequirementsInfo2KhrBuilder<'b>
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn build(self) -> ImageMemoryRequirementsInfo2Khr<'b> {
        ImageMemoryRequirementsInfo2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImageSparseMemoryRequirementsInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageSparseMemoryRequirementsInfo2Khr<'s> {
    raw: vks::VkImageSparseMemoryRequirementsInfo2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImageSparseMemoryRequirementsInfo2Khr<'s> {
    pub fn builder<'b>() -> ImageSparseMemoryRequirementsInfo2KhrBuilder<'b> {
        ImageSparseMemoryRequirementsInfo2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageSparseMemoryRequirementsInfo2KHR) -> ImageSparseMemoryRequirementsInfo2Khr<'s> {
        ImageSparseMemoryRequirementsInfo2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_image<'m, H>(&mut self, image: H)
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkImageSparseMemoryRequirementsInfo2KHR {
        &self.raw
    }
}

impl<'s> From<ImageSparseMemoryRequirementsInfo2Khr<'s>> for vks::VkImageSparseMemoryRequirementsInfo2KHR {
    fn from(f: ImageSparseMemoryRequirementsInfo2Khr<'s>) -> vks::VkImageSparseMemoryRequirementsInfo2KHR {
        f.raw
    }
}


/// A builder for `VkImageSparseMemoryRequirementsInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageSparseMemoryRequirementsInfo2KhrBuilder<'b> {
    raw: vks::VkImageSparseMemoryRequirementsInfo2KHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> ImageSparseMemoryRequirementsInfo2KhrBuilder<'b> {
    pub fn new() -> ImageSparseMemoryRequirementsInfo2KhrBuilder<'b> {
        ImageSparseMemoryRequirementsInfo2KhrBuilder {
            raw: vks::VkImageSparseMemoryRequirementsInfo2KHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImageSparseMemoryRequirementsInfo2KhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn image<'m, H>(mut self, image: H) -> ImageSparseMemoryRequirementsInfo2KhrBuilder<'b>
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn build(self) -> ImageSparseMemoryRequirementsInfo2Khr<'b> {
        ImageSparseMemoryRequirementsInfo2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMemoryRequirements2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryRequirements2Khr<'s> {
    raw: vks::VkMemoryRequirements2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> MemoryRequirements2Khr<'s> {
    pub fn builder<'b>() -> MemoryRequirements2KhrBuilder<'b> {
        MemoryRequirements2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryRequirements2KHR) -> MemoryRequirements2Khr<'s> {
        MemoryRequirements2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn memory_requirements<'a>(&'a self) -> &'a MemoryRequirements {
        unsafe { &*(&self.raw.memoryRequirements as *const vks::VkMemoryRequirements as *const MemoryRequirements) }
    }

    pub fn memory_requirements_mut<'a>(&'a mut self) -> &'a mut MemoryRequirements {
        unsafe { &mut *(&mut self.raw.memoryRequirements as *mut  vks::VkMemoryRequirements as *mut MemoryRequirements) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_memory_requirements<'m>(&mut self, memory_requirements: MemoryRequirements) {
        self.raw.memoryRequirements = memory_requirements.raw;
    }

    pub fn as_raw(&self) -> &vks::VkMemoryRequirements2KHR {
        &self.raw
    }
}

impl<'s> From<MemoryRequirements2Khr<'s>> for vks::VkMemoryRequirements2KHR {
    fn from(f: MemoryRequirements2Khr<'s>) -> vks::VkMemoryRequirements2KHR {
        f.raw
    }
}


/// A builder for `VkMemoryRequirements2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryRequirements2KhrBuilder<'b> {
    raw: vks::VkMemoryRequirements2KHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> MemoryRequirements2KhrBuilder<'b> {
    pub fn new() -> MemoryRequirements2KhrBuilder<'b> {
        MemoryRequirements2KhrBuilder {
            raw: vks::VkMemoryRequirements2KHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> MemoryRequirements2KhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn memory_requirements<'m>(mut self, memory_requirements: MemoryRequirements) -> MemoryRequirements2KhrBuilder<'b> {
        self.raw.memoryRequirements = memory_requirements.raw;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_memory_requirements<'a>(&'a self) -> &'a MemoryRequirements {
        unsafe { &*(&self.raw.memoryRequirements as *const vks::VkMemoryRequirements as *const MemoryRequirements) }
    }

    pub fn get_memory_requirements_mut<'a>(&'a mut self) -> &'a mut MemoryRequirements {
        unsafe { &mut *(&mut self.raw.memoryRequirements as *mut  vks::VkMemoryRequirements as *mut MemoryRequirements) }
    }

    pub fn build(self) -> MemoryRequirements2Khr<'b> {
        MemoryRequirements2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSparseImageMemoryRequirements2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SparseImageMemoryRequirements2Khr<'s> {
    raw: vks::VkSparseImageMemoryRequirements2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> SparseImageMemoryRequirements2Khr<'s> {
    pub fn builder<'b>() -> SparseImageMemoryRequirements2KhrBuilder<'b> {
        SparseImageMemoryRequirements2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSparseImageMemoryRequirements2KHR) -> SparseImageMemoryRequirements2Khr<'s> {
        SparseImageMemoryRequirements2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn memory_requirements<'a>(&'a self) -> &'a SparseImageMemoryRequirements {
        unsafe { &*(&self.raw.memoryRequirements as *const vks::VkSparseImageMemoryRequirements as *const SparseImageMemoryRequirements) }
    }

    pub fn memory_requirements_mut<'a>(&'a mut self) -> &'a mut SparseImageMemoryRequirements {
        unsafe { &mut *(&mut self.raw.memoryRequirements as *mut  vks::VkSparseImageMemoryRequirements as *mut SparseImageMemoryRequirements) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_memory_requirements<'m>(&mut self, memory_requirements: SparseImageMemoryRequirements) {
        self.raw.memoryRequirements = memory_requirements.raw;
    }

    pub fn as_raw(&self) -> &vks::VkSparseImageMemoryRequirements2KHR {
        &self.raw
    }
}

impl<'s> From<SparseImageMemoryRequirements2Khr<'s>> for vks::VkSparseImageMemoryRequirements2KHR {
    fn from(f: SparseImageMemoryRequirements2Khr<'s>) -> vks::VkSparseImageMemoryRequirements2KHR {
        f.raw
    }
}


/// A builder for `VkSparseImageMemoryRequirements2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SparseImageMemoryRequirements2KhrBuilder<'b> {
    raw: vks::VkSparseImageMemoryRequirements2KHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SparseImageMemoryRequirements2KhrBuilder<'b> {
    pub fn new() -> SparseImageMemoryRequirements2KhrBuilder<'b> {
        SparseImageMemoryRequirements2KhrBuilder {
            raw: vks::VkSparseImageMemoryRequirements2KHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> SparseImageMemoryRequirements2KhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn memory_requirements<'m>(mut self, memory_requirements: SparseImageMemoryRequirements) -> SparseImageMemoryRequirements2KhrBuilder<'b> {
        self.raw.memoryRequirements = memory_requirements.raw;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_memory_requirements<'a>(&'a self) -> &'a SparseImageMemoryRequirements {
        unsafe { &*(&self.raw.memoryRequirements as *const vks::VkSparseImageMemoryRequirements as *const SparseImageMemoryRequirements) }
    }

    pub fn get_memory_requirements_mut<'a>(&'a mut self) -> &'a mut SparseImageMemoryRequirements {
        unsafe { &mut *(&mut self.raw.memoryRequirements as *mut  vks::VkSparseImageMemoryRequirements as *mut SparseImageMemoryRequirements) }
    }

    pub fn build(self) -> SparseImageMemoryRequirements2Khr<'b> {
        SparseImageMemoryRequirements2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMemoryDedicatedRequirementsKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryDedicatedRequirementsKhr<'s> {
    raw: vks::VkMemoryDedicatedRequirementsKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> MemoryDedicatedRequirementsKhr<'s> {
    pub fn builder<'b>() -> MemoryDedicatedRequirementsKhrBuilder<'b> {
        MemoryDedicatedRequirementsKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryDedicatedRequirementsKHR) -> MemoryDedicatedRequirementsKhr<'s> {
        MemoryDedicatedRequirementsKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn prefers_dedicated_allocation<'a>(&'a self) -> bool {
        self.raw.prefersDedicatedAllocation != 0
    }

    pub fn requires_dedicated_allocation<'a>(&'a self) -> bool {
        self.raw.requiresDedicatedAllocation != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_prefers_dedicated_allocation<'m>(&mut self, prefers_dedicated_allocation: bool) {
        self.raw.prefersDedicatedAllocation = prefers_dedicated_allocation as u32;
    }

    pub fn set_requires_dedicated_allocation<'m>(&mut self, requires_dedicated_allocation: bool) {
        self.raw.requiresDedicatedAllocation = requires_dedicated_allocation as u32;
    }

    pub fn as_raw(&self) -> &vks::VkMemoryDedicatedRequirementsKHR {
        &self.raw
    }
}

impl<'s> From<MemoryDedicatedRequirementsKhr<'s>> for vks::VkMemoryDedicatedRequirementsKHR {
    fn from(f: MemoryDedicatedRequirementsKhr<'s>) -> vks::VkMemoryDedicatedRequirementsKHR {
        f.raw
    }
}


/// A builder for `VkMemoryDedicatedRequirementsKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryDedicatedRequirementsKhrBuilder<'b> {
    raw: vks::VkMemoryDedicatedRequirementsKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> MemoryDedicatedRequirementsKhrBuilder<'b> {
    pub fn new() -> MemoryDedicatedRequirementsKhrBuilder<'b> {
        MemoryDedicatedRequirementsKhrBuilder {
            raw: vks::VkMemoryDedicatedRequirementsKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> MemoryDedicatedRequirementsKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn prefers_dedicated_allocation<'m>(mut self, prefers_dedicated_allocation: bool) -> MemoryDedicatedRequirementsKhrBuilder<'b> {
        self.raw.prefersDedicatedAllocation = prefers_dedicated_allocation as u32;
        self
    }

    pub fn requires_dedicated_allocation<'m>(mut self, requires_dedicated_allocation: bool) -> MemoryDedicatedRequirementsKhrBuilder<'b> {
        self.raw.requiresDedicatedAllocation = requires_dedicated_allocation as u32;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_prefers_dedicated_allocation<'a>(&'a self) -> bool {
        self.raw.prefersDedicatedAllocation != 0
    }

    pub fn get_requires_dedicated_allocation<'a>(&'a self) -> bool {
        self.raw.requiresDedicatedAllocation != 0
    }

    pub fn build(self) -> MemoryDedicatedRequirementsKhr<'b> {
        MemoryDedicatedRequirementsKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMemoryDedicatedAllocateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryDedicatedAllocateInfoKhr<'s> {
    raw: vks::VkMemoryDedicatedAllocateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> MemoryDedicatedAllocateInfoKhr<'s> {
    pub fn builder<'b>() -> MemoryDedicatedAllocateInfoKhrBuilder<'b> {
        MemoryDedicatedAllocateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryDedicatedAllocateInfoKHR) -> MemoryDedicatedAllocateInfoKhr<'s> {
        MemoryDedicatedAllocateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_image<'m, H>(&mut self, image: H)
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
    }

    pub fn set_buffer<'m, H>(&mut self, buffer: H)
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkMemoryDedicatedAllocateInfoKHR {
        &self.raw
    }
}

impl<'s> From<MemoryDedicatedAllocateInfoKhr<'s>> for vks::VkMemoryDedicatedAllocateInfoKHR {
    fn from(f: MemoryDedicatedAllocateInfoKhr<'s>) -> vks::VkMemoryDedicatedAllocateInfoKHR {
        f.raw
    }
}


/// A builder for `VkMemoryDedicatedAllocateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryDedicatedAllocateInfoKhrBuilder<'b> {
    raw: vks::VkMemoryDedicatedAllocateInfoKHR,
    _p: PhantomData<&'b ()>, 
}

impl<'b> MemoryDedicatedAllocateInfoKhrBuilder<'b> {
    pub fn new() -> MemoryDedicatedAllocateInfoKhrBuilder<'b> {
        MemoryDedicatedAllocateInfoKhrBuilder {
            raw: vks::VkMemoryDedicatedAllocateInfoKHR::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> MemoryDedicatedAllocateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn image<'m, H>(mut self, image: H) -> MemoryDedicatedAllocateInfoKhrBuilder<'b>
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
        self
    }

    pub fn buffer<'m, H>(mut self, buffer: H) -> MemoryDedicatedAllocateInfoKhrBuilder<'b>
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn get_buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn build(self) -> MemoryDedicatedAllocateInfoKhr<'b> {
        MemoryDedicatedAllocateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkTextureLODGatherFormatPropertiesAMD`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct TextureLODGatherFormatPropertiesAmd<'s> {
    raw: vks::VkTextureLODGatherFormatPropertiesAMD,
    _p: PhantomData<&'s ()>,
}

impl<'s> TextureLODGatherFormatPropertiesAmd<'s> {
    pub fn builder<'b>() -> TextureLODGatherFormatPropertiesAmdBuilder<'b> {
        TextureLODGatherFormatPropertiesAmdBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkTextureLODGatherFormatPropertiesAMD) -> TextureLODGatherFormatPropertiesAmd<'s> {
        TextureLODGatherFormatPropertiesAmd { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn supports_texture_gather_lodbias_amd<'a>(&'a self) -> bool {
        self.raw.supportsTextureGatherLODBiasAMD != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_supports_texture_gather_lodbias_amd<'m>(&mut self, supports_texture_gather_lodbias_amd: bool) {
        self.raw.supportsTextureGatherLODBiasAMD = supports_texture_gather_lodbias_amd as u32;
    }

    pub fn as_raw(&self) -> &vks::VkTextureLODGatherFormatPropertiesAMD {
        &self.raw
    }
}

impl<'s> From<TextureLODGatherFormatPropertiesAmd<'s>> for vks::VkTextureLODGatherFormatPropertiesAMD {
    fn from(f: TextureLODGatherFormatPropertiesAmd<'s>) -> vks::VkTextureLODGatherFormatPropertiesAMD {
        f.raw
    }
}


/// A builder for `VkTextureLODGatherFormatPropertiesAMD`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct TextureLODGatherFormatPropertiesAmdBuilder<'b> {
    raw: vks::VkTextureLODGatherFormatPropertiesAMD,
    _p: PhantomData<&'b ()>, 
}

impl<'b> TextureLODGatherFormatPropertiesAmdBuilder<'b> {
    pub fn new() -> TextureLODGatherFormatPropertiesAmdBuilder<'b> {
        TextureLODGatherFormatPropertiesAmdBuilder {
            raw: vks::VkTextureLODGatherFormatPropertiesAMD::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> TextureLODGatherFormatPropertiesAmdBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn supports_texture_gather_lodbias_amd<'m>(mut self, supports_texture_gather_lodbias_amd: bool) -> TextureLODGatherFormatPropertiesAmdBuilder<'b> {
        self.raw.supportsTextureGatherLODBiasAMD = supports_texture_gather_lodbias_amd as u32;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_supports_texture_gather_lodbias_amd<'a>(&'a self) -> bool {
        self.raw.supportsTextureGatherLODBiasAMD != 0
    }

    pub fn build(self) -> TextureLODGatherFormatPropertiesAmd<'b> {
        TextureLODGatherFormatPropertiesAmd {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineCoverageToColorStateCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineCoverageToColorStateCreateInfoNv<'s> {
    raw: vks::VkPipelineCoverageToColorStateCreateInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineCoverageToColorStateCreateInfoNv<'s> {
    pub fn builder<'b>() -> PipelineCoverageToColorStateCreateInfoNvBuilder<'b> {
        PipelineCoverageToColorStateCreateInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineCoverageToColorStateCreateInfoNV) -> PipelineCoverageToColorStateCreateInfoNv<'s> {
        PipelineCoverageToColorStateCreateInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineCoverageToColorStateCreateFlagsNv {
        PipelineCoverageToColorStateCreateFlagsNv::from_bits(self.raw.flags)
            .expect("PipelineCoverageToColorStateCreateInfoNv::flags: error converting flags")
    }

    pub fn coverage_to_color_enable<'a>(&'a self) -> bool {
        self.raw.coverageToColorEnable != 0
    }

    pub fn coverage_to_color_location<'a>(&'a self) -> u32 {
        self.raw.coverageToColorLocation.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineCoverageToColorStateCreateFlagsNv) {
        self.raw.flags = flags.bits();
    }

    pub fn set_coverage_to_color_enable<'m>(&mut self, coverage_to_color_enable: bool) {
        self.raw.coverageToColorEnable = coverage_to_color_enable as u32;
    }

    pub fn set_coverage_to_color_location<'m>(&mut self, coverage_to_color_location: u32) {
        self.raw.coverageToColorLocation = coverage_to_color_location.into();
    }

    pub fn as_raw(&self) -> &vks::VkPipelineCoverageToColorStateCreateInfoNV {
        &self.raw
    }
}

impl<'s> From<PipelineCoverageToColorStateCreateInfoNv<'s>> for vks::VkPipelineCoverageToColorStateCreateInfoNV {
    fn from(f: PipelineCoverageToColorStateCreateInfoNv<'s>) -> vks::VkPipelineCoverageToColorStateCreateInfoNV {
        f.raw
    }
}


/// A builder for `VkPipelineCoverageToColorStateCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineCoverageToColorStateCreateInfoNvBuilder<'b> {
    raw: vks::VkPipelineCoverageToColorStateCreateInfoNV,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineCoverageToColorStateCreateInfoNvBuilder<'b> {
    pub fn new() -> PipelineCoverageToColorStateCreateInfoNvBuilder<'b> {
        PipelineCoverageToColorStateCreateInfoNvBuilder {
            raw: vks::VkPipelineCoverageToColorStateCreateInfoNV::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineCoverageToColorStateCreateInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineCoverageToColorStateCreateFlagsNv) -> PipelineCoverageToColorStateCreateInfoNvBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn coverage_to_color_enable<'m>(mut self, coverage_to_color_enable: bool) -> PipelineCoverageToColorStateCreateInfoNvBuilder<'b> {
        self.raw.coverageToColorEnable = coverage_to_color_enable as u32;
        self
    }

    pub fn coverage_to_color_location<'m>(mut self, coverage_to_color_location: u32) -> PipelineCoverageToColorStateCreateInfoNvBuilder<'b> {
        self.raw.coverageToColorLocation = coverage_to_color_location.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> PipelineCoverageToColorStateCreateFlagsNv {
        PipelineCoverageToColorStateCreateFlagsNv::from_bits(self.raw.flags)
            .expect("PipelineCoverageToColorStateCreateInfoNv::flags: error converting flags")
    }

    pub fn get_coverage_to_color_enable<'a>(&'a self) -> bool {
        self.raw.coverageToColorEnable != 0
    }

    pub fn get_coverage_to_color_location<'a>(&'a self) -> u32 {
        self.raw.coverageToColorLocation.into()
    }

    pub fn build(self) -> PipelineCoverageToColorStateCreateInfoNv<'b> {
        PipelineCoverageToColorStateCreateInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceSamplerFilterMinmaxPropertiesExt<'s> {
    raw: vks::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceSamplerFilterMinmaxPropertiesExt<'s> {
    pub fn builder<'b>() -> PhysicalDeviceSamplerFilterMinmaxPropertiesExtBuilder<'b> {
        PhysicalDeviceSamplerFilterMinmaxPropertiesExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT) -> PhysicalDeviceSamplerFilterMinmaxPropertiesExt<'s> {
        PhysicalDeviceSamplerFilterMinmaxPropertiesExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn filter_minmax_single_component_formats<'a>(&'a self) -> bool {
        self.raw.filterMinmaxSingleComponentFormats != 0
    }

    pub fn filter_minmax_image_component_mapping<'a>(&'a self) -> bool {
        self.raw.filterMinmaxImageComponentMapping != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_filter_minmax_single_component_formats<'m>(&mut self, filter_minmax_single_component_formats: bool) {
        self.raw.filterMinmaxSingleComponentFormats = filter_minmax_single_component_formats as u32;
    }

    pub fn set_filter_minmax_image_component_mapping<'m>(&mut self, filter_minmax_image_component_mapping: bool) {
        self.raw.filterMinmaxImageComponentMapping = filter_minmax_image_component_mapping as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceSamplerFilterMinmaxPropertiesExt<'s>> for vks::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
    fn from(f: PhysicalDeviceSamplerFilterMinmaxPropertiesExt<'s>) -> vks::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceSamplerFilterMinmaxPropertiesExtBuilder<'b> {
    raw: vks::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PhysicalDeviceSamplerFilterMinmaxPropertiesExtBuilder<'b> {
    pub fn new() -> PhysicalDeviceSamplerFilterMinmaxPropertiesExtBuilder<'b> {
        PhysicalDeviceSamplerFilterMinmaxPropertiesExtBuilder {
            raw: vks::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceSamplerFilterMinmaxPropertiesExtBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn filter_minmax_single_component_formats<'m>(mut self, filter_minmax_single_component_formats: bool) -> PhysicalDeviceSamplerFilterMinmaxPropertiesExtBuilder<'b> {
        self.raw.filterMinmaxSingleComponentFormats = filter_minmax_single_component_formats as u32;
        self
    }

    pub fn filter_minmax_image_component_mapping<'m>(mut self, filter_minmax_image_component_mapping: bool) -> PhysicalDeviceSamplerFilterMinmaxPropertiesExtBuilder<'b> {
        self.raw.filterMinmaxImageComponentMapping = filter_minmax_image_component_mapping as u32;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_filter_minmax_single_component_formats<'a>(&'a self) -> bool {
        self.raw.filterMinmaxSingleComponentFormats != 0
    }

    pub fn get_filter_minmax_image_component_mapping<'a>(&'a self) -> bool {
        self.raw.filterMinmaxImageComponentMapping != 0
    }

    pub fn build(self) -> PhysicalDeviceSamplerFilterMinmaxPropertiesExt<'b> {
        PhysicalDeviceSamplerFilterMinmaxPropertiesExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSamplerReductionModeCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SamplerReductionModeCreateInfoExt<'s> {
    raw: vks::VkSamplerReductionModeCreateInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> SamplerReductionModeCreateInfoExt<'s> {
    pub fn builder<'b>() -> SamplerReductionModeCreateInfoExtBuilder<'b> {
        SamplerReductionModeCreateInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSamplerReductionModeCreateInfoEXT) -> SamplerReductionModeCreateInfoExt<'s> {
        SamplerReductionModeCreateInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn reduction_mode<'a>(&'a self) -> SamplerReductionModeExt {
        self.raw.reductionMode.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_reduction_mode<'m>(&mut self, reduction_mode: SamplerReductionModeExt) {
        self.raw.reductionMode = reduction_mode.into();
    }

    pub fn as_raw(&self) -> &vks::VkSamplerReductionModeCreateInfoEXT {
        &self.raw
    }
}

impl<'s> From<SamplerReductionModeCreateInfoExt<'s>> for vks::VkSamplerReductionModeCreateInfoEXT {
    fn from(f: SamplerReductionModeCreateInfoExt<'s>) -> vks::VkSamplerReductionModeCreateInfoEXT {
        f.raw
    }
}


/// A builder for `VkSamplerReductionModeCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SamplerReductionModeCreateInfoExtBuilder<'b> {
    raw: vks::VkSamplerReductionModeCreateInfoEXT,
    _p: PhantomData<&'b ()>, 
}

impl<'b> SamplerReductionModeCreateInfoExtBuilder<'b> {
    pub fn new() -> SamplerReductionModeCreateInfoExtBuilder<'b> {
        SamplerReductionModeCreateInfoExtBuilder {
            raw: vks::VkSamplerReductionModeCreateInfoEXT::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> SamplerReductionModeCreateInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn reduction_mode<'m>(mut self, reduction_mode: SamplerReductionModeExt) -> SamplerReductionModeCreateInfoExtBuilder<'b> {
        self.raw.reductionMode = reduction_mode.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_reduction_mode<'a>(&'a self) -> SamplerReductionModeExt {
        self.raw.reductionMode.into()
    }

    pub fn build(self) -> SamplerReductionModeCreateInfoExt<'b> {
        SamplerReductionModeCreateInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceBlendOperationAdvancedFeaturesExt<'s> {
    raw: vks::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceBlendOperationAdvancedFeaturesExt<'s> {
    pub fn builder<'b>() -> PhysicalDeviceBlendOperationAdvancedFeaturesExtBuilder<'b> {
        PhysicalDeviceBlendOperationAdvancedFeaturesExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT) -> PhysicalDeviceBlendOperationAdvancedFeaturesExt<'s> {
        PhysicalDeviceBlendOperationAdvancedFeaturesExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn advanced_blend_coherent_operations<'a>(&'a self) -> bool {
        self.raw.advancedBlendCoherentOperations != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_advanced_blend_coherent_operations<'m>(&mut self, advanced_blend_coherent_operations: bool) {
        self.raw.advancedBlendCoherentOperations = advanced_blend_coherent_operations as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceBlendOperationAdvancedFeaturesExt<'s>> for vks::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    fn from(f: PhysicalDeviceBlendOperationAdvancedFeaturesExt<'s>) -> vks::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceBlendOperationAdvancedFeaturesExtBuilder<'b> {
    raw: vks::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PhysicalDeviceBlendOperationAdvancedFeaturesExtBuilder<'b> {
    pub fn new() -> PhysicalDeviceBlendOperationAdvancedFeaturesExtBuilder<'b> {
        PhysicalDeviceBlendOperationAdvancedFeaturesExtBuilder {
            raw: vks::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceBlendOperationAdvancedFeaturesExtBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn advanced_blend_coherent_operations<'m>(mut self, advanced_blend_coherent_operations: bool) -> PhysicalDeviceBlendOperationAdvancedFeaturesExtBuilder<'b> {
        self.raw.advancedBlendCoherentOperations = advanced_blend_coherent_operations as u32;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_advanced_blend_coherent_operations<'a>(&'a self) -> bool {
        self.raw.advancedBlendCoherentOperations != 0
    }

    pub fn build(self) -> PhysicalDeviceBlendOperationAdvancedFeaturesExt<'b> {
        PhysicalDeviceBlendOperationAdvancedFeaturesExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceBlendOperationAdvancedPropertiesExt<'s> {
    raw: vks::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceBlendOperationAdvancedPropertiesExt<'s> {
    pub fn builder<'b>() -> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
        PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT) -> PhysicalDeviceBlendOperationAdvancedPropertiesExt<'s> {
        PhysicalDeviceBlendOperationAdvancedPropertiesExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn advanced_blend_max_color_attachments<'a>(&'a self) -> u32 {
        self.raw.advancedBlendMaxColorAttachments.into()
    }

    pub fn advanced_blend_independent_blend<'a>(&'a self) -> bool {
        self.raw.advancedBlendIndependentBlend != 0
    }

    pub fn advanced_blend_non_premultiplied_src_color<'a>(&'a self) -> bool {
        self.raw.advancedBlendNonPremultipliedSrcColor != 0
    }

    pub fn advanced_blend_non_premultiplied_dst_color<'a>(&'a self) -> bool {
        self.raw.advancedBlendNonPremultipliedDstColor != 0
    }

    pub fn advanced_blend_correlated_overlap<'a>(&'a self) -> bool {
        self.raw.advancedBlendCorrelatedOverlap != 0
    }

    pub fn advanced_blend_all_operations<'a>(&'a self) -> bool {
        self.raw.advancedBlendAllOperations != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_advanced_blend_max_color_attachments<'m>(&mut self, advanced_blend_max_color_attachments: u32) {
        self.raw.advancedBlendMaxColorAttachments = advanced_blend_max_color_attachments.into();
    }

    pub fn set_advanced_blend_independent_blend<'m>(&mut self, advanced_blend_independent_blend: bool) {
        self.raw.advancedBlendIndependentBlend = advanced_blend_independent_blend as u32;
    }

    pub fn set_advanced_blend_non_premultiplied_src_color<'m>(&mut self, advanced_blend_non_premultiplied_src_color: bool) {
        self.raw.advancedBlendNonPremultipliedSrcColor = advanced_blend_non_premultiplied_src_color as u32;
    }

    pub fn set_advanced_blend_non_premultiplied_dst_color<'m>(&mut self, advanced_blend_non_premultiplied_dst_color: bool) {
        self.raw.advancedBlendNonPremultipliedDstColor = advanced_blend_non_premultiplied_dst_color as u32;
    }

    pub fn set_advanced_blend_correlated_overlap<'m>(&mut self, advanced_blend_correlated_overlap: bool) {
        self.raw.advancedBlendCorrelatedOverlap = advanced_blend_correlated_overlap as u32;
    }

    pub fn set_advanced_blend_all_operations<'m>(&mut self, advanced_blend_all_operations: bool) {
        self.raw.advancedBlendAllOperations = advanced_blend_all_operations as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceBlendOperationAdvancedPropertiesExt<'s>> for vks::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    fn from(f: PhysicalDeviceBlendOperationAdvancedPropertiesExt<'s>) -> vks::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
        f.raw
    }
}


/// A builder for `VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
    raw: vks::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
    pub fn new() -> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
        PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder {
            raw: vks::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn advanced_blend_max_color_attachments<'m>(mut self, advanced_blend_max_color_attachments: u32) -> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
        self.raw.advancedBlendMaxColorAttachments = advanced_blend_max_color_attachments.into();
        self
    }

    pub fn advanced_blend_independent_blend<'m>(mut self, advanced_blend_independent_blend: bool) -> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
        self.raw.advancedBlendIndependentBlend = advanced_blend_independent_blend as u32;
        self
    }

    pub fn advanced_blend_non_premultiplied_src_color<'m>(mut self, advanced_blend_non_premultiplied_src_color: bool) -> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
        self.raw.advancedBlendNonPremultipliedSrcColor = advanced_blend_non_premultiplied_src_color as u32;
        self
    }

    pub fn advanced_blend_non_premultiplied_dst_color<'m>(mut self, advanced_blend_non_premultiplied_dst_color: bool) -> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
        self.raw.advancedBlendNonPremultipliedDstColor = advanced_blend_non_premultiplied_dst_color as u32;
        self
    }

    pub fn advanced_blend_correlated_overlap<'m>(mut self, advanced_blend_correlated_overlap: bool) -> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
        self.raw.advancedBlendCorrelatedOverlap = advanced_blend_correlated_overlap as u32;
        self
    }

    pub fn advanced_blend_all_operations<'m>(mut self, advanced_blend_all_operations: bool) -> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
        self.raw.advancedBlendAllOperations = advanced_blend_all_operations as u32;
        self
    }

    pub fn get_next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn get_advanced_blend_max_color_attachments<'a>(&'a self) -> u32 {
        self.raw.advancedBlendMaxColorAttachments.into()
    }

    pub fn get_advanced_blend_independent_blend<'a>(&'a self) -> bool {
        self.raw.advancedBlendIndependentBlend != 0
    }

    pub fn get_advanced_blend_non_premultiplied_src_color<'a>(&'a self) -> bool {
        self.raw.advancedBlendNonPremultipliedSrcColor != 0
    }

    pub fn get_advanced_blend_non_premultiplied_dst_color<'a>(&'a self) -> bool {
        self.raw.advancedBlendNonPremultipliedDstColor != 0
    }

    pub fn get_advanced_blend_correlated_overlap<'a>(&'a self) -> bool {
        self.raw.advancedBlendCorrelatedOverlap != 0
    }

    pub fn get_advanced_blend_all_operations<'a>(&'a self) -> bool {
        self.raw.advancedBlendAllOperations != 0
    }

    pub fn build(self) -> PhysicalDeviceBlendOperationAdvancedPropertiesExt<'b> {
        PhysicalDeviceBlendOperationAdvancedPropertiesExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineColorBlendAdvancedStateCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineColorBlendAdvancedStateCreateInfoExt<'s> {
    raw: vks::VkPipelineColorBlendAdvancedStateCreateInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineColorBlendAdvancedStateCreateInfoExt<'s> {
    pub fn builder<'b>() -> PipelineColorBlendAdvancedStateCreateInfoExtBuilder<'b> {
        PipelineColorBlendAdvancedStateCreateInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineColorBlendAdvancedStateCreateInfoEXT) -> PipelineColorBlendAdvancedStateCreateInfoExt<'s> {
        PipelineColorBlendAdvancedStateCreateInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn src_premultiplied<'a>(&'a self) -> bool {
        self.raw.srcPremultiplied != 0
    }

    pub fn dst_premultiplied<'a>(&'a self) -> bool {
        self.raw.dstPremultiplied != 0
    }

    pub fn blend_overlap<'a>(&'a self) -> BlendOverlapExt {
        self.raw.blendOverlap.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_src_premultiplied<'m>(&mut self, src_premultiplied: bool) {
        self.raw.srcPremultiplied = src_premultiplied as u32;
    }

    pub fn set_dst_premultiplied<'m>(&mut self, dst_premultiplied: bool) {
        self.raw.dstPremultiplied = dst_premultiplied as u32;
    }

    pub fn set_blend_overlap<'m>(&mut self, blend_overlap: BlendOverlapExt) {
        self.raw.blendOverlap = blend_overlap.into();
    }

    pub fn as_raw(&self) -> &vks::VkPipelineColorBlendAdvancedStateCreateInfoEXT {
        &self.raw
    }
}

impl<'s> From<PipelineColorBlendAdvancedStateCreateInfoExt<'s>> for vks::VkPipelineColorBlendAdvancedStateCreateInfoEXT {
    fn from(f: PipelineColorBlendAdvancedStateCreateInfoExt<'s>) -> vks::VkPipelineColorBlendAdvancedStateCreateInfoEXT {
        f.raw
    }
}


/// A builder for `VkPipelineColorBlendAdvancedStateCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineColorBlendAdvancedStateCreateInfoExtBuilder<'b> {
    raw: vks::VkPipelineColorBlendAdvancedStateCreateInfoEXT,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineColorBlendAdvancedStateCreateInfoExtBuilder<'b> {
    pub fn new() -> PipelineColorBlendAdvancedStateCreateInfoExtBuilder<'b> {
        PipelineColorBlendAdvancedStateCreateInfoExtBuilder {
            raw: vks::VkPipelineColorBlendAdvancedStateCreateInfoEXT::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineColorBlendAdvancedStateCreateInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn src_premultiplied<'m>(mut self, src_premultiplied: bool) -> PipelineColorBlendAdvancedStateCreateInfoExtBuilder<'b> {
        self.raw.srcPremultiplied = src_premultiplied as u32;
        self
    }

    pub fn dst_premultiplied<'m>(mut self, dst_premultiplied: bool) -> PipelineColorBlendAdvancedStateCreateInfoExtBuilder<'b> {
        self.raw.dstPremultiplied = dst_premultiplied as u32;
        self
    }

    pub fn blend_overlap<'m>(mut self, blend_overlap: BlendOverlapExt) -> PipelineColorBlendAdvancedStateCreateInfoExtBuilder<'b> {
        self.raw.blendOverlap = blend_overlap.into();
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_src_premultiplied<'a>(&'a self) -> bool {
        self.raw.srcPremultiplied != 0
    }

    pub fn get_dst_premultiplied<'a>(&'a self) -> bool {
        self.raw.dstPremultiplied != 0
    }

    pub fn get_blend_overlap<'a>(&'a self) -> BlendOverlapExt {
        self.raw.blendOverlap.into()
    }

    pub fn build(self) -> PipelineColorBlendAdvancedStateCreateInfoExt<'b> {
        PipelineColorBlendAdvancedStateCreateInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineCoverageModulationStateCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineCoverageModulationStateCreateInfoNv<'s> {
    raw: vks::VkPipelineCoverageModulationStateCreateInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineCoverageModulationStateCreateInfoNv<'s> {
    pub fn builder<'b>() -> PipelineCoverageModulationStateCreateInfoNvBuilder<'b> {
        PipelineCoverageModulationStateCreateInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineCoverageModulationStateCreateInfoNV) -> PipelineCoverageModulationStateCreateInfoNv<'s> {
        PipelineCoverageModulationStateCreateInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineCoverageModulationStateCreateFlagsNv {
        PipelineCoverageModulationStateCreateFlagsNv::from_bits(self.raw.flags)
            .expect("PipelineCoverageModulationStateCreateInfoNv::flags: error converting flags")
    }

    pub fn coverage_modulation_mode<'a>(&'a self) -> CoverageModulationModeNv {
        self.raw.coverageModulationMode.into()
    }

    pub fn coverage_modulation_table_enable<'a>(&'a self) -> bool {
        self.raw.coverageModulationTableEnable != 0
    }

    pub fn coverage_modulation_table<'a>(&'a self) -> &'a [f32] {
        unsafe { slice::from_raw_parts(self.raw.pCoverageModulationTable as *const _, self.raw.coverageModulationTableCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineCoverageModulationStateCreateFlagsNv) {
        self.raw.flags = flags.bits();
    }

    pub fn set_coverage_modulation_mode<'m>(&mut self, coverage_modulation_mode: CoverageModulationModeNv) {
        self.raw.coverageModulationMode = coverage_modulation_mode.into();
    }

    pub fn set_coverage_modulation_table_enable<'m>(&mut self, coverage_modulation_table_enable: bool) {
        self.raw.coverageModulationTableEnable = coverage_modulation_table_enable as u32;
    }

    pub fn set_coverage_modulation_table<'m, 'a>(&mut self, coverage_modulation_table: &'a [f32])
            where 'a: 's {
        assert!(self.raw.coverageModulationTableCount == 0 || self.raw.coverageModulationTableCount == coverage_modulation_table.len() as _, 
            "count inconsistency found when specifying `PipelineCoverageModulationStateCreateInfoNv::coverage_modulation_table`.");
        self.raw.coverageModulationTableCount = coverage_modulation_table.len() as _;
        self.raw.pCoverageModulationTable = coverage_modulation_table.as_ptr() as *const f32 as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineCoverageModulationStateCreateInfoNV {
        &self.raw
    }
}

impl<'s> From<PipelineCoverageModulationStateCreateInfoNv<'s>> for vks::VkPipelineCoverageModulationStateCreateInfoNV {
    fn from(f: PipelineCoverageModulationStateCreateInfoNv<'s>) -> vks::VkPipelineCoverageModulationStateCreateInfoNV {
        f.raw
    }
}


/// A builder for `VkPipelineCoverageModulationStateCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineCoverageModulationStateCreateInfoNvBuilder<'b> {
    raw: vks::VkPipelineCoverageModulationStateCreateInfoNV,
    _p: PhantomData<&'b ()>, 
}

impl<'b> PipelineCoverageModulationStateCreateInfoNvBuilder<'b> {
    pub fn new() -> PipelineCoverageModulationStateCreateInfoNvBuilder<'b> {
        PipelineCoverageModulationStateCreateInfoNvBuilder {
            raw: vks::VkPipelineCoverageModulationStateCreateInfoNV::default(),
            _p: PhantomData,
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineCoverageModulationStateCreateInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineCoverageModulationStateCreateFlagsNv) -> PipelineCoverageModulationStateCreateInfoNvBuilder<'b> {
        self.raw.flags = flags.bits();
        self
    }

    pub fn coverage_modulation_mode<'m>(mut self, coverage_modulation_mode: CoverageModulationModeNv) -> PipelineCoverageModulationStateCreateInfoNvBuilder<'b> {
        self.raw.coverageModulationMode = coverage_modulation_mode.into();
        self
    }

    pub fn coverage_modulation_table_enable<'m>(mut self, coverage_modulation_table_enable: bool) -> PipelineCoverageModulationStateCreateInfoNvBuilder<'b> {
        self.raw.coverageModulationTableEnable = coverage_modulation_table_enable as u32;
        self
    }

    pub fn coverage_modulation_table<'m, 'a>(mut self, coverage_modulation_table: &'a [f32]) -> PipelineCoverageModulationStateCreateInfoNvBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.coverageModulationTableCount == 0 || self.raw.coverageModulationTableCount == coverage_modulation_table.len() as _, 
            "count inconsistency found when specifying `PipelineCoverageModulationStateCreateInfoNv::coverage_modulation_table`.");
        self.raw.coverageModulationTableCount = coverage_modulation_table.len() as _;
        self.raw.pCoverageModulationTable = coverage_modulation_table.as_ptr() as *const f32 as *const _;
        self
    }

    pub fn get_next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn get_flags<'a>(&'a self) -> PipelineCoverageModulationStateCreateFlagsNv {
        PipelineCoverageModulationStateCreateFlagsNv::from_bits(self.raw.flags)
            .expect("PipelineCoverageModulationStateCreateInfoNv::flags: error converting flags")
    }

    pub fn get_coverage_modulation_mode<'a>(&'a self) -> CoverageModulationModeNv {
        self.raw.coverageModulationMode.into()
    }

    pub fn get_coverage_modulation_table_enable<'a>(&'a self) -> bool {
        self.raw.coverageModulationTableEnable != 0
    }

    pub fn get_coverage_modulation_table<'a>(&'a self) -> &'a [f32] {
        unsafe { slice::from_raw_parts(self.raw.pCoverageModulationTable as *const _, self.raw.coverageModulationTableCount as usize) }
    }

    pub fn build(self) -> PipelineCoverageModulationStateCreateInfoNv<'b> {
        PipelineCoverageModulationStateCreateInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


